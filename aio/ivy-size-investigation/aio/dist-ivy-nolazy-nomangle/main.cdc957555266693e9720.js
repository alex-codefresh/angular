(window.webpackJsonp = window.webpackJsonp || []).push([ [ 1 ], {
    0: function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__("zUnb");
    },
    crnd: function(module, exports) {
        function webpackEmptyAsyncContext(req) {
            return Promise.resolve().then(function() {
                var e = new Error("Cannot find module '" + req + "'");
                throw e.code = "MODULE_NOT_FOUND", e;
            });
        }
        webpackEmptyAsyncContext.keys = function() {
            return [];
        }, webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext, module.exports = webpackEmptyAsyncContext, 
        webpackEmptyAsyncContext.id = "crnd";
    },
    zUnb: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        var extendStatics = function(d, b) {
            return (extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            })(d, b);
        };
        function __extends(d, b) {
            function __() {
                this.constructor = d;
            }
            extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
            new __());
        }
        var __assign = function() {
            return (__assign = Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) for (var p in s = arguments[i]) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
                return t;
            }).apply(this, arguments);
        };
        function __decorate(decorators, target, key, desc) {
            var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
            return c > 3 && r && Object.defineProperty(target, key, r), r;
        }
        function __metadata(metadataKey, metadataValue) {
            if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(metadataKey, metadataValue);
        }
        function __values(o) {
            var m = "function" == typeof Symbol && o[Symbol.iterator], i = 0;
            return m ? m.call(o) : {
                next: function() {
                    return o && i >= o.length && (o = void 0), {
                        value: o && o[i++],
                        done: !o
                    };
                }
            };
        }
        function __read(o, n) {
            var m = "function" == typeof Symbol && o[Symbol.iterator];
            if (!m) return o;
            var r, e, i = m.call(o), ar = [];
            try {
                for (;(void 0 === n || n-- > 0) && !(r = i.next()).done; ) ar.push(r.value);
            } catch (error) {
                e = {
                    error: error
                };
            } finally {
                try {
                    r && !r.done && (m = i.return) && m.call(i);
                } finally {
                    if (e) throw e.error;
                }
            }
            return ar;
        }
        function __spread() {
            for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
            return ar;
        }
        var isArray = Array.isArray || function(x) {
            return x && "number" == typeof x.length;
        };
        function isObject(x) {
            return null !== x && "object" == typeof x;
        }
        function isFunction(x) {
            return "function" == typeof x;
        }
        function UnsubscriptionErrorImpl(errors) {
            return Error.call(this), this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
                return i + 1 + ") " + err.toString();
            }).join("\n  ") : "", this.name = "UnsubscriptionError", this.errors = errors, this;
        }
        UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);
        var UnsubscriptionError = UnsubscriptionErrorImpl, Subscription_Subscription = function() {
            function Subscription(unsubscribe) {
                this.closed = !1, this._parent = null, this._parents = null, this._subscriptions = null, 
                unsubscribe && (this._unsubscribe = unsubscribe);
            }
            var empty;
            return Subscription.prototype.unsubscribe = function() {
                var errors, hasErrors = !1;
                if (!this.closed) {
                    var _parent = this._parent, _parents = this._parents, _unsubscribe = this._unsubscribe, _subscriptions = this._subscriptions;
                    this.closed = !0, this._parent = null, this._parents = null, this._subscriptions = null;
                    for (var index = -1, len = _parents ? _parents.length : 0; _parent; ) _parent.remove(this), 
                    _parent = ++index < len && _parents[index] || null;
                    if (isFunction(_unsubscribe)) try {
                        _unsubscribe.call(this);
                    } catch (e) {
                        hasErrors = !0, errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [ e ];
                    }
                    if (isArray(_subscriptions)) for (index = -1, len = _subscriptions.length; ++index < len; ) {
                        var sub = _subscriptions[index];
                        if (isObject(sub)) try {
                            sub.unsubscribe();
                        } catch (e) {
                            hasErrors = !0, errors = errors || [], e instanceof UnsubscriptionError ? errors = errors.concat(flattenUnsubscriptionErrors(e.errors)) : errors.push(e);
                        }
                    }
                    if (hasErrors) throw new UnsubscriptionError(errors);
                }
            }, Subscription.prototype.add = function(teardown) {
                var subscription = teardown;
                switch (typeof teardown) {
                  case "function":
                    subscription = new Subscription(teardown);

                  case "object":
                    if (subscription === this || subscription.closed || "function" != typeof subscription.unsubscribe) return subscription;
                    if (this.closed) return subscription.unsubscribe(), subscription;
                    if (!(subscription instanceof Subscription)) {
                        var tmp = subscription;
                        (subscription = new Subscription())._subscriptions = [ tmp ];
                    }
                    break;

                  default:
                    if (!teardown) return Subscription.EMPTY;
                    throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
                }
                if (subscription._addParent(this)) {
                    var subscriptions = this._subscriptions;
                    subscriptions ? subscriptions.push(subscription) : this._subscriptions = [ subscription ];
                }
                return subscription;
            }, Subscription.prototype.remove = function(subscription) {
                var subscriptions = this._subscriptions;
                if (subscriptions) {
                    var subscriptionIndex = subscriptions.indexOf(subscription);
                    -1 !== subscriptionIndex && subscriptions.splice(subscriptionIndex, 1);
                }
            }, Subscription.prototype._addParent = function(parent) {
                var _parent = this._parent, _parents = this._parents;
                return _parent !== parent && (_parent ? _parents ? -1 === _parents.indexOf(parent) && (_parents.push(parent), 
                !0) : (this._parents = [ parent ], !0) : (this._parent = parent, !0));
            }, Subscription.EMPTY = ((empty = new Subscription()).closed = !0, empty), Subscription;
        }();
        function flattenUnsubscriptionErrors(errors) {
            return errors.reduce(function(errs, err) {
                return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
            }, []);
        }
        var _enable_super_gross_mode_that_will_cause_bad_things = !1, config_config = {
            Promise: void 0,
            set useDeprecatedSynchronousErrorHandling(value) {
                _enable_super_gross_mode_that_will_cause_bad_things = value;
            },
            get useDeprecatedSynchronousErrorHandling() {
                return _enable_super_gross_mode_that_will_cause_bad_things;
            }
        };
        function hostReportError(err) {
            setTimeout(function() {
                throw err;
            });
        }
        var empty = {
            closed: !0,
            next: function(value) {},
            error: function(err) {
                if (config_config.useDeprecatedSynchronousErrorHandling) throw err;
                hostReportError(err);
            },
            complete: function() {}
        }, rxSubscriber = "function" == typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random(), Subscriber_Subscriber = function(_super) {
            function Subscriber(destinationOrNext, error, complete) {
                var _this = _super.call(this) || this;
                switch (_this.syncErrorValue = null, _this.syncErrorThrown = !1, _this.syncErrorThrowable = !1, 
                _this.isStopped = !1, arguments.length) {
                  case 0:
                    _this.destination = empty;
                    break;

                  case 1:
                    if (!destinationOrNext) {
                        _this.destination = empty;
                        break;
                    }
                    if ("object" == typeof destinationOrNext) {
                        destinationOrNext instanceof Subscriber ? (_this.syncErrorThrowable = destinationOrNext.syncErrorThrowable, 
                        _this.destination = destinationOrNext, destinationOrNext.add(_this)) : (_this.syncErrorThrowable = !0, 
                        _this.destination = new Subscriber_SafeSubscriber(_this, destinationOrNext));
                        break;
                    }

                  default:
                    _this.syncErrorThrowable = !0, _this.destination = new Subscriber_SafeSubscriber(_this, destinationOrNext, error, complete);
                }
                return _this;
            }
            return __extends(Subscriber, _super), Subscriber.prototype[rxSubscriber] = function() {
                return this;
            }, Subscriber.create = function(next, error, complete) {
                var subscriber = new Subscriber(next, error, complete);
                return subscriber.syncErrorThrowable = !1, subscriber;
            }, Subscriber.prototype.next = function(value) {
                this.isStopped || this._next(value);
            }, Subscriber.prototype.error = function(err) {
                this.isStopped || (this.isStopped = !0, this._error(err));
            }, Subscriber.prototype.complete = function() {
                this.isStopped || (this.isStopped = !0, this._complete());
            }, Subscriber.prototype.unsubscribe = function() {
                this.closed || (this.isStopped = !0, _super.prototype.unsubscribe.call(this));
            }, Subscriber.prototype._next = function(value) {
                this.destination.next(value);
            }, Subscriber.prototype._error = function(err) {
                this.destination.error(err), this.unsubscribe();
            }, Subscriber.prototype._complete = function() {
                this.destination.complete(), this.unsubscribe();
            }, Subscriber.prototype._unsubscribeAndRecycle = function() {
                var _parent = this._parent, _parents = this._parents;
                return this._parent = null, this._parents = null, this.unsubscribe(), this.closed = !1, 
                this.isStopped = !1, this._parent = _parent, this._parents = _parents, this;
            }, Subscriber;
        }(Subscription_Subscription), Subscriber_SafeSubscriber = function(_super) {
            function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
                var next, _this = _super.call(this) || this;
                _this._parentSubscriber = _parentSubscriber;
                var context = _this;
                return isFunction(observerOrNext) ? next = observerOrNext : observerOrNext && (next = observerOrNext.next, 
                error = observerOrNext.error, complete = observerOrNext.complete, observerOrNext !== empty && (isFunction((context = Object.create(observerOrNext)).unsubscribe) && _this.add(context.unsubscribe.bind(context)), 
                context.unsubscribe = _this.unsubscribe.bind(_this))), _this._context = context, 
                _this._next = next, _this._error = error, _this._complete = complete, _this;
            }
            return __extends(SafeSubscriber, _super), SafeSubscriber.prototype.next = function(value) {
                if (!this.isStopped && this._next) {
                    var _parentSubscriber = this._parentSubscriber;
                    config_config.useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable ? this.__tryOrSetError(_parentSubscriber, this._next, value) && this.unsubscribe() : this.__tryOrUnsub(this._next, value);
                }
            }, SafeSubscriber.prototype.error = function(err) {
                if (!this.isStopped) {
                    var _parentSubscriber = this._parentSubscriber, useDeprecatedSynchronousErrorHandling = config_config.useDeprecatedSynchronousErrorHandling;
                    if (this._error) useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable ? (this.__tryOrSetError(_parentSubscriber, this._error, err), 
                    this.unsubscribe()) : (this.__tryOrUnsub(this._error, err), this.unsubscribe()); else if (_parentSubscriber.syncErrorThrowable) useDeprecatedSynchronousErrorHandling ? (_parentSubscriber.syncErrorValue = err, 
                    _parentSubscriber.syncErrorThrown = !0) : hostReportError(err), this.unsubscribe(); else {
                        if (this.unsubscribe(), useDeprecatedSynchronousErrorHandling) throw err;
                        hostReportError(err);
                    }
                }
            }, SafeSubscriber.prototype.complete = function() {
                var _this = this;
                if (!this.isStopped) {
                    var _parentSubscriber = this._parentSubscriber;
                    if (this._complete) {
                        var wrappedComplete = function() {
                            return _this._complete.call(_this._context);
                        };
                        config_config.useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable ? (this.__tryOrSetError(_parentSubscriber, wrappedComplete), 
                        this.unsubscribe()) : (this.__tryOrUnsub(wrappedComplete), this.unsubscribe());
                    } else this.unsubscribe();
                }
            }, SafeSubscriber.prototype.__tryOrUnsub = function(fn, value) {
                try {
                    fn.call(this._context, value);
                } catch (err) {
                    if (this.unsubscribe(), config_config.useDeprecatedSynchronousErrorHandling) throw err;
                    hostReportError(err);
                }
            }, SafeSubscriber.prototype.__tryOrSetError = function(parent, fn, value) {
                if (!config_config.useDeprecatedSynchronousErrorHandling) throw new Error("bad call");
                try {
                    fn.call(this._context, value);
                } catch (err) {
                    return config_config.useDeprecatedSynchronousErrorHandling ? (parent.syncErrorValue = err, 
                    parent.syncErrorThrown = !0, !0) : (hostReportError(err), !0);
                }
                return !1;
            }, SafeSubscriber.prototype._unsubscribe = function() {
                var _parentSubscriber = this._parentSubscriber;
                this._context = null, this._parentSubscriber = null, _parentSubscriber.unsubscribe();
            }, SafeSubscriber;
        }(Subscriber_Subscriber), observable_observable = "function" == typeof Symbol && Symbol.observable || "@@observable";
        function noop() {}
        var Observable_Observable = function() {
            function Observable(subscribe) {
                this._isScalar = !1, subscribe && (this._subscribe = subscribe);
            }
            return Observable.prototype.lift = function(operator) {
                var observable = new Observable();
                return observable.source = this, observable.operator = operator, observable;
            }, Observable.prototype.subscribe = function(observerOrNext, error, complete) {
                var operator = this.operator, sink = function(nextOrObserver, error, complete) {
                    if (nextOrObserver) {
                        if (nextOrObserver instanceof Subscriber_Subscriber) return nextOrObserver;
                        if (nextOrObserver[rxSubscriber]) return nextOrObserver[rxSubscriber]();
                    }
                    return nextOrObserver || error || complete ? new Subscriber_Subscriber(nextOrObserver, error, complete) : new Subscriber_Subscriber(empty);
                }(observerOrNext, error, complete);
                if (sink.add(operator ? operator.call(sink, this.source) : this.source || config_config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink)), 
                config_config.useDeprecatedSynchronousErrorHandling && sink.syncErrorThrowable && (sink.syncErrorThrowable = !1, 
                sink.syncErrorThrown)) throw sink.syncErrorValue;
                return sink;
            }, Observable.prototype._trySubscribe = function(sink) {
                try {
                    return this._subscribe(sink);
                } catch (err) {
                    config_config.useDeprecatedSynchronousErrorHandling && (sink.syncErrorThrown = !0, 
                    sink.syncErrorValue = err), function(observer) {
                        for (;observer; ) {
                            var destination = observer.destination;
                            if (observer.closed || observer.isStopped) return !1;
                            observer = destination && destination instanceof Subscriber_Subscriber ? destination : null;
                        }
                        return !0;
                    }(sink) ? sink.error(err) : console.warn(err);
                }
            }, Observable.prototype.forEach = function(next, promiseCtor) {
                var _this = this;
                return new (promiseCtor = getPromiseCtor(promiseCtor))(function(resolve, reject) {
                    var subscription;
                    subscription = _this.subscribe(function(value) {
                        try {
                            next(value);
                        } catch (err) {
                            reject(err), subscription && subscription.unsubscribe();
                        }
                    }, reject, resolve);
                });
            }, Observable.prototype._subscribe = function(subscriber) {
                var source = this.source;
                return source && source.subscribe(subscriber);
            }, Observable.prototype[observable_observable] = function() {
                return this;
            }, Observable.prototype.pipe = function() {
                for (var operations = [], _i = 0; _i < arguments.length; _i++) operations[_i] = arguments[_i];
                return 0 === operations.length ? this : ((fns = operations) ? 1 === fns.length ? fns[0] : function(input) {
                    return fns.reduce(function(prev, fn) {
                        return fn(prev);
                    }, input);
                } : noop)(this);
                var fns;
            }, Observable.prototype.toPromise = function(promiseCtor) {
                var _this = this;
                return new (promiseCtor = getPromiseCtor(promiseCtor))(function(resolve, reject) {
                    var value;
                    _this.subscribe(function(x) {
                        return value = x;
                    }, function(err) {
                        return reject(err);
                    }, function() {
                        return resolve(value);
                    });
                });
            }, Observable.create = function(subscribe) {
                return new Observable(subscribe);
            }, Observable;
        }();
        function getPromiseCtor(promiseCtor) {
            if (promiseCtor || (promiseCtor = config_config.Promise || Promise), !promiseCtor) throw new Error("no Promise impl found");
            return promiseCtor;
        }
        function ObjectUnsubscribedErrorImpl() {
            return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", 
            this;
        }
        ObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype);
        var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl, SubjectSubscription_SubjectSubscription = function(_super) {
            function SubjectSubscription(subject, subscriber) {
                var _this = _super.call(this) || this;
                return _this.subject = subject, _this.subscriber = subscriber, _this.closed = !1, 
                _this;
            }
            return __extends(SubjectSubscription, _super), SubjectSubscription.prototype.unsubscribe = function() {
                if (!this.closed) {
                    this.closed = !0;
                    var subject = this.subject, observers = subject.observers;
                    if (this.subject = null, observers && 0 !== observers.length && !subject.isStopped && !subject.closed) {
                        var subscriberIndex = observers.indexOf(this.subscriber);
                        -1 !== subscriberIndex && observers.splice(subscriberIndex, 1);
                    }
                }
            }, SubjectSubscription;
        }(Subscription_Subscription), Subject_SubjectSubscriber = function(_super) {
            function SubjectSubscriber(destination) {
                var _this = _super.call(this, destination) || this;
                return _this.destination = destination, _this;
            }
            return __extends(SubjectSubscriber, _super), SubjectSubscriber;
        }(Subscriber_Subscriber), Subject_Subject = function(_super) {
            function Subject() {
                var _this = _super.call(this) || this;
                return _this.observers = [], _this.closed = !1, _this.isStopped = !1, _this.hasError = !1, 
                _this.thrownError = null, _this;
            }
            return __extends(Subject, _super), Subject.prototype[rxSubscriber] = function() {
                return new Subject_SubjectSubscriber(this);
            }, Subject.prototype.lift = function(operator) {
                var subject = new Subject_AnonymousSubject(this, this);
                return subject.operator = operator, subject;
            }, Subject.prototype.next = function(value) {
                if (this.closed) throw new ObjectUnsubscribedError();
                if (!this.isStopped) for (var observers = this.observers, len = observers.length, copy = observers.slice(), i = 0; i < len; i++) copy[i].next(value);
            }, Subject.prototype.error = function(err) {
                if (this.closed) throw new ObjectUnsubscribedError();
                this.hasError = !0, this.thrownError = err, this.isStopped = !0;
                for (var observers = this.observers, len = observers.length, copy = observers.slice(), i = 0; i < len; i++) copy[i].error(err);
                this.observers.length = 0;
            }, Subject.prototype.complete = function() {
                if (this.closed) throw new ObjectUnsubscribedError();
                this.isStopped = !0;
                for (var observers = this.observers, len = observers.length, copy = observers.slice(), i = 0; i < len; i++) copy[i].complete();
                this.observers.length = 0;
            }, Subject.prototype.unsubscribe = function() {
                this.isStopped = !0, this.closed = !0, this.observers = null;
            }, Subject.prototype._trySubscribe = function(subscriber) {
                if (this.closed) throw new ObjectUnsubscribedError();
                return _super.prototype._trySubscribe.call(this, subscriber);
            }, Subject.prototype._subscribe = function(subscriber) {
                if (this.closed) throw new ObjectUnsubscribedError();
                return this.hasError ? (subscriber.error(this.thrownError), Subscription_Subscription.EMPTY) : this.isStopped ? (subscriber.complete(), 
                Subscription_Subscription.EMPTY) : (this.observers.push(subscriber), new SubjectSubscription_SubjectSubscription(this, subscriber));
            }, Subject.prototype.asObservable = function() {
                var observable = new Observable_Observable();
                return observable.source = this, observable;
            }, Subject.create = function(destination, source) {
                return new Subject_AnonymousSubject(destination, source);
            }, Subject;
        }(Observable_Observable), Subject_AnonymousSubject = function(_super) {
            function AnonymousSubject(destination, source) {
                var _this = _super.call(this) || this;
                return _this.destination = destination, _this.source = source, _this;
            }
            return __extends(AnonymousSubject, _super), AnonymousSubject.prototype.next = function(value) {
                var destination = this.destination;
                destination && destination.next && destination.next(value);
            }, AnonymousSubject.prototype.error = function(err) {
                var destination = this.destination;
                destination && destination.error && this.destination.error(err);
            }, AnonymousSubject.prototype.complete = function() {
                var destination = this.destination;
                destination && destination.complete && this.destination.complete();
            }, AnonymousSubject.prototype._subscribe = function(subscriber) {
                return this.source ? this.source.subscribe(subscriber) : Subscription_Subscription.EMPTY;
            }, AnonymousSubject;
        }(Subject_Subject);
        function isScheduler(value) {
            return value && "function" == typeof value.schedule;
        }
        var InnerSubscriber_InnerSubscriber = function(_super) {
            function InnerSubscriber(parent, outerValue, outerIndex) {
                var _this = _super.call(this) || this;
                return _this.parent = parent, _this.outerValue = outerValue, _this.outerIndex = outerIndex, 
                _this.index = 0, _this;
            }
            return __extends(InnerSubscriber, _super), InnerSubscriber.prototype._next = function(value) {
                this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
            }, InnerSubscriber.prototype._error = function(error) {
                this.parent.notifyError(error, this), this.unsubscribe();
            }, InnerSubscriber.prototype._complete = function() {
                this.parent.notifyComplete(this), this.unsubscribe();
            }, InnerSubscriber;
        }(Subscriber_Subscriber), subscribeToArray = function(array) {
            return function(subscriber) {
                for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) subscriber.next(array[i]);
                subscriber.closed || subscriber.complete();
            };
        }, subscribeToPromise = function(promise) {
            return function(subscriber) {
                return promise.then(function(value) {
                    subscriber.closed || (subscriber.next(value), subscriber.complete());
                }, function(err) {
                    return subscriber.error(err);
                }).then(null, hostReportError), subscriber;
            };
        };
        function getSymbolIterator() {
            return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator";
        }
        var iterator_iterator = getSymbolIterator(), subscribeToIterable = function(iterable) {
            return function(subscriber) {
                for (var iterator = iterable[iterator_iterator](); ;) {
                    var item = iterator.next();
                    if (item.done) {
                        subscriber.complete();
                        break;
                    }
                    if (subscriber.next(item.value), subscriber.closed) break;
                }
                return "function" == typeof iterator.return && subscriber.add(function() {
                    iterator.return && iterator.return();
                }), subscriber;
            };
        }, subscribeToObservable = function(obj) {
            return function(subscriber) {
                var obs = obj[observable_observable]();
                if ("function" != typeof obs.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable");
                return obs.subscribe(subscriber);
            };
        }, isArrayLike = function(x) {
            return x && "number" == typeof x.length && "function" != typeof x;
        };
        function isPromise(value) {
            return !!value && "function" != typeof value.subscribe && "function" == typeof value.then;
        }
        var subscribeTo = function(result) {
            if (result instanceof Observable_Observable) return function(subscriber) {
                return result._isScalar ? (subscriber.next(result.value), void subscriber.complete()) : result.subscribe(subscriber);
            };
            if (result && "function" == typeof result[observable_observable]) return subscribeToObservable(result);
            if (isArrayLike(result)) return subscribeToArray(result);
            if (isPromise(result)) return subscribeToPromise(result);
            if (result && "function" == typeof result[iterator_iterator]) return subscribeToIterable(result);
            var value = isObject(result) ? "an invalid object" : "'" + result + "'";
            throw new TypeError("You provided " + value + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.");
        };
        function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination) {
            if (void 0 === destination && (destination = new InnerSubscriber_InnerSubscriber(outerSubscriber, outerValue, outerIndex)), 
            !destination.closed) return subscribeTo(result)(destination);
        }
        var OuterSubscriber_OuterSubscriber = function(_super) {
            function OuterSubscriber() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return __extends(OuterSubscriber, _super), OuterSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            }, OuterSubscriber.prototype.notifyError = function(error, innerSub) {
                this.destination.error(error);
            }, OuterSubscriber.prototype.notifyComplete = function(innerSub) {
                this.destination.complete();
            }, OuterSubscriber;
        }(Subscriber_Subscriber);
        function map_map(project, thisArg) {
            return function(source) {
                if ("function" != typeof project) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
                return source.lift(new MapOperator(project, thisArg));
            };
        }
        var MapOperator = function() {
            function MapOperator(project, thisArg) {
                this.project = project, this.thisArg = thisArg;
            }
            return MapOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new map_MapSubscriber(subscriber, this.project, this.thisArg));
            }, MapOperator;
        }(), map_MapSubscriber = function(_super) {
            function MapSubscriber(destination, project, thisArg) {
                var _this = _super.call(this, destination) || this;
                return _this.project = project, _this.count = 0, _this.thisArg = thisArg || _this, 
                _this;
            }
            return __extends(MapSubscriber, _super), MapSubscriber.prototype._next = function(value) {
                var result;
                try {
                    result = this.project.call(this.thisArg, value, this.count++);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.next(result);
            }, MapSubscriber;
        }(Subscriber_Subscriber);
        function fromArray(input, scheduler) {
            return new Observable_Observable(scheduler ? function(subscriber) {
                var sub = new Subscription_Subscription(), i = 0;
                return sub.add(scheduler.schedule(function() {
                    i !== input.length ? (subscriber.next(input[i++]), subscriber.closed || sub.add(this.schedule())) : subscriber.complete();
                })), sub;
            } : subscribeToArray(input));
        }
        function from_from(input, scheduler) {
            if (!scheduler) return input instanceof Observable_Observable ? input : new Observable_Observable(subscribeTo(input));
            if (null != input) {
                if (function(input) {
                    return input && "function" == typeof input[observable_observable];
                }(input)) return function(input, scheduler) {
                    return new Observable_Observable(scheduler ? function(subscriber) {
                        var sub = new Subscription_Subscription();
                        return sub.add(scheduler.schedule(function() {
                            var observable = input[observable_observable]();
                            sub.add(observable.subscribe({
                                next: function(value) {
                                    sub.add(scheduler.schedule(function() {
                                        return subscriber.next(value);
                                    }));
                                },
                                error: function(err) {
                                    sub.add(scheduler.schedule(function() {
                                        return subscriber.error(err);
                                    }));
                                },
                                complete: function() {
                                    sub.add(scheduler.schedule(function() {
                                        return subscriber.complete();
                                    }));
                                }
                            }));
                        })), sub;
                    } : subscribeToObservable(input));
                }(input, scheduler);
                if (isPromise(input)) return function(input, scheduler) {
                    return new Observable_Observable(scheduler ? function(subscriber) {
                        var sub = new Subscription_Subscription();
                        return sub.add(scheduler.schedule(function() {
                            return input.then(function(value) {
                                sub.add(scheduler.schedule(function() {
                                    subscriber.next(value), sub.add(scheduler.schedule(function() {
                                        return subscriber.complete();
                                    }));
                                }));
                            }, function(err) {
                                sub.add(scheduler.schedule(function() {
                                    return subscriber.error(err);
                                }));
                            });
                        })), sub;
                    } : subscribeToPromise(input));
                }(input, scheduler);
                if (isArrayLike(input)) return fromArray(input, scheduler);
                if (function(input) {
                    return input && "function" == typeof input[iterator_iterator];
                }(input) || "string" == typeof input) return function(input, scheduler) {
                    if (!input) throw new Error("Iterable cannot be null");
                    return new Observable_Observable(scheduler ? function(subscriber) {
                        var iterator, sub = new Subscription_Subscription();
                        return sub.add(function() {
                            iterator && "function" == typeof iterator.return && iterator.return();
                        }), sub.add(scheduler.schedule(function() {
                            iterator = input[iterator_iterator](), sub.add(scheduler.schedule(function() {
                                if (!subscriber.closed) {
                                    var value, done;
                                    try {
                                        var result = iterator.next();
                                        value = result.value, done = result.done;
                                    } catch (err) {
                                        return void subscriber.error(err);
                                    }
                                    done ? subscriber.complete() : (subscriber.next(value), this.schedule());
                                }
                            }));
                        })), sub;
                    } : subscribeToIterable(input));
                }(input, scheduler);
            }
            throw new TypeError((null !== input && typeof input || input) + " is not observable");
        }
        function mergeMap(project, resultSelector, concurrent) {
            return void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY), "function" == typeof resultSelector ? function(source) {
                return source.pipe(mergeMap(function(a, i) {
                    return from_from(project(a, i)).pipe(map_map(function(b, ii) {
                        return resultSelector(a, b, i, ii);
                    }));
                }, concurrent));
            } : ("number" == typeof resultSelector && (concurrent = resultSelector), function(source) {
                return source.lift(new MergeMapOperator(project, concurrent));
            });
        }
        var MergeMapOperator = function() {
            function MergeMapOperator(project, concurrent) {
                void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY), this.project = project, 
                this.concurrent = concurrent;
            }
            return MergeMapOperator.prototype.call = function(observer, source) {
                return source.subscribe(new mergeMap_MergeMapSubscriber(observer, this.project, this.concurrent));
            }, MergeMapOperator;
        }(), mergeMap_MergeMapSubscriber = function(_super) {
            function MergeMapSubscriber(destination, project, concurrent) {
                void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY);
                var _this = _super.call(this, destination) || this;
                return _this.project = project, _this.concurrent = concurrent, _this.hasCompleted = !1, 
                _this.buffer = [], _this.active = 0, _this.index = 0, _this;
            }
            return __extends(MergeMapSubscriber, _super), MergeMapSubscriber.prototype._next = function(value) {
                this.active < this.concurrent ? this._tryNext(value) : this.buffer.push(value);
            }, MergeMapSubscriber.prototype._tryNext = function(value) {
                var result, index = this.index++;
                try {
                    result = this.project(value, index);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.active++, this._innerSub(result, value, index);
            }, MergeMapSubscriber.prototype._innerSub = function(ish, value, index) {
                var innerSubscriber = new InnerSubscriber_InnerSubscriber(this, void 0, void 0);
                this.destination.add(innerSubscriber), subscribeToResult(this, ish, value, index, innerSubscriber);
            }, MergeMapSubscriber.prototype._complete = function() {
                this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), 
                this.unsubscribe();
            }, MergeMapSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            }, MergeMapSubscriber.prototype.notifyComplete = function(innerSub) {
                var buffer = this.buffer;
                this.remove(innerSub), this.active--, buffer.length > 0 ? this._next(buffer.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete();
            }, MergeMapSubscriber;
        }(OuterSubscriber_OuterSubscriber);
        function identity(x) {
            return x;
        }
        function mergeAll(concurrent) {
            return void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY), mergeMap(identity, concurrent);
        }
        function merge() {
            for (var observables = [], _i = 0; _i < arguments.length; _i++) observables[_i] = arguments[_i];
            var concurrent = Number.POSITIVE_INFINITY, scheduler = null, last = observables[observables.length - 1];
            return isScheduler(last) ? (scheduler = observables.pop(), observables.length > 1 && "number" == typeof observables[observables.length - 1] && (concurrent = observables.pop())) : "number" == typeof last && (concurrent = observables.pop()), 
            null === scheduler && 1 === observables.length && observables[0] instanceof Observable_Observable ? observables[0] : mergeAll(concurrent)(fromArray(observables, scheduler));
        }
        function refCount_refCount() {
            return function(source) {
                return source.lift(new RefCountOperator(source));
            };
        }
        var RefCountOperator = function() {
            function RefCountOperator(connectable) {
                this.connectable = connectable;
            }
            return RefCountOperator.prototype.call = function(subscriber, source) {
                var connectable = this.connectable;
                connectable._refCount++;
                var refCounter = new refCount_RefCountSubscriber(subscriber, connectable), subscription = source.subscribe(refCounter);
                return refCounter.closed || (refCounter.connection = connectable.connect()), subscription;
            }, RefCountOperator;
        }(), refCount_RefCountSubscriber = function(_super) {
            function RefCountSubscriber(destination, connectable) {
                var _this = _super.call(this, destination) || this;
                return _this.connectable = connectable, _this;
            }
            return __extends(RefCountSubscriber, _super), RefCountSubscriber.prototype._unsubscribe = function() {
                var connectable = this.connectable;
                if (connectable) {
                    this.connectable = null;
                    var refCount = connectable._refCount;
                    if (refCount <= 0) this.connection = null; else if (connectable._refCount = refCount - 1, 
                    refCount > 1) this.connection = null; else {
                        var connection = this.connection, sharedConnection = connectable._connection;
                        this.connection = null, !sharedConnection || connection && sharedConnection !== connection || sharedConnection.unsubscribe();
                    }
                } else this.connection = null;
            }, RefCountSubscriber;
        }(Subscriber_Subscriber), connectableProto = function(_super) {
            function ConnectableObservable(source, subjectFactory) {
                var _this = _super.call(this) || this;
                return _this.source = source, _this.subjectFactory = subjectFactory, _this._refCount = 0, 
                _this._isComplete = !1, _this;
            }
            return __extends(ConnectableObservable, _super), ConnectableObservable.prototype._subscribe = function(subscriber) {
                return this.getSubject().subscribe(subscriber);
            }, ConnectableObservable.prototype.getSubject = function() {
                var subject = this._subject;
                return subject && !subject.isStopped || (this._subject = this.subjectFactory()), 
                this._subject;
            }, ConnectableObservable.prototype.connect = function() {
                var connection = this._connection;
                return connection || (this._isComplete = !1, (connection = this._connection = new Subscription_Subscription()).add(this.source.subscribe(new ConnectableObservable_ConnectableSubscriber(this.getSubject(), this))), 
                connection.closed ? (this._connection = null, connection = Subscription_Subscription.EMPTY) : this._connection = connection), 
                connection;
            }, ConnectableObservable.prototype.refCount = function() {
                return refCount_refCount()(this);
            }, ConnectableObservable;
        }(Observable_Observable).prototype, connectableObservableDescriptor = {
            operator: {
                value: null
            },
            _refCount: {
                value: 0,
                writable: !0
            },
            _subject: {
                value: null,
                writable: !0
            },
            _connection: {
                value: null,
                writable: !0
            },
            _subscribe: {
                value: connectableProto._subscribe
            },
            _isComplete: {
                value: connectableProto._isComplete,
                writable: !0
            },
            getSubject: {
                value: connectableProto.getSubject
            },
            connect: {
                value: connectableProto.connect
            },
            refCount: {
                value: connectableProto.refCount
            }
        }, ConnectableObservable_ConnectableSubscriber = function(_super) {
            function ConnectableSubscriber(destination, connectable) {
                var _this = _super.call(this, destination) || this;
                return _this.connectable = connectable, _this;
            }
            return __extends(ConnectableSubscriber, _super), ConnectableSubscriber.prototype._error = function(err) {
                this._unsubscribe(), _super.prototype._error.call(this, err);
            }, ConnectableSubscriber.prototype._complete = function() {
                this.connectable._isComplete = !0, this._unsubscribe(), _super.prototype._complete.call(this);
            }, ConnectableSubscriber.prototype._unsubscribe = function() {
                var connectable = this.connectable;
                if (connectable) {
                    this.connectable = null;
                    var connection = connectable._connection;
                    connectable._refCount = 0, connectable._subject = null, connectable._connection = null, 
                    connection && connection.unsubscribe();
                }
            }, ConnectableSubscriber;
        }(Subject_SubjectSubscriber);
        function multicast(subjectOrSubjectFactory, selector) {
            return function(source) {
                var subjectFactory;
                if (subjectFactory = "function" == typeof subjectOrSubjectFactory ? subjectOrSubjectFactory : function() {
                    return subjectOrSubjectFactory;
                }, "function" == typeof selector) return source.lift(new MulticastOperator(subjectFactory, selector));
                var connectable = Object.create(source, connectableObservableDescriptor);
                return connectable.source = source, connectable.subjectFactory = subjectFactory, 
                connectable;
            };
        }
        var MulticastOperator = function() {
            function MulticastOperator(subjectFactory, selector) {
                this.subjectFactory = subjectFactory, this.selector = selector;
            }
            return MulticastOperator.prototype.call = function(subscriber, source) {
                var selector = this.selector, subject = this.subjectFactory(), subscription = selector(subject).subscribe(subscriber);
                return subscription.add(source.subscribe(subject)), subscription;
            }, MulticastOperator;
        }();
        function shareSubjectFactory() {
            return new Subject_Subject();
        }
        function share() {
            return function(source) {
                return refCount_refCount()(multicast(shareSubjectFactory)(source));
            };
        }
        var PARAMETERS = "__parameters__";
        function makeParamDecorator(name, props, parentClass) {
            var metaCtor = function(props) {
                return function() {
                    for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
                    if (props) {
                        var values = props.apply(void 0, __spread(args));
                        for (var propName in values) this[propName] = values[propName];
                    }
                };
            }(props);
            function ParamDecoratorFactory() {
                for (var _a, args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
                if (this instanceof ParamDecoratorFactory) return metaCtor.apply(this, args), this;
                var annotationInstance = new ((_a = ParamDecoratorFactory).bind.apply(_a, __spread([ void 0 ], args)))();
                return ParamDecorator.annotation = annotationInstance, ParamDecorator;
                function ParamDecorator(cls, unusedKey, index) {
                    for (var parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, {
                        value: []
                    })[PARAMETERS]; parameters.length <= index; ) parameters.push(null);
                    return (parameters[index] = parameters[index] || []).push(annotationInstance), cls;
                }
            }
            return parentClass && (ParamDecoratorFactory.prototype = Object.create(parentClass.prototype)), 
            ParamDecoratorFactory.prototype.ngMetadataName = name, ParamDecoratorFactory.annotationCls = ParamDecoratorFactory, 
            ParamDecoratorFactory;
        }
        var Inject = makeParamDecorator("Inject", function(token) {
            return {
                token: token
            };
        }), Optional = makeParamDecorator("Optional"), Self = makeParamDecorator("Self"), SkipSelf = makeParamDecorator("SkipSelf"), InjectFlags = function(InjectFlags) {
            return InjectFlags[InjectFlags.Default = 0] = "Default", InjectFlags[InjectFlags.Host = 1] = "Host", 
            InjectFlags[InjectFlags.Self = 2] = "Self", InjectFlags[InjectFlags.SkipSelf = 4] = "SkipSelf", 
            InjectFlags[InjectFlags.Optional = 8] = "Optional", InjectFlags;
        }({});
        function getClosureSafeProperty(objWithPropertyToExtract) {
            for (var key in objWithPropertyToExtract) if (objWithPropertyToExtract[key] === getClosureSafeProperty) return key;
            throw Error("Could not find renamed property on target object.");
        }
        function fillProperties(target, source) {
            for (var key in source) source.hasOwnProperty(key) && !target.hasOwnProperty(key) && (target[key] = source[key]);
        }
        function defineInjectable(opts) {
            return {
                providedIn: opts.providedIn || null,
                factory: opts.factory,
                value: void 0
            };
        }
        function defineInjector(options) {
            return {
                factory: options.factory,
                providers: options.providers || [],
                imports: options.imports || []
            };
        }
        function getInjectableDef(type) {
            return type && type.hasOwnProperty(NG_INJECTABLE_DEF) ? type[NG_INJECTABLE_DEF] : null;
        }
        function getInjectorDef(type) {
            return type && type.hasOwnProperty(NG_INJECTOR_DEF) ? type[NG_INJECTOR_DEF] : null;
        }
        var NG_INJECTABLE_DEF = getClosureSafeProperty({
            ngInjectableDef: getClosureSafeProperty
        }), NG_INJECTOR_DEF = getClosureSafeProperty({
            ngInjectorDef: getClosureSafeProperty
        });
        function stringify(token) {
            if ("string" == typeof token) return token;
            if (token instanceof Array) return "[" + token.map(stringify).join(", ") + "]";
            if (null == token) return "" + token;
            if (token.overriddenName) return "" + token.overriddenName;
            if (token.name) return "" + token.name;
            var res = token.toString();
            if (null == res) return "" + res;
            var newLineIndex = res.indexOf("\n");
            return -1 === newLineIndex ? res : res.substring(0, newLineIndex);
        }
        var __forward_ref__ = getClosureSafeProperty({
            __forward_ref__: getClosureSafeProperty
        });
        function forwardRef(forwardRefFn) {
            return forwardRefFn.__forward_ref__ = forwardRef, forwardRefFn.toString = function() {
                return stringify(this());
            }, forwardRefFn;
        }
        function resolveForwardRef(type) {
            var fn = type;
            return "function" == typeof fn && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef ? fn() : type;
        }
        function getGlobal() {
            var __globalThis = "undefined" != typeof globalThis && globalThis, __window = "undefined" != typeof window && window, __self = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, __global = "undefined" != typeof global && global;
            return __globalThis || __global || __window || __self;
        }
        var _injectImplementation, _global = getGlobal(), _currentInjector = void 0;
        function setCurrentInjector(injector) {
            var former = _currentInjector;
            return _currentInjector = injector, former;
        }
        function setInjectImplementation(impl) {
            var previous = _injectImplementation;
            return _injectImplementation = impl, previous;
        }
        function inject(token, flags) {
            return void 0 === flags && (flags = InjectFlags.Default), (_injectImplementation || function(token, flags) {
                if (void 0 === flags && (flags = InjectFlags.Default), void 0 === _currentInjector) throw new Error("inject() must be called from an injection context");
                return null === _currentInjector ? injectRootLimpMode(token, void 0, flags) : _currentInjector.get(token, flags & InjectFlags.Optional ? null : void 0, flags);
            })(token, flags);
        }
        function injectRootLimpMode(token, notFoundValue, flags) {
            var injectableDef = getInjectableDef(token);
            if (injectableDef && "root" == injectableDef.providedIn) return void 0 === injectableDef.value ? injectableDef.value = injectableDef.factory() : injectableDef.value;
            if (flags & InjectFlags.Optional) return null;
            if (void 0 !== notFoundValue) return notFoundValue;
            throw new Error("Injector: NOT_FOUND [" + stringify(token) + "]");
        }
        function injectArgs(types) {
            for (var args = [], i = 0; i < types.length; i++) {
                var arg = types[i];
                if (Array.isArray(arg)) {
                    if (0 === arg.length) throw new Error("Arguments array must have arguments.");
                    for (var type = void 0, flags = InjectFlags.Default, j = 0; j < arg.length; j++) {
                        var meta = arg[j];
                        meta instanceof Optional || "Optional" === meta.ngMetadataName ? flags |= InjectFlags.Optional : meta instanceof SkipSelf || "SkipSelf" === meta.ngMetadataName ? flags |= InjectFlags.SkipSelf : meta instanceof Self || "Self" === meta.ngMetadataName ? flags |= InjectFlags.Self : type = meta instanceof Inject ? meta.token : meta;
                    }
                    args.push(inject(type, flags));
                } else args.push(inject(arg));
            }
            return args;
        }
        var InjectionToken = function() {
            function InjectionToken(_desc, options) {
                this._desc = _desc, this.ngMetadataName = "InjectionToken", this.ngInjectableDef = void 0, 
                "number" == typeof options ? this.__NG_ELEMENT_ID__ = options : void 0 !== options && (this.ngInjectableDef = defineInjectable({
                    providedIn: options.providedIn || "root",
                    factory: options.factory
                }));
            }
            return InjectionToken.prototype.toString = function() {
                return "InjectionToken " + this._desc;
            }, InjectionToken;
        }(), SOURCE = "__source", _THROW_IF_NOT_FOUND = new Object(), INJECTOR = new InjectionToken("INJECTOR", -1), NullInjector = function() {
            function NullInjector() {}
            return NullInjector.prototype.get = function(token, notFoundValue) {
                if (void 0 === notFoundValue && (notFoundValue = _THROW_IF_NOT_FOUND), notFoundValue === _THROW_IF_NOT_FOUND) {
                    var error = new Error("NullInjectorError: No provider for " + stringify(token) + "!");
                    throw error.name = "NullInjectorError", error;
                }
                return notFoundValue;
            }, NullInjector;
        }(), Injector = function() {
            function Injector() {}
            return Injector.create = function(options, parent) {
                return Array.isArray(options) ? new StaticInjector(options, parent) : new StaticInjector(options.providers, options.parent, options.name || null);
            }, Injector.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND, Injector.NULL = new NullInjector(), 
            Injector.ngInjectableDef = defineInjectable({
                providedIn: "any",
                factory: function() {
                    return inject(INJECTOR);
                }
            }), Injector.__NG_ELEMENT_ID__ = -1, Injector;
        }(), IDENT = function(value) {
            return value;
        }, EMPTY = [], CIRCULAR = IDENT, MULTI_PROVIDER_FN = function() {
            return Array.prototype.slice.call(arguments);
        }, USE_VALUE$2 = getClosureSafeProperty({
            provide: String,
            useValue: getClosureSafeProperty
        }), NG_TOKEN_PATH = "ngTokenPath", NG_TEMP_TOKEN_PATH = "ngTempTokenPath", NULL_INJECTOR = Injector.NULL, NEW_LINE = /\n/gm, NO_NEW_LINE = "\u0275", StaticInjector = function() {
            function StaticInjector(providers, parent, source) {
                void 0 === parent && (parent = NULL_INJECTOR), void 0 === source && (source = null), 
                this.parent = parent, this.source = source;
                var records = this._records = new Map();
                records.set(Injector, {
                    token: Injector,
                    fn: IDENT,
                    deps: EMPTY,
                    value: this,
                    useNew: !1
                }), records.set(INJECTOR, {
                    token: INJECTOR,
                    fn: IDENT,
                    deps: EMPTY,
                    value: this,
                    useNew: !1
                }), function recursivelyProcessProviders(records, provider) {
                    if (provider) if ((provider = resolveForwardRef(provider)) instanceof Array) for (var i = 0; i < provider.length; i++) recursivelyProcessProviders(records, provider[i]); else {
                        if ("function" == typeof provider) throw staticError("Function/Class not supported", provider);
                        if (!provider || "object" != typeof provider || !provider.provide) throw staticError("Unexpected provider", provider);
                        var token = resolveForwardRef(provider.provide), resolvedProvider = function(provider) {
                            var deps = function(provider) {
                                var deps = EMPTY, providerDeps = provider.deps;
                                if (providerDeps && providerDeps.length) {
                                    deps = [];
                                    for (var i = 0; i < providerDeps.length; i++) {
                                        var options = 6;
                                        if ((token = resolveForwardRef(providerDeps[i])) instanceof Array) for (var j = 0, annotations = token; j < annotations.length; j++) {
                                            var annotation = annotations[j];
                                            annotation instanceof Optional || annotation == Optional ? options |= 1 : annotation instanceof SkipSelf || annotation == SkipSelf ? options &= -3 : annotation instanceof Self || annotation == Self ? options &= -5 : token = annotation instanceof Inject ? annotation.token : resolveForwardRef(annotation);
                                        }
                                        deps.push({
                                            token: token,
                                            options: options
                                        });
                                    }
                                } else if (provider.useExisting) {
                                    var token;
                                    deps = [ {
                                        token: token = resolveForwardRef(provider.useExisting),
                                        options: 6
                                    } ];
                                } else if (!(providerDeps || USE_VALUE$2 in provider)) throw staticError("'deps' required", provider);
                                return deps;
                            }(provider), fn = IDENT, value = EMPTY, useNew = !1, provide = resolveForwardRef(provider.provide);
                            if (USE_VALUE$2 in provider) value = provider.useValue; else if (provider.useFactory) fn = provider.useFactory; else if (provider.useExisting) ; else if (provider.useClass) useNew = !0, 
                            fn = resolveForwardRef(provider.useClass); else {
                                if ("function" != typeof provide) throw staticError("StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable", provider);
                                useNew = !0, fn = provide;
                            }
                            return {
                                deps: deps,
                                fn: fn,
                                useNew: useNew,
                                value: value
                            };
                        }(provider);
                        if (!0 === provider.multi) {
                            var multiProvider = records.get(token);
                            if (multiProvider) {
                                if (multiProvider.fn !== MULTI_PROVIDER_FN) throw multiProviderMixError(token);
                            } else records.set(token, multiProvider = {
                                token: provider.provide,
                                deps: [],
                                useNew: !1,
                                fn: MULTI_PROVIDER_FN,
                                value: EMPTY
                            });
                            multiProvider.deps.push({
                                token: token = provider,
                                options: 6
                            });
                        }
                        var record = records.get(token);
                        if (record && record.fn == MULTI_PROVIDER_FN) throw multiProviderMixError(token);
                        records.set(token, resolvedProvider);
                    }
                }(records, providers);
            }
            return StaticInjector.prototype.get = function(token, notFoundValue, flags) {
                void 0 === flags && (flags = InjectFlags.Default);
                var record = this._records.get(token);
                try {
                    return function tryResolveToken(token, record, records, parent, notFoundValue, flags) {
                        try {
                            return function(token, record, records, parent, notFoundValue, flags) {
                                var _a, value;
                                if (!record || flags & InjectFlags.SkipSelf) flags & InjectFlags.Self || (value = parent.get(token, notFoundValue, InjectFlags.Default)); else {
                                    if ((value = record.value) == CIRCULAR) throw Error(NO_NEW_LINE + "Circular dependency");
                                    if (value === EMPTY) {
                                        record.value = CIRCULAR;
                                        var useNew = record.useNew, fn = record.fn, depRecords = record.deps, deps = EMPTY;
                                        if (depRecords.length) {
                                            deps = [];
                                            for (var i = 0; i < depRecords.length; i++) {
                                                var depRecord = depRecords[i], options = depRecord.options, childRecord = 2 & options ? records.get(depRecord.token) : void 0;
                                                deps.push(tryResolveToken(depRecord.token, childRecord, records, childRecord || 4 & options ? parent : NULL_INJECTOR, 1 & options ? null : Injector.THROW_IF_NOT_FOUND, InjectFlags.Default));
                                            }
                                        }
                                        record.value = value = useNew ? new ((_a = fn).bind.apply(_a, __spread([ void 0 ], deps)))() : fn.apply(void 0, deps);
                                    }
                                }
                                return value;
                            }(token, record, records, parent, notFoundValue, flags);
                        } catch (e) {
                            throw e instanceof Error || (e = new Error(e)), (e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || []).unshift(token), 
                            record && record.value == CIRCULAR && (record.value = EMPTY), e;
                        }
                    }(token, record, this._records, this.parent, notFoundValue, flags);
                } catch (e) {
                    return catchInjectorError(e, token, "StaticInjectorError", this.source);
                }
            }, StaticInjector.prototype.toString = function() {
                var tokens = [];
                return this._records.forEach(function(v, token) {
                    return tokens.push(stringify(token));
                }), "StaticInjector[" + tokens.join(", ") + "]";
            }, StaticInjector;
        }();
        function multiProviderMixError(token) {
            return staticError("Cannot mix multi providers and regular providers", token);
        }
        function catchInjectorError(e, token, injectorErrorName, source) {
            var tokenPath = e[NG_TEMP_TOKEN_PATH];
            throw token[SOURCE] && tokenPath.unshift(token[SOURCE]), e.message = formatError("\n" + e.message, tokenPath, injectorErrorName, source), 
            e[NG_TOKEN_PATH] = tokenPath, e[NG_TEMP_TOKEN_PATH] = null, e;
        }
        function formatError(text, obj, injectorErrorName, source) {
            void 0 === source && (source = null), text = text && "\n" === text.charAt(0) && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;
            var context = stringify(obj);
            if (obj instanceof Array) context = obj.map(stringify).join(" -> "); else if ("object" == typeof obj) {
                var parts = [];
                for (var key in obj) if (obj.hasOwnProperty(key)) {
                    var value = obj[key];
                    parts.push(key + ":" + ("string" == typeof value ? JSON.stringify(value) : stringify(value)));
                }
                context = "{" + parts.join(", ") + "}";
            }
            return injectorErrorName + (source ? "(" + source + ")" : "") + "[" + context + "]: " + text.replace(NEW_LINE, "\n  ");
        }
        function staticError(text, obj) {
            return new Error(formatError(text, obj, "StaticInjectorError"));
        }
        var ERROR_DEBUG_CONTEXT = "ngDebugContext", ERROR_ORIGINAL_ERROR = "ngOriginalError", ChangeDetectionStrategy = function(ChangeDetectionStrategy) {
            return ChangeDetectionStrategy[ChangeDetectionStrategy.OnPush = 0] = "OnPush", ChangeDetectionStrategy[ChangeDetectionStrategy.Default = 1] = "Default", 
            ChangeDetectionStrategy;
        }({}), NG_COMPONENT_DEF = getClosureSafeProperty({
            ngComponentDef: getClosureSafeProperty
        }), NG_DIRECTIVE_DEF = getClosureSafeProperty({
            ngDirectiveDef: getClosureSafeProperty
        }), NG_PIPE_DEF = getClosureSafeProperty({
            ngPipeDef: getClosureSafeProperty
        }), NG_MODULE_DEF = getClosureSafeProperty({
            ngModuleDef: getClosureSafeProperty
        }), NG_ELEMENT_ID = getClosureSafeProperty({
            __NG_ELEMENT_ID__: getClosureSafeProperty
        }), componentResourceResolutionQueue = new Map(), componentDefPendingResolution = new Set();
        function unwrapResponse(response) {
            return "string" == typeof response ? response : response.text();
        }
        var ViewEncapsulation = function(ViewEncapsulation) {
            return ViewEncapsulation[ViewEncapsulation.Emulated = 0] = "Emulated", ViewEncapsulation[ViewEncapsulation.Native = 1] = "Native", 
            ViewEncapsulation[ViewEncapsulation.None = 2] = "None", ViewEncapsulation[ViewEncapsulation.ShadowDom = 3] = "ShadowDom", 
            ViewEncapsulation;
        }({}), EMPTY_OBJ = {}, EMPTY_ARRAY$1 = [];
        function renderStringify(value) {
            return "function" == typeof value ? value.name || value : "string" == typeof value ? value : null == value ? "" : "object" == typeof value && "function" == typeof value.type ? value.type.name || value.type : "" + value;
        }
        var defaultScheduler = ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(_global);
        function resolveWindow(element) {
            return {
                name: "window",
                target: element.ownerDocument.defaultView
            };
        }
        function resolveDocument(element) {
            return {
                name: "document",
                target: element.ownerDocument
            };
        }
        var INTERPOLATION_DELIMITER = "\ufffd";
        function isPropMetadataString(str) {
            return str.indexOf(INTERPOLATION_DELIMITER) >= 0;
        }
        function maybeUnwrapFn(value) {
            return value instanceof Function ? value() : value;
        }
        var _renderCompCount = 0;
        function defineComponent(componentDefinition) {
            var type = componentDefinition.type, typePrototype = type.prototype, declaredInputs = {}, def = {
                type: type,
                providersResolver: null,
                consts: componentDefinition.consts,
                vars: componentDefinition.vars,
                factory: componentDefinition.factory,
                template: componentDefinition.template || null,
                ngContentSelectors: componentDefinition.ngContentSelectors,
                hostBindings: componentDefinition.hostBindings || null,
                contentQueries: componentDefinition.contentQueries || null,
                declaredInputs: declaredInputs,
                inputs: null,
                outputs: null,
                exportAs: componentDefinition.exportAs || null,
                onChanges: null,
                onInit: typePrototype.ngOnInit || null,
                doCheck: typePrototype.ngDoCheck || null,
                afterContentInit: typePrototype.ngAfterContentInit || null,
                afterContentChecked: typePrototype.ngAfterContentChecked || null,
                afterViewInit: typePrototype.ngAfterViewInit || null,
                afterViewChecked: typePrototype.ngAfterViewChecked || null,
                onDestroy: typePrototype.ngOnDestroy || null,
                onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,
                directiveDefs: null,
                pipeDefs: null,
                selectors: componentDefinition.selectors,
                viewQuery: componentDefinition.viewQuery || null,
                features: componentDefinition.features || null,
                data: componentDefinition.data || {},
                encapsulation: componentDefinition.encapsulation || ViewEncapsulation.Emulated,
                id: "c",
                styles: componentDefinition.styles || EMPTY_ARRAY$1,
                _: null,
                setInput: null,
                schemas: componentDefinition.schemas || null
            };
            return def._ = "" + {
                toString: function() {
                    var directiveTypes = componentDefinition.directives, feature = componentDefinition.features, pipeTypes = componentDefinition.pipes;
                    def.id += _renderCompCount++, def.inputs = invertObject(componentDefinition.inputs, declaredInputs), 
                    def.outputs = invertObject(componentDefinition.outputs), feature && feature.forEach(function(fn) {
                        return fn(def);
                    }), def.directiveDefs = directiveTypes ? function() {
                        return ("function" == typeof directiveTypes ? directiveTypes() : directiveTypes).map(extractDirectiveDef);
                    } : null, def.pipeDefs = pipeTypes ? function() {
                        return ("function" == typeof pipeTypes ? pipeTypes() : pipeTypes).map(extractPipeDef);
                    } : null;
                }
            }, def;
        }
        function extractDirectiveDef(type) {
            return getComponentDef(type) || getDirectiveDef(type);
        }
        function extractPipeDef(type) {
            return getPipeDef(type);
        }
        function defineNgModule(def) {
            return {
                type: def.type,
                bootstrap: def.bootstrap || EMPTY_ARRAY$1,
                declarations: def.declarations || EMPTY_ARRAY$1,
                imports: def.imports || EMPTY_ARRAY$1,
                exports: def.exports || EMPTY_ARRAY$1,
                transitiveCompileScopes: null,
                schemas: def.schemas || null
            };
        }
        function invertObject(obj, secondary) {
            if (null == obj) return EMPTY_OBJ;
            var newLookup = {};
            for (var minifiedKey in obj) if (obj.hasOwnProperty(minifiedKey)) {
                var publicName = obj[minifiedKey], declaredName = publicName;
                Array.isArray(publicName) && (declaredName = publicName[1], publicName = publicName[0]), 
                newLookup[publicName] = minifiedKey, secondary && (secondary[publicName] = declaredName);
            }
            return newLookup;
        }
        var defineDirective = defineComponent;
        function getComponentDef(type) {
            return type[NG_COMPONENT_DEF] || null;
        }
        function getDirectiveDef(type) {
            return type[NG_DIRECTIVE_DEF] || null;
        }
        function getPipeDef(type) {
            return type[NG_PIPE_DEF] || null;
        }
        function getNgModuleDef(type, throwNotFound) {
            var ngModuleDef = type[NG_MODULE_DEF] || null;
            if (!ngModuleDef && !0 === throwNotFound) throw new Error("Type " + stringify(type) + " does not have 'ngModuleDef' property.");
            return ngModuleDef;
        }
        var HOST = 0, TVIEW = 1, FLAGS = 2, PARENT = 3, NEXT = 4, QUERIES = 5, T_HOST = 6, BINDING_INDEX = 7, CLEANUP = 8, CONTEXT = 9, INJECTOR$1 = 10, RENDERER_FACTORY = 11, RENDERER = 12, SANITIZER = 13, CHILD_HEAD = 14, CHILD_TAIL = 15, CONTENT_QUERIES = 16, DECLARATION_VIEW = 17, PREORDER_HOOK_FLAGS = 18, HEADER_OFFSET = 20, TYPE = 1, ACTIVE_INDEX = 2, NATIVE = 7, VIEWS = 8, MONKEY_PATCH_KEY_NAME = "__ngContext__";
        function unwrapRNode(value) {
            for (;Array.isArray(value); ) value = value[HOST];
            return value;
        }
        function isLView(value) {
            return Array.isArray(value) && "object" == typeof value[TYPE];
        }
        function isLContainer(value) {
            return Array.isArray(value) && !0 === value[TYPE];
        }
        function getNativeByIndex(index, lView) {
            return unwrapRNode(lView[index + HEADER_OFFSET]);
        }
        function getNativeByTNode(tNode, hostView) {
            return unwrapRNode(hostView[tNode.index]);
        }
        function getTNode(index, view) {
            return view[TVIEW].data[index + HEADER_OFFSET];
        }
        function loadInternal(view, index) {
            return view[index + HEADER_OFFSET];
        }
        function getComponentViewByIndex(nodeIndex, hostView) {
            var slotValue = hostView[nodeIndex];
            return isLView(slotValue) ? slotValue : slotValue[HOST];
        }
        function isComponent(tNode) {
            return 1 == (1 & tNode.flags);
        }
        function isComponentDef(def) {
            return null !== def.template;
        }
        function isRootView(target) {
            return 0 != (512 & target[FLAGS]);
        }
        function readPatchedData(target) {
            return target[MONKEY_PATCH_KEY_NAME];
        }
        function readPatchedLView(target) {
            var value = readPatchedData(target);
            return value ? Array.isArray(value) ? value : value.lView : null;
        }
        function viewAttachedToContainer(view) {
            return isLContainer(view[PARENT]);
        }
        function resetPreOrderHookFlags(lView) {
            lView[PREORDER_HOOK_FLAGS] = 0;
        }
        var elementDepthCount, TNODE = 8, PARENT_INJECTOR = 8, INJECTOR_BLOOM_PARENT_SIZE = 9, NO_PARENT_INJECTOR = -1, NodeInjectorFactory = function() {
            return function(factory, isViewProvider, injectImplementation) {
                this.factory = factory, this.resolving = !1, this.canSeeViewProviders = isViewProvider, 
                this.injectImpl = injectImplementation;
            };
        }(), FactoryPrototype = NodeInjectorFactory.prototype;
        function registerPreOrderHooks(directiveIndex, directiveDef, tView, nodeIndex, initialPreOrderHooksLength, initialPreOrderCheckHooksLength) {
            var onChanges = directiveDef.onChanges, onInit = directiveDef.onInit, doCheck = directiveDef.doCheck;
            initialPreOrderHooksLength >= 0 && (!tView.preOrderHooks || initialPreOrderHooksLength === tView.preOrderHooks.length) && (onChanges || onInit || doCheck) && (tView.preOrderHooks || (tView.preOrderHooks = [])).push(nodeIndex), 
            initialPreOrderCheckHooksLength >= 0 && (!tView.preOrderCheckHooks || initialPreOrderCheckHooksLength === tView.preOrderCheckHooks.length) && (onChanges || doCheck) && (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(nodeIndex), 
            onChanges && ((tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, onChanges), 
            (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, onChanges)), 
            onInit && (tView.preOrderHooks || (tView.preOrderHooks = [])).push(-directiveIndex, onInit), 
            doCheck && ((tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, doCheck), 
            (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, doCheck));
        }
        function registerPostOrderHooks(tView, tNode) {
            if (tView.firstTemplatePass) for (var i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {
                var directiveDef = tView.data[i];
                directiveDef.afterContentInit && (tView.contentHooks || (tView.contentHooks = [])).push(-i, directiveDef.afterContentInit), 
                directiveDef.afterContentChecked && ((tView.contentHooks || (tView.contentHooks = [])).push(i, directiveDef.afterContentChecked), 
                (tView.contentCheckHooks || (tView.contentCheckHooks = [])).push(i, directiveDef.afterContentChecked)), 
                directiveDef.afterViewInit && (tView.viewHooks || (tView.viewHooks = [])).push(-i, directiveDef.afterViewInit), 
                directiveDef.afterViewChecked && ((tView.viewHooks || (tView.viewHooks = [])).push(i, directiveDef.afterViewChecked), 
                (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(i, directiveDef.afterViewChecked)), 
                null != directiveDef.onDestroy && (tView.destroyHooks || (tView.destroyHooks = [])).push(i, directiveDef.onDestroy);
            }
        }
        function executePreOrderHooks(currentView, tView, checkNoChangesMode, currentNodeIndex) {
            checkNoChangesMode || executeHooks(currentView, tView.preOrderHooks, tView.preOrderCheckHooks, checkNoChangesMode, 0, void 0 !== currentNodeIndex ? currentNodeIndex : null);
        }
        function executeHooks(currentView, firstPassHooks, checkHooks, checkNoChangesMode, initPhaseState, currentNodeIndex) {
            if (!checkNoChangesMode) {
                var hooksToCall = (3 & currentView[FLAGS]) === initPhaseState ? firstPassHooks : checkHooks;
                hooksToCall && function(currentView, arr, initPhase, currentNodeIndex) {
                    for (var nodeIndexLimit = null != currentNodeIndex ? currentNodeIndex : -1, lastNodeIndexFound = 0, i = void 0 !== currentNodeIndex ? 65535 & currentView[PREORDER_HOOK_FLAGS] : 0; i < arr.length; i++) if ("number" == typeof arr[i + 1]) {
                        if (lastNodeIndexFound = arr[i], null != currentNodeIndex && lastNodeIndexFound >= currentNodeIndex) break;
                    } else arr[i] < 0 && (currentView[PREORDER_HOOK_FLAGS] += 65536), (lastNodeIndexFound < nodeIndexLimit || -1 == nodeIndexLimit) && (callHook(currentView, initPhase, arr, i), 
                    currentView[PREORDER_HOOK_FLAGS] = (4294901760 & currentView[PREORDER_HOOK_FLAGS]) + i + 2), 
                    i++;
                }(currentView, hooksToCall, initPhaseState, currentNodeIndex), null == currentNodeIndex && (3 & currentView[FLAGS]) === initPhaseState && 3 !== initPhaseState && (currentView[FLAGS] &= 1023, 
                currentView[FLAGS] += 1);
            }
        }
        function callHook(currentView, initPhase, arr, i) {
            var isInitHook = arr[i] < 0, hook = arr[i + 1], directive = currentView[isInitHook ? -arr[i] : arr[i]];
            isInitHook ? currentView[FLAGS] >> 10 < currentView[PREORDER_HOOK_FLAGS] >> 16 && (3 & currentView[FLAGS]) === initPhase && (currentView[FLAGS] += 1024, 
            hook.call(directive)) : hook.call(directive);
        }
        var bindingsEnabled, currentDirectiveDef = null;
        function setCurrentDirectiveDef(def) {
            currentDirectiveDef = def;
        }
        function getLView() {
            return core_lView;
        }
        var previousOrParentTNode, isParent, core_lView, activeHostContext = null, activeHostElementIndex = null;
        function setActiveHost(host, index) {
            void 0 === index && (index = null), activeHostContext = host, activeHostElementIndex = index;
        }
        function getActiveHostContext() {
            return activeHostContext;
        }
        function getActiveHostElementIndex() {
            return activeHostElementIndex;
        }
        function restoreView(viewToRestore) {
            contextLView = viewToRestore;
        }
        function getPreviousOrParentTNode() {
            return previousOrParentTNode;
        }
        function setPreviousOrParentTNode(tNode) {
            previousOrParentTNode = tNode;
        }
        function setTNodeAndViewData(tNode, view) {
            previousOrParentTNode = tNode, core_lView = view;
        }
        function getIsParent() {
            return isParent;
        }
        function setIsParent(value) {
            isParent = value;
        }
        function isCreationMode(view) {
            return void 0 === view && (view = core_lView), 4 == (4 & view[FLAGS]);
        }
        var contextLView = null, checkNoChangesMode = !1;
        function getCheckNoChangesMode() {
            return checkNoChangesMode;
        }
        function setCheckNoChangesMode(mode) {
            checkNoChangesMode = mode;
        }
        var bindingRootIndex = -1;
        function setBindingRoot(value) {
            bindingRootIndex = value;
        }
        var currentQueryIndex = 0;
        function getCurrentQueryIndex() {
            return currentQueryIndex;
        }
        function setCurrentQueryIndex(value) {
            currentQueryIndex = value;
        }
        function enterView(newView, hostTNode) {
            var oldView = core_lView;
            return newView && (bindingRootIndex = newView[TVIEW].bindingStartIndex), previousOrParentTNode = hostTNode, 
            isParent = !0, core_lView = contextLView = newView, oldView;
        }
        function leaveView(newView) {
            var tView = core_lView[TVIEW];
            if (isCreationMode(core_lView)) core_lView[FLAGS] &= -5; else try {
                resetPreOrderHookFlags(core_lView), executeHooks(core_lView, tView.viewHooks, tView.viewCheckHooks, checkNoChangesMode, 2, void 0);
            } finally {
                core_lView[FLAGS] &= -73, core_lView[BINDING_INDEX] = tView.bindingStartIndex;
            }
            enterView(newView, null);
        }
        var _currentNamespace = null;
        function namespaceHTML() {
            _currentNamespace = null;
        }
        var NG_PROJECT_AS_ATTR_NAME = "ngProjectAs", RendererStyleFlags3 = function(RendererStyleFlags3) {
            return RendererStyleFlags3[RendererStyleFlags3.Important = 1] = "Important", RendererStyleFlags3[RendererStyleFlags3.DashCase = 2] = "DashCase", 
            RendererStyleFlags3;
        }({});
        function isProceduralRenderer(renderer) {
            return !!renderer.listen;
        }
        var domRendererFactory3 = {
            createRenderer: function(hostElement, rendererType) {
                return document;
            }
        };
        function createLContext(lView, nodeIndex, native) {
            return {
                lView: lView,
                nodeIndex: nodeIndex,
                native: native,
                component: void 0,
                directives: void 0,
                localRefs: void 0
            };
        }
        function attachPatchData(target, data) {
            target[MONKEY_PATCH_KEY_NAME] = data;
        }
        function findViaNativeElement(lView, target) {
            for (var tNode = lView[TVIEW].firstChild; tNode; ) {
                if (getNativeByTNode(tNode, lView) === target) return tNode.index;
                tNode = traverseNextElement(tNode);
            }
            return -1;
        }
        function traverseNextElement(tNode) {
            if (tNode.child) return tNode.child;
            if (tNode.next) return tNode.next;
            for (;tNode.parent && !tNode.parent.next; ) tNode = tNode.parent;
            return tNode.parent && tNode.parent.next;
        }
        var CorePlayerHandler = function() {
            function CorePlayerHandler() {
                this._players = [];
            }
            return CorePlayerHandler.prototype.flushPlayers = function() {
                for (var i = 0; i < this._players.length; i++) {
                    var player = this._players[i];
                    player.parent || 0 !== player.state || player.play();
                }
                this._players.length = 0;
            }, CorePlayerHandler.prototype.queuePlayer = function(player) {
                this._players.push(player);
            }, CorePlayerHandler;
        }(), ANIMATION_PROP_PREFIX = "@";
        function createEmptyStylingContext(wrappedElement, sanitizer, initialStyles, initialClasses) {
            var context = [ wrappedElement || null, 0, [], initialStyles || [ null, null ], initialClasses || [ null, null ], [ 0, 0 ], [ 0 ], [ 0 ], null ];
            return allocateDirectiveIntoContext(context, null), context;
        }
        function allocateDirectiveIntoContext(context, directiveRef) {
            var dirs = context[2], i = dirs.length;
            return dirs.push(null, null, null, null), dirs[i + 0] = directiveRef, dirs[i + 2] = !1, 
            dirs[i + 3] = null, dirs[i + 1] = -1, i;
        }
        function getStylingContext(index, viewData) {
            for (var storageIndex = index, slotValue = viewData[storageIndex], wrapper = viewData; Array.isArray(slotValue); ) wrapper = slotValue, 
            slotValue = slotValue[HOST];
            if (value = wrapper, Array.isArray(value) && "number" == typeof value[TYPE]) return wrapper;
            var value, stylingTemplate = getTNode(index - HEADER_OFFSET, viewData).stylingTemplate;
            return wrapper !== viewData && (storageIndex = HOST), wrapper[storageIndex] = stylingTemplate ? function(element, templateStyleContext) {
                for (var context = templateStyleContext.slice(), i = 0; i < 9; i++) {
                    var value = templateStyleContext[i];
                    Array.isArray(value) && (context[i] = value.slice());
                }
                return context[0] = element, context[1] |= 16, context;
            }(slotValue, stylingTemplate) : createEmptyStylingContext(slotValue);
        }
        function isAnimationProp(name) {
            return name[0] === ANIMATION_PROP_PREFIX;
        }
        function hasClassInput(tNode) {
            return 0 != (8 & tNode.flags);
        }
        function hasStyleInput(tNode) {
            return 0 != (16 & tNode.flags);
        }
        function addPlayerInternal(playerContext, rootContext, element, player, playerContextIndex, ref) {
            return ref = ref || element, playerContextIndex ? playerContext[playerContextIndex] = player : playerContext.push(player), 
            !!player && (player.addEventListener(200, function() {
                var index = playerContext.indexOf(player);
                index && (index < playerContext[0] ? playerContext[index] = null : playerContext.splice(index, 1)), 
                player.destroy();
            }), (rootContext.playerHandler || (rootContext.playerHandler = new CorePlayerHandler())).queuePlayer(player, ref), 
            !0);
        }
        function setUpAttributes(native, attrs) {
            for (var renderer = getLView()[RENDERER], isProc = isProceduralRenderer(renderer), i = 0; i < attrs.length; ) {
                var value = attrs[i];
                if ("number" == typeof value) {
                    if (0 !== value) break;
                    i++;
                    var namespaceURI = attrs[i++], attrName = attrs[i++], attrVal = attrs[i++];
                    isProc ? renderer.setAttribute(native, attrName, attrVal, namespaceURI) : native.setAttributeNS(namespaceURI, attrName, attrVal);
                } else attrVal = attrs[++i], (attrName = value) !== NG_PROJECT_AS_ATTR_NAME && (isAnimationProp(attrName) ? isProc && renderer.setProperty(native, attrName, attrVal) : isProc ? renderer.setAttribute(native, attrName, attrVal) : native.setAttribute(attrName, attrVal)), 
                i++;
            }
            return i;
        }
        function attrsStylingIndexOf(attrs, startIndex) {
            for (var i = startIndex; i < attrs.length; i++) {
                var val = attrs[i];
                if (1 === val || 2 === val) return i;
            }
            return -1;
        }
        function isNameOnlyAttributeMarker(marker) {
            return 3 === marker || 4 === marker;
        }
        function hasParentInjector(parentLocation) {
            return parentLocation !== NO_PARENT_INJECTOR;
        }
        function getParentInjectorIndex(parentLocation) {
            return 32767 & parentLocation;
        }
        function getParentInjectorViewOffset(parentLocation) {
            return parentLocation >> 16;
        }
        function getParentInjectorView(location, startView) {
            for (var viewOffset = getParentInjectorViewOffset(location), parentView = startView; viewOffset > 0; ) parentView = parentView[DECLARATION_VIEW], 
            viewOffset--;
            return parentView;
        }
        function getLViewParent(lView) {
            var parent = lView[PARENT];
            return isLContainer(parent) ? parent[PARENT] : parent;
        }
        function findComponentView(lView) {
            for (var rootTNode = lView[T_HOST]; rootTNode && 2 === rootTNode.type; ) rootTNode = (lView = lView[DECLARATION_VIEW])[T_HOST];
            return lView;
        }
        function getRootContext(viewOrComponent) {
            return function(componentOrLView) {
                for (var lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView); lView && !(512 & lView[FLAGS]); ) lView = getLViewParent(lView);
                return lView;
            }(viewOrComponent)[CONTEXT];
        }
        var includeViewProviders = !0;
        function setIncludeViewProviders(v) {
            var oldValue = includeViewProviders;
            return includeViewProviders = v, oldValue;
        }
        var BLOOM_MASK = 255, nextNgElementId = 0;
        function getOrCreateNodeInjectorForNode(tNode, hostView) {
            var existingInjectorIndex = getInjectorIndex(tNode, hostView);
            if (-1 !== existingInjectorIndex) return existingInjectorIndex;
            var tView = hostView[TVIEW];
            tView.firstTemplatePass && (tNode.injectorIndex = hostView.length, insertBloom(tView.data, tNode), 
            insertBloom(hostView, null), insertBloom(tView.blueprint, null));
            var parentLoc = getParentInjectorLocation(tNode, hostView), parentIndex = getParentInjectorIndex(parentLoc), parentLView = getParentInjectorView(parentLoc, hostView), injectorIndex = tNode.injectorIndex;
            if (hasParentInjector(parentLoc)) for (var parentData = parentLView[TVIEW].data, i = 0; i < 8; i++) hostView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];
            return hostView[injectorIndex + PARENT_INJECTOR] = parentLoc, injectorIndex;
        }
        function insertBloom(arr, footer) {
            arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);
        }
        function getInjectorIndex(tNode, hostView) {
            return -1 === tNode.injectorIndex || tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex || null == hostView[tNode.injectorIndex + PARENT_INJECTOR] ? -1 : tNode.injectorIndex;
        }
        function getParentInjectorLocation(tNode, view) {
            if (tNode.parent && -1 !== tNode.parent.injectorIndex) return tNode.parent.injectorIndex;
            for (var hostTNode = view[T_HOST], viewOffset = 1; hostTNode && -1 === hostTNode.injectorIndex; ) hostTNode = (view = view[DECLARATION_VIEW]) ? view[T_HOST] : null, 
            viewOffset++;
            return hostTNode ? hostTNode.injectorIndex | viewOffset << 16 : -1;
        }
        function diPublicInInjector(injectorIndex, view, token) {
            !function(injectorIndex, tView, type) {
                var id = "string" != typeof type ? type[NG_ELEMENT_ID] : type.charCodeAt(0) || 0;
                null == id && (id = type[NG_ELEMENT_ID] = nextNgElementId++);
                var bloomBit = id & BLOOM_MASK, mask = 1 << bloomBit, b6 = 64 & bloomBit, b5 = 32 & bloomBit, tData = tView.data;
                128 & bloomBit ? b6 ? b5 ? tData[injectorIndex + 7] |= mask : tData[injectorIndex + 6] |= mask : b5 ? tData[injectorIndex + 5] |= mask : tData[injectorIndex + 4] |= mask : b6 ? b5 ? tData[injectorIndex + 3] |= mask : tData[injectorIndex + 2] |= mask : b5 ? tData[injectorIndex + 1] |= mask : tData[injectorIndex] |= mask;
            }(injectorIndex, view[TVIEW], token);
        }
        function getOrCreateInjectable(tNode, lView, token, flags, notFoundValue) {
            if (void 0 === flags && (flags = InjectFlags.Default), tNode) {
                var bloomHash = function(token) {
                    if ("string" == typeof token) return token.charCodeAt(0) || 0;
                    var tokenId = token[NG_ELEMENT_ID];
                    return "number" == typeof tokenId && tokenId > 0 ? tokenId & BLOOM_MASK : tokenId;
                }(token);
                if ("function" == typeof bloomHash) {
                    var savePreviousOrParentTNode = getPreviousOrParentTNode(), saveLView = getLView();
                    setTNodeAndViewData(tNode, lView);
                    try {
                        var value = bloomHash();
                        if (null != value || flags & InjectFlags.Optional) return value;
                        throw new Error("No provider for " + renderStringify(token) + "!");
                    } finally {
                        setTNodeAndViewData(savePreviousOrParentTNode, saveLView);
                    }
                } else if ("number" == typeof bloomHash) {
                    if (-1 === bloomHash) return new NodeInjector(tNode, lView);
                    var previousTView = null, injectorIndex = getInjectorIndex(tNode, lView), parentLocation = NO_PARENT_INJECTOR, hostTElementNode = flags & InjectFlags.Host ? findComponentView(lView)[T_HOST] : null;
                    for ((-1 === injectorIndex || flags & InjectFlags.SkipSelf) && (parentLocation = -1 === injectorIndex ? getParentInjectorLocation(tNode, lView) : lView[injectorIndex + PARENT_INJECTOR], 
                    shouldSearchParent(flags, !1) ? (previousTView = lView[TVIEW], injectorIndex = getParentInjectorIndex(parentLocation), 
                    lView = getParentInjectorView(parentLocation, lView)) : injectorIndex = -1); -1 !== injectorIndex; ) {
                        parentLocation = lView[injectorIndex + PARENT_INJECTOR];
                        var tView = lView[TVIEW];
                        if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {
                            var instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);
                            if (instance !== NOT_FOUND) return instance;
                        }
                        shouldSearchParent(flags, lView[TVIEW].data[injectorIndex + TNODE] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView) ? (previousTView = tView, 
                        injectorIndex = getParentInjectorIndex(parentLocation), lView = getParentInjectorView(parentLocation, lView)) : injectorIndex = -1;
                    }
                }
            }
            if (flags & InjectFlags.Optional && void 0 === notFoundValue && (notFoundValue = null), 
            0 == (flags & (InjectFlags.Self | InjectFlags.Host))) {
                var moduleInjector = lView[INJECTOR$1], previousInjectImplementation = setInjectImplementation(void 0);
                try {
                    return moduleInjector ? moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional) : injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);
                } finally {
                    setInjectImplementation(previousInjectImplementation);
                }
            }
            if (flags & InjectFlags.Optional) return notFoundValue;
            throw new Error("NodeInjector: NOT_FOUND [" + renderStringify(token) + "]");
        }
        var NOT_FOUND = {};
        function searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {
            var currentTView = lView[TVIEW], tNode = currentTView.data[injectorIndex + TNODE], injectableIdx = locateDirectiveOrProvider(tNode, lView, token, null == previousTView ? isComponent(tNode) && includeViewProviders : previousTView != currentTView && 3 === tNode.type, flags & InjectFlags.Host && hostTElementNode === tNode);
            return null !== injectableIdx ? getNodeInjectable(currentTView.data, lView, injectableIdx, tNode) : NOT_FOUND;
        }
        function locateDirectiveOrProvider(tNode, lView, token, canAccessViewProviders, isHostSpecialCase) {
            for (var nodeProviderIndexes = tNode.providerIndexes, tInjectables = lView[TVIEW].data, injectablesStart = 65535 & nodeProviderIndexes, directivesStart = tNode.directiveStart, cptViewProvidersCount = nodeProviderIndexes >> 16, endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : tNode.directiveEnd, i = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount; i < endIndex; i++) {
                var providerTokenOrDef = tInjectables[i];
                if (i < directivesStart && token === providerTokenOrDef || i >= directivesStart && providerTokenOrDef.type === token) return i;
            }
            if (isHostSpecialCase) {
                var dirDef = tInjectables[directivesStart];
                if (dirDef && isComponentDef(dirDef) && dirDef.type === token) return directivesStart;
            }
            return null;
        }
        function getNodeInjectable(tData, lData, index, tNode) {
            var obj, value = lData[index];
            if (null !== (obj = value) && "object" == typeof obj && Object.getPrototypeOf(obj) == FactoryPrototype) {
                var factory = value;
                if (factory.resolving) throw new Error("Circular dep for " + renderStringify(tData[index]));
                var previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);
                factory.resolving = !0;
                var previousInjectImplementation = void 0;
                factory.injectImpl && (previousInjectImplementation = setInjectImplementation(factory.injectImpl));
                var savePreviousOrParentTNode = getPreviousOrParentTNode(), saveLView = getLView();
                setTNodeAndViewData(tNode, lData);
                try {
                    value = lData[index] = factory.factory(null, tData, lData, tNode);
                } finally {
                    factory.injectImpl && setInjectImplementation(previousInjectImplementation), setIncludeViewProviders(previousIncludeViewProviders), 
                    factory.resolving = !1, setTNodeAndViewData(savePreviousOrParentTNode, saveLView);
                }
            }
            return value;
        }
        function bloomHasToken(bloomHash, injectorIndex, injectorView) {
            var b6 = 64 & bloomHash, b5 = 32 & bloomHash;
            return !!((128 & bloomHash ? b6 ? b5 ? injectorView[injectorIndex + 7] : injectorView[injectorIndex + 6] : b5 ? injectorView[injectorIndex + 5] : injectorView[injectorIndex + 4] : b6 ? b5 ? injectorView[injectorIndex + 3] : injectorView[injectorIndex + 2] : b5 ? injectorView[injectorIndex + 1] : injectorView[injectorIndex]) & 1 << bloomHash);
        }
        function shouldSearchParent(flags, isFirstHostTNode) {
            return !(flags & InjectFlags.Self || flags & InjectFlags.Host && isFirstHostTNode);
        }
        var NodeInjector = function() {
            function NodeInjector(_tNode, _lView) {
                this._tNode = _tNode, this._lView = _lView;
            }
            return NodeInjector.prototype.get = function(token, notFoundValue) {
                return getOrCreateInjectable(this._tNode, this._lView, token, void 0, notFoundValue);
            }, NodeInjector;
        }();
        function getInheritedFactory(type) {
            var factory = function(type) {
                var typeAny = type, def = getComponentDef(typeAny) || getDirectiveDef(typeAny) || getPipeDef(typeAny) || getInjectableDef(typeAny) || getInjectorDef(typeAny);
                return def && void 0 !== def.factory ? def.factory : null;
            }(Object.getPrototypeOf(type.prototype).constructor);
            return null !== factory ? factory : function(t) {
                return new t();
            };
        }
        function getDebugContext(error) {
            return error[ERROR_DEBUG_CONTEXT];
        }
        function getOriginalError(error) {
            return error[ERROR_ORIGINAL_ERROR];
        }
        function defaultErrorLogger(console) {
            for (var values = [], _i = 1; _i < arguments.length; _i++) values[_i - 1] = arguments[_i];
            console.error.apply(console, __spread(values));
        }
        var ErrorHandler = function() {
            function ErrorHandler() {
                this._console = console;
            }
            return ErrorHandler.prototype.handleError = function(error) {
                var originalError = this._findOriginalError(error), context = this._findContext(error), errorLogger = function(error) {
                    return error.ngErrorLogger || defaultErrorLogger;
                }(error);
                errorLogger(this._console, "ERROR", error), originalError && errorLogger(this._console, "ORIGINAL ERROR", originalError), 
                context && errorLogger(this._console, "ERROR CONTEXT", context);
            }, ErrorHandler.prototype._findContext = function(error) {
                return error ? getDebugContext(error) ? getDebugContext(error) : this._findContext(getOriginalError(error)) : null;
            }, ErrorHandler.prototype._findOriginalError = function(error) {
                for (var e = getOriginalError(error); e && getOriginalError(e); ) e = getOriginalError(e);
                return e;
            }, ErrorHandler;
        }();
        function throwMultipleComponentError(tNode) {
            throw new Error("Multiple components match node with tagname " + tNode.tagName);
        }
        var NO_CHANGE = {}, BoundPlayerFactory = function() {
            return function(fn, value) {
                this.fn = fn, this.value = value;
            };
        }();
        function initializeStaticContext(attrs, stylingStartIndex, directiveRef) {
            var context = createEmptyStylingContext();
            return patchContextWithStaticAttrs(context, attrs, stylingStartIndex, directiveRef), 
            context;
        }
        function patchContextWithStaticAttrs(context, attrs, attrsStylingStartIndex, directiveRef) {
            if (!(16 & context[1])) {
                var detectedIndex = getDirectiveRegistryValuesIndexOf(context[2], directiveRef || null);
                -1 === detectedIndex && (detectedIndex = allocateDirectiveIntoContext(context, directiveRef));
                for (var directiveIndex = detectedIndex / 4, initialClasses = null, initialStyles = null, mode = -1, i = attrsStylingStartIndex; i < attrs.length; i++) {
                    var attr = attrs[i];
                    "number" == typeof attr ? mode = attr : 1 == mode ? patchInitialStylingValue(initialClasses = initialClasses || context[4], attr, !0, directiveIndex) : 2 == mode && patchInitialStylingValue(initialStyles = initialStyles || context[3], attr, attrs[++i], directiveIndex);
                }
            }
        }
        function patchInitialStylingValue(initialStyling, prop, value, directiveOwnerIndex) {
            for (var i = 2; i < initialStyling.length; i += 3) if (initialStyling[i + 0] === prop) return void (allowValueChange(initialStyling[i + 1], value, initialStyling[i + 2], directiveOwnerIndex) && addOrUpdateStaticStyle(i, initialStyling, prop, value, directiveOwnerIndex));
            addOrUpdateStaticStyle(null, initialStyling, prop, value, directiveOwnerIndex);
        }
        function renderInitialClasses(element, context, renderer, startIndex) {
            for (var initialClasses = context[4], i = startIndex || 2; i < initialClasses.length; ) initialClasses[i + 1] && setClass(element, initialClasses[i + 0], !0, renderer, null), 
            i += 3;
            return i;
        }
        function renderInitialStyles(element, context, renderer, startIndex) {
            for (var initialStyles = context[3], i = startIndex || 2; i < initialStyles.length; ) {
                var value = initialStyles[i + 1];
                value && setStyle(element, initialStyles[i + 0], value, renderer, null), i += 3;
            }
            return i;
        }
        function getMatchingBindingIndex(context, bindingName, start, end) {
            for (var j = start; j < end; j += 4) if (getProp(context, j) === bindingName) return j;
            return -1;
        }
        function patchStylingMapIntoContext(context, directiveIndex, playerBuilderIndex, ctxStart, ctxEnd, props, values, cacheValue, entryIsClassBased) {
            for (var dirty = !1, cacheIndex = 1 + 4 * directiveIndex, cachedValues = context[entryIsClassBased ? 6 : 7], ownershipValuesStartIndex = cachedValues[cacheIndex + 1], existingCachedValueCount = cachedValues[cacheIndex + 3], valuesEntryShapeChange = 1 === cachedValues[cacheIndex + 0] || !(cachedValues[cacheIndex + 2] || !cacheValue), totalUniqueValues = 0, totalNewAllocatedSlots = 0, applyAllProps = !0 === values, ctxIndex = ctxStart, totalRemainingProperties = props.length; ctxIndex < ownershipValuesStartIndex; ) {
                var currentProp = getProp(context, ctxIndex);
                if (totalRemainingProperties) for (var i = 0; i < props.length; i++) if ((normalizedProp = (mapProp = props[i]) ? entryIsClassBased ? mapProp : hyphenate(mapProp) : null) && currentProp === normalizedProp) {
                    var currentValue = getValue(context, ctxIndex), currentDirectiveIndex = getDirectiveIndexFromEntry(context, ctxIndex), value = !!applyAllProps || values[normalizedProp], currentFlag = getPointers(context, ctxIndex);
                    hasValueChanged(currentFlag, currentValue, value) && allowValueChange(currentValue, value, currentDirectiveIndex, directiveIndex) && (setValue(context, ctxIndex, value), 
                    setPlayerBuilderIndex(context, ctxIndex, playerBuilderIndex, directiveIndex), hasInitialValueChanged(context, currentFlag, value) && (setDirty(context, ctxIndex, !0), 
                    dirty = !0)), props[i] = null, totalRemainingProperties--;
                    break;
                }
                ctxIndex += 4;
            }
            if (totalRemainingProperties) {
                var sanitizer = entryIsClassBased ? null : getStyleSanitizer(context, directiveIndex);
                propertiesLoop: for (i = 0; i < props.length; i++) {
                    var mapProp;
                    if (mapProp = props[i]) {
                        value = !!applyAllProps || values[mapProp];
                        for (var normalizedProp = entryIsClassBased ? mapProp : hyphenate(mapProp), isInsideOwnershipArea = ctxIndex >= ownershipValuesStartIndex, j = ctxIndex; j < ctxEnd; j += 4) if (getProp(context, j) === normalizedProp) {
                            var distantCtxDirectiveIndex = getDirectiveIndexFromEntry(context, j), distantCtxPlayerBuilderIndex = getPlayerBuilderIndex(context, j), distantCtxValue = getValue(context, j), distantCtxFlag = getPointers(context, j);
                            allowValueChange(distantCtxValue, value, distantCtxDirectiveIndex, directiveIndex) && (isInsideOwnershipArea && (swapMultiContextEntries(context, ctxIndex, j), 
                            totalUniqueValues++), hasValueChanged(distantCtxFlag, distantCtxValue, value) && ((null === value || void 0 === value && value !== distantCtxValue) && (valuesEntryShapeChange = !0), 
                            setValue(context, ctxIndex, value), (null !== distantCtxValue || hasInitialValueChanged(context, distantCtxFlag, value)) && (setDirty(context, ctxIndex, !0), 
                            dirty = !0)), distantCtxDirectiveIndex === directiveIndex && playerBuilderIndex === distantCtxPlayerBuilderIndex || setPlayerBuilderIndex(context, ctxIndex, playerBuilderIndex, directiveIndex)), 
                            ctxIndex += 4;
                            continue propertiesLoop;
                        }
                        null != value && (valuesEntryShapeChange = !0, totalUniqueValues++, insertNewMultiProperty(context, isInsideOwnershipArea ? ctxIndex : ownershipValuesStartIndex + 4 * totalNewAllocatedSlots, entryIsClassBased, normalizedProp, 1 | prepareInitialFlag(context, normalizedProp, entryIsClassBased, sanitizer), value, directiveIndex, playerBuilderIndex), 
                        totalNewAllocatedSlots++, ctxEnd += 4, ctxIndex += 4, dirty = !0);
                    }
                }
            }
            for (;ctxIndex < ctxEnd; ) {
                valuesEntryShapeChange = !0;
                var ctxValue = getValue(context, ctxIndex), ctxFlag = getPointers(context, ctxIndex);
                getDirectiveIndexFromEntry(context, ctxIndex), null != ctxValue && (valuesEntryShapeChange = !0), 
                hasValueChanged(ctxFlag, ctxValue, null) && (setValue(context, ctxIndex, null), 
                hasInitialValueChanged(context, ctxFlag, ctxValue) && (setDirty(context, ctxIndex, !0), 
                dirty = !0), setPlayerBuilderIndex(context, ctxIndex, playerBuilderIndex, directiveIndex)), 
                ctxIndex += 4;
            }
            return function(context, directiveIndex, entryIsClassBased, cacheValue, startPosition, endPosition, totalValues, dirtyFutureValues) {
                var values = context[entryIsClassBased ? 6 : 7], index = 1 + 4 * directiveIndex;
                if (dirtyFutureValues) for (var nextStartPosition = startPosition + 4 * totalValues, i = index + 4; i < values.length; i += 4) values[i + 1] = nextStartPosition, 
                values[i + 0] = 1;
                values[index + 0] = 0, values[index + 1] = startPosition, values[index + 2] = cacheValue, 
                values[index + 3] = totalValues;
                var totalStylingEntries = totalValues;
                for (i = 1; i < index; i += 4) totalStylingEntries += values[i + 3];
                if (!entryIsClassBased) {
                    var classCache = context[6], diffInStartPosition = endPosition - classCache[2];
                    for (i = 1; i < classCache.length; i += 4) classCache[i + 1] += diffInStartPosition;
                }
                values[0] = totalStylingEntries;
            }(context, directiveIndex, entryIsClassBased, cacheValue, ownershipValuesStartIndex, ctxEnd, totalUniqueValues, valuesEntryShapeChange = valuesEntryShapeChange || existingCachedValueCount !== totalUniqueValues), 
            dirty && (setContextDirty(context, !0), setDirectiveDirty(context, directiveIndex, !0)), 
            totalNewAllocatedSlots;
        }
        function updateSingleStylingValue(context, offset, input, isClassBased, directiveRef, forceOverride) {
            var directiveIndex = getDirectiveIndexFromRegistry(context, directiveRef || null), singleIndex = function(context, directiveIndex, offset, isClassBased) {
                var singlePropOffsetRegistryIndex = context[2][4 * directiveIndex + 1], offsets = context[5];
                return offsets[singlePropOffsetRegistryIndex + 2 + (isClassBased ? offsets[singlePropOffsetRegistryIndex + 0] : 0) + offset];
            }(context, directiveIndex, offset, isClassBased), currValue = getValue(context, singleIndex), currFlag = getPointers(context, singleIndex), currDirective = getDirectiveIndexFromEntry(context, singleIndex), value = input instanceof BoundPlayerFactory ? input.value : input;
            if (hasValueChanged(currFlag, currValue, value) && (forceOverride || allowValueChange(currValue, value, currDirective, directiveIndex))) {
                var playerBuilder = input instanceof BoundPlayerFactory ? new ClassAndStylePlayerBuilder(input, context[0], 2 == (2 & currFlag) ? 1 : 2) : null, value_1 = playerBuilder ? input.value : input, currPlayerIndex = getPlayerBuilderIndex(context, singleIndex), playerBuildersAreDirty = !1, playerBuilderIndex = playerBuilder ? currPlayerIndex : 0;
                if (hasPlayerBuilderChanged(context, playerBuilder, currPlayerIndex)) {
                    var newIndex = setPlayerBuilder(context, playerBuilder, currPlayerIndex);
                    playerBuilderIndex = playerBuilder ? newIndex : 0, playerBuildersAreDirty = !0;
                }
                if ((playerBuildersAreDirty || currDirective !== directiveIndex) && setPlayerBuilderIndex(context, singleIndex, playerBuilderIndex, directiveIndex), 
                currDirective !== directiveIndex) {
                    var prop = getProp(context, singleIndex), sanitizer = getStyleSanitizer(context, directiveIndex);
                    !function(context, index, sanitizeYes) {
                        sanitizer && sanitizer(prop) ? context[index] |= 4 : context[index] &= -5;
                    }(context, singleIndex);
                }
                setValue(context, singleIndex, value_1);
                var indexForMulti = getMultiOrSingleIndex(currFlag), valueForMulti = getValue(context, indexForMulti);
                if (!valueForMulti || hasValueChanged(currFlag, valueForMulti, value_1)) {
                    var multiDirty = !1, singleDirty = !0;
                    !valueExists(value_1) && valueExists(valueForMulti) && (multiDirty = !0, singleDirty = !1), 
                    setDirty(context, indexForMulti, multiDirty), setDirty(context, singleIndex, singleDirty), 
                    setDirectiveDirty(context, directiveIndex, !0), setContextDirty(context, !0);
                }
                playerBuildersAreDirty && setContextPlayersDirty(context, !0);
            }
        }
        function setStyle(native, prop, value, renderer, sanitizer, store, playerBuilder) {
            value = sanitizer && value ? sanitizer(prop, value) : value, store || playerBuilder ? (store && store.setValue(prop, value), 
            playerBuilder && playerBuilder.setValue(prop, value)) : value ? (value = value.toString(), 
            isProceduralRenderer(renderer) ? renderer.setStyle(native, prop, value, RendererStyleFlags3.DashCase) : native.style.setProperty(prop, value)) : isProceduralRenderer(renderer) ? renderer.removeStyle(native, prop, RendererStyleFlags3.DashCase) : native.style.removeProperty(prop);
        }
        function setClass(native, className, add, renderer, store, playerBuilder) {
            store || playerBuilder ? (store && store.setValue(className, add), playerBuilder && playerBuilder.setValue(className, add)) : "" !== className && (add ? isProceduralRenderer(renderer) ? renderer.addClass(native, className) : native.classList.add(className) : isProceduralRenderer(renderer) ? renderer.removeClass(native, className) : native.classList.remove(className));
        }
        function setDirty(context, index, isDirtyYes) {
            var adjustedIndex = index >= 9 ? index + 0 : index;
            isDirtyYes ? context[adjustedIndex] |= 1 : context[adjustedIndex] &= -2;
        }
        function isDirty(context, index) {
            return 1 == (1 & context[index >= 9 ? index + 0 : index]);
        }
        function isClassBasedValue(context, index) {
            return 2 == (2 & context[index >= 9 ? index + 0 : index]);
        }
        function isSanitizable(context, index) {
            return 4 == (4 & context[index >= 9 ? index + 0 : index]);
        }
        function pointers(configFlag, staticIndex, dynamicIndex) {
            return 31 & configFlag | staticIndex << 5 | dynamicIndex << 19;
        }
        function getInitialValue(context, flag) {
            var index = getInitialIndex(flag);
            return (2 & flag ? context[4] : context[3])[index];
        }
        function getInitialIndex(flag) {
            return flag >> 5 & 16383;
        }
        function getMultiOrSingleIndex(flag) {
            var index = flag >> 19 & 16383;
            return index >= 9 ? index : -1;
        }
        function getMultiClassesStartIndex(context) {
            return context[6][2];
        }
        function getMultiStylesStartIndex(context) {
            return context[7][2];
        }
        function setProp(context, index, prop) {
            context[index + 1] = prop;
        }
        function setValue(context, index, value) {
            context[index + 2] = value;
        }
        function hasPlayerBuilderChanged(context, builder, index) {
            var playerContext = context[8];
            if (builder) {
                if (!playerContext || 0 === index) return !0;
            } else if (!playerContext) return !1;
            return playerContext[index] !== builder;
        }
        function setPlayerBuilder(context, builder, insertionIndex) {
            var playerContext = context[8] || (context[8] = [ 5, null, null, null, null ]);
            return insertionIndex > 0 ? playerContext[insertionIndex] = builder : (playerContext.splice(insertionIndex = playerContext[0], 0, builder, null), 
            playerContext[0] += 2), insertionIndex;
        }
        function setPlayerBuilderIndex(context, index, playerBuilderIndex, directiveIndex) {
            var value = function(directiveIndex, playerIndex) {
                return playerBuilderIndex << 16 | directiveIndex;
            }(directiveIndex);
            context[index + 3] = value;
        }
        function getPlayerBuilderIndex(context, index) {
            return context[index + 3] >> 16 & 65535;
        }
        function getPlayerBuilder(context, index) {
            var playerBuilderIndex = getPlayerBuilderIndex(context, index);
            if (playerBuilderIndex) {
                var playerContext = context[8];
                if (playerContext) return playerContext[playerBuilderIndex];
            }
            return null;
        }
        function setFlag(context, index, flag) {
            context[1 === index ? index : index + 0] = flag;
        }
        function getPointers(context, index) {
            return context[1 === index ? index : index + 0];
        }
        function getValue(context, index) {
            return context[index + 2];
        }
        function getProp(context, index) {
            return context[index + 1];
        }
        function setContextDirty(context, isDirtyYes) {
            setDirty(context, 1, isDirtyYes);
        }
        function setContextPlayersDirty(context, isDirtyYes) {
            isDirtyYes ? context[1] |= 8 : context[1] &= -9;
        }
        function swapMultiContextEntries(context, indexA, indexB) {
            if (indexA !== indexB) {
                var tmpValue = getValue(context, indexA), tmpProp = getProp(context, indexA), tmpFlag = getPointers(context, indexA), tmpPlayerBuilderIndex = getPlayerBuilderIndex(context, indexA), tmpDirectiveIndex = getDirectiveIndexFromEntry(context, indexA), flagA = tmpFlag, flagB = getPointers(context, indexB), singleIndexA = getMultiOrSingleIndex(flagA);
                singleIndexA >= 0 && setFlag(context, singleIndexA, pointers(_flag = getPointers(context, singleIndexA), getInitialIndex(_flag), indexB));
                var _flag, singleIndexB = getMultiOrSingleIndex(flagB);
                singleIndexB >= 0 && setFlag(context, singleIndexB, pointers(_flag = getPointers(context, singleIndexB), getInitialIndex(_flag), indexA)), 
                setValue(context, indexA, getValue(context, indexB)), setProp(context, indexA, getProp(context, indexB)), 
                setFlag(context, indexA, getPointers(context, indexB)), setPlayerBuilderIndex(context, indexA, getPlayerBuilderIndex(context, indexB), getDirectiveIndexFromEntry(context, indexB)), 
                setValue(context, indexB, tmpValue), setProp(context, indexB, tmpProp), setFlag(context, indexB, tmpFlag), 
                setPlayerBuilderIndex(context, indexB, tmpPlayerBuilderIndex, tmpDirectiveIndex);
            }
        }
        function insertNewMultiProperty(context, index, classBased, name, flag, value, directiveIndex, playerIndex) {
            var doShift = index < context.length;
            context.splice(index, 0, 1 | flag | (classBased ? 2 : 0), name, value, 0), setPlayerBuilderIndex(context, index, playerIndex, directiveIndex), 
            doShift && function(context, indexStartPosition) {
                for (var i = index + 4; i < context.length; i += 4) {
                    var singleIndex = getMultiOrSingleIndex(getPointers(context, i));
                    if (singleIndex > 0) {
                        var initialIndexForSingle = getInitialIndex(getPointers(context, singleIndex));
                        setFlag(context, singleIndex, pointers((isDirty(context, singleIndex) ? 1 : 0) | (isClassBasedValue(context, singleIndex) ? 2 : 0) | (isSanitizable(context, singleIndex) ? 4 : 0), initialIndexForSingle, i));
                    }
                }
            }(context);
        }
        function valueExists(value, isClassBased) {
            return null !== value;
        }
        function prepareInitialFlag(context, prop, entryIsClassBased, sanitizer) {
            var initialIndex, flag = sanitizer && sanitizer(prop) ? 4 : 0;
            return entryIsClassBased ? (flag |= 2, initialIndex = getInitialStylingValuesIndexOf(context[4], prop)) : initialIndex = getInitialStylingValuesIndexOf(context[3], prop), 
            pointers(flag, initialIndex = initialIndex > 0 ? initialIndex + 1 : 0, 0);
        }
        function hasInitialValueChanged(context, flag, newValue) {
            var initialValue = getInitialValue(context, flag);
            return !initialValue || hasValueChanged(flag, initialValue, newValue);
        }
        function hasValueChanged(flag, a, b) {
            return !(2 & flag) && a && b && 4 & flag ? a.toString() !== b.toString() : a !== b;
        }
        var ClassAndStylePlayerBuilder = function() {
            function ClassAndStylePlayerBuilder(factory, _element, _type) {
                this._element = _element, this._type = _type, this._values = {}, this._dirty = !1, 
                this._factory = factory;
            }
            return ClassAndStylePlayerBuilder.prototype.setValue = function(prop, value) {
                this._values[prop] !== value && (this._values[prop] = value, this._dirty = !0);
            }, ClassAndStylePlayerBuilder.prototype.buildPlayer = function(currentPlayer, isFirstRender) {
                if (this._dirty) {
                    var player = this._factory.fn(this._element, this._type, this._values, isFirstRender, currentPlayer || null);
                    return this._values = {}, this._dirty = !1, player;
                }
            }, ClassAndStylePlayerBuilder;
        }();
        function getDirectiveIndexFromEntry(context, index) {
            return 65535 & context[index + 3];
        }
        function getDirectiveIndexFromRegistry(context, directiveRef) {
            var directiveIndex, dirs = context[2], index = getDirectiveRegistryValuesIndexOf(dirs, directiveRef);
            if (-1 === index) {
                directiveIndex = (index = dirs.length) > 0 ? index / 4 : 0, dirs.push(null, null, null, null), 
                dirs[index + 0] = directiveRef, dirs[index + 2] = !1, dirs[index + 1] = -1;
                var classesStartIndex = getMultiClassesStartIndex(context) || 9;
                registerMultiMapEntry(context, directiveIndex, !0, context.length), registerMultiMapEntry(context, directiveIndex, !1, classesStartIndex);
            } else directiveIndex = index > 0 ? index / 4 : 0;
            return directiveIndex;
        }
        function getDirectiveRegistryValuesIndexOf(directives, directive) {
            for (var i = 0; i < directives.length; i += 4) if (directives[i] === directive) return i;
            return -1;
        }
        function getInitialStylingValuesIndexOf(keyValues, key) {
            for (var i = 2; i < keyValues.length; i += 3) if (keyValues[i] === key) return i;
            return -1;
        }
        function getStyleSanitizer(context, directiveIndex) {
            var dirs = context[2];
            return dirs[4 * directiveIndex + 3] || dirs[3] || null;
        }
        function setDirectiveDirty(context, directiveIndex, dirtyYes) {
            context[2][4 * directiveIndex + 2] = dirtyYes;
        }
        function allowValueChange(currentValue, newValue, currentDirectiveOwner, newDirectiveOwner) {
            return null == currentValue || (null != newValue ? newDirectiveOwner <= currentDirectiveOwner : currentDirectiveOwner === newDirectiveOwner);
        }
        function getInitialClassNameValue(context) {
            var initialClassValues = context[4], className = initialClassValues[1];
            if (null === className) {
                className = "";
                for (var i = 2; i < initialClassValues.length; i += 3) initialClassValues[i + 1] && (className += (className.length ? " " : "") + initialClassValues[i]);
                initialClassValues[1] = className;
            }
            return className;
        }
        function readCachedMapValue(context, entryIsClassBased, directiveIndex) {
            return context[entryIsClassBased ? 6 : 7][1 + 4 * directiveIndex + 2] || null;
        }
        function isMultiValueCacheHit(context, entryIsClassBased, directiveIndex, newValue) {
            return !context[entryIsClassBased ? 6 : 7][1 + 4 * directiveIndex + 0] && (newValue === NO_CHANGE || readCachedMapValue(context, entryIsClassBased, directiveIndex) === newValue);
        }
        function hyphenate(value) {
            return value.replace(/[a-z][A-Z]/g, function(match) {
                return match.charAt(0) + "-" + match.charAt(1).toLowerCase();
            });
        }
        function registerMultiMapEntry(context, directiveIndex, entryIsClassBased, startPosition, count) {
            void 0 === count && (count = 0);
            var cachedValues = context[entryIsClassBased ? 6 : 7];
            if (directiveIndex > 0) for (var limit = 1 + 4 * directiveIndex; cachedValues.length < limit; ) cachedValues.push(0, startPosition, null, 0);
            cachedValues.push(0, startPosition, null, count);
        }
        function addOrUpdateStaticStyle(index, staticStyles, prop, value, directiveOwnerIndex) {
            return null === index && (index = staticStyles.length, staticStyles.push(null, null, null), 
            staticStyles[index + 0] = prop), staticStyles[index + 1] = value, staticStyles[index + 2] = directiveOwnerIndex, 
            index;
        }
        var NG_TEMPLATE_SELECTOR = "ng-template";
        function isCssClassMatching(nodeClassAttrVal, cssClassToMatch) {
            var nodeClassesLen = nodeClassAttrVal.length, matchIndex = nodeClassAttrVal.indexOf(cssClassToMatch), matchEndIdx = matchIndex + cssClassToMatch.length;
            return !(-1 === matchIndex || matchIndex > 0 && " " !== nodeClassAttrVal[matchIndex - 1] || matchEndIdx < nodeClassesLen && " " !== nodeClassAttrVal[matchEndIdx]);
        }
        function hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {
            return currentSelector === (0 !== tNode.type || isProjectionMode ? tNode.tagName : NG_TEMPLATE_SELECTOR);
        }
        function isNodeMatchingSelector(tNode, selector, isProjectionMode) {
            for (var mode = 4, nodeAttrs = tNode.attrs || [], nameOnlyMarkerIdx = function(nodeAttrs) {
                for (var i = 0; i < nodeAttrs.length; i++) if (isNameOnlyAttributeMarker(nodeAttrs[i])) return i;
                return nodeAttrs.length;
            }(nodeAttrs), skipToNextSelector = !1, i = 0; i < selector.length; i++) {
                var current = selector[i];
                if ("number" != typeof current) {
                    if (!skipToNextSelector) if (4 & mode) {
                        if (mode = 2 | 1 & mode, "" !== current && !hasTagAndTypeMatch(tNode, current, isProjectionMode) || "" === current && 1 === selector.length) {
                            if (isPositive(mode)) return !1;
                            skipToNextSelector = !0;
                        }
                    } else {
                        var selectorAttrValue = 8 & mode ? current : selector[++i];
                        if (8 & mode && tNode.stylingTemplate) {
                            if (!isCssClassMatching(readClassValueFromTNode(tNode), selectorAttrValue)) {
                                if (isPositive(mode)) return !1;
                                skipToNextSelector = !0;
                            }
                            continue;
                        }
                        var attrIndexInNode = findAttrIndexInNode(8 & mode ? "class" : current, nodeAttrs, 0 == tNode.type && tNode.tagName !== NG_TEMPLATE_SELECTOR, isProjectionMode);
                        if (-1 === attrIndexInNode) {
                            if (isPositive(mode)) return !1;
                            skipToNextSelector = !0;
                            continue;
                        }
                        if ("" !== selectorAttrValue) {
                            var nodeAttrValue;
                            nodeAttrValue = attrIndexInNode > nameOnlyMarkerIdx ? "" : nodeAttrs[attrIndexInNode + 1];
                            var compareAgainstClassName = 8 & mode ? nodeAttrValue : null;
                            if (compareAgainstClassName && !isCssClassMatching(compareAgainstClassName, selectorAttrValue) || 2 & mode && selectorAttrValue !== nodeAttrValue) {
                                if (isPositive(mode)) return !1;
                                skipToNextSelector = !0;
                            }
                        }
                    }
                } else {
                    if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) return !1;
                    if (skipToNextSelector && isPositive(current)) continue;
                    skipToNextSelector = !1, mode = current | 1 & mode;
                }
            }
            return isPositive(mode) || skipToNextSelector;
        }
        function isPositive(mode) {
            return 0 == (1 & mode);
        }
        function readClassValueFromTNode(tNode) {
            return tNode.stylingTemplate ? getInitialClassNameValue(tNode.stylingTemplate) : "";
        }
        function findAttrIndexInNode(name, attrs, isInlineTemplate, isProjectionMode) {
            if (null === attrs) return -1;
            var i = 0;
            if (isProjectionMode || !isInlineTemplate) {
                for (var bindingsMode = !1; i < attrs.length; ) {
                    var maybeAttrName = attrs[i];
                    if (maybeAttrName === name) return i;
                    if (3 === maybeAttrName) bindingsMode = !0; else {
                        if (4 === maybeAttrName) break;
                        if (0 === maybeAttrName) {
                            i += 4;
                            continue;
                        }
                    }
                    i += bindingsMode ? 1 : 2;
                }
                return -1;
            }
            return function(attrs, name) {
                var i = attrs.indexOf(4);
                if (i > -1) for (i++; i < attrs.length; ) {
                    if (attrs[i] === name) return i;
                    i++;
                }
                return -1;
            }(attrs, name);
        }
        function isNodeMatchingSelectorList(tNode, selector, isProjectionMode) {
            void 0 === isProjectionMode && (isProjectionMode = !1);
            for (var i = 0; i < selector.length; i++) if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) return !0;
            return !1;
        }
        function matchingProjectionSelectorIndex(tNode, selectors, textSelectors) {
            for (var ngProjectAsAttrVal = function(tNode) {
                var nodeAttrs = tNode.attrs;
                if (null != nodeAttrs) {
                    var ngProjectAsAttrIdx = nodeAttrs.indexOf(NG_PROJECT_AS_ATTR_NAME);
                    if (0 == (1 & ngProjectAsAttrIdx)) return nodeAttrs[ngProjectAsAttrIdx + 1];
                }
                return null;
            }(tNode), i = 0; i < selectors.length; i++) if (ngProjectAsAttrVal === textSelectors[i] || null === ngProjectAsAttrVal && isNodeMatchingSelectorList(tNode, selectors[i], !0)) return i + 1;
            return 0;
        }
        var _CLEAN_PROMISE = Promise.resolve(null);
        function refreshDescendantViews(lView) {
            var tView = lView[TVIEW], creationMode = isCreationMode(lView);
            if (tView.firstTemplatePass = !1, lView[BINDING_INDEX] = tView.bindingStartIndex, 
            !creationMode) {
                var checkNoChangesMode = getCheckNoChangesMode();
                executePreOrderHooks(lView, tView, checkNoChangesMode, void 0), function(lView) {
                    for (var current = lView[CHILD_HEAD]; null !== current; current = current[NEXT]) if (current.length < HEADER_OFFSET && -1 === current[ACTIVE_INDEX]) for (var container = current, i = 0; i < container[VIEWS].length; i++) {
                        var dynamicViewData = container[VIEWS][i];
                        renderEmbeddedTemplate(dynamicViewData, dynamicViewData[TVIEW], dynamicViewData[CONTEXT]);
                    }
                }(lView), refreshContentQueries(tView, lView), resetPreOrderHookFlags(lView), executeHooks(lView, tView.contentHooks, tView.contentCheckHooks, checkNoChangesMode, 1, void 0), 
                function(tView, viewData) {
                    if (tView.expandoInstructions) {
                        var bindingRootIndex = viewData[BINDING_INDEX] = tView.expandoStartIndex;
                        setBindingRoot(bindingRootIndex);
                        for (var currentDirectiveIndex = -1, currentElementIndex = -1, i = 0; i < tView.expandoInstructions.length; i++) {
                            var instruction = tView.expandoInstructions[i];
                            if ("number" == typeof instruction) {
                                if (instruction <= 0) {
                                    currentElementIndex = -instruction;
                                    var providerCount = tView.expandoInstructions[++i];
                                    currentDirectiveIndex = bindingRootIndex += INJECTOR_BLOOM_PARENT_SIZE + providerCount;
                                } else bindingRootIndex += instruction;
                                setBindingRoot(bindingRootIndex);
                            } else {
                                if (null !== instruction) {
                                    viewData[BINDING_INDEX] = bindingRootIndex;
                                    var hostCtx = unwrapRNode(viewData[currentDirectiveIndex]);
                                    setActiveHost(hostCtx, currentElementIndex), instruction(2, hostCtx, currentElementIndex), 
                                    setActiveHost(null);
                                }
                                currentDirectiveIndex++;
                            }
                        }
                    }
                }(tView, lView);
            }
            creationMode && tView.staticContentQueries && refreshContentQueries(tView, lView), 
            function(components) {
                if (null != components) for (var i = 0; i < components.length; i++) void 0, void 0, 
                128 == (128 & (hostView = getComponentViewByIndex(components[i], getLView()))[FLAGS]) && 80 & hostView[FLAGS] && (function(componentView) {
                    for (var componentTView = componentView[TVIEW], i = componentView.length; i < componentTView.blueprint.length; i++) componentView[i] = componentTView.blueprint[i];
                }(hostView), checkView(hostView, hostView[CONTEXT]));
                var hostView;
            }(tView.components);
        }
        function refreshContentQueries(tView, lView) {
            if (null != tView.contentQueries) {
                setCurrentQueryIndex(0);
                for (var i = 0; i < tView.contentQueries.length; i++) {
                    var directiveDefIdx = tView.contentQueries[i];
                    tView.data[directiveDefIdx].contentQueries(2, lView[directiveDefIdx], directiveDefIdx);
                }
            }
        }
        function elementCreate(name, overriddenRenderer) {
            var rendererToUse = overriddenRenderer || getLView()[RENDERER], namespace = _currentNamespace;
            return isProceduralRenderer(rendererToUse) ? rendererToUse.createElement(name, namespace) : null === namespace ? rendererToUse.createElement(name) : rendererToUse.createElementNS(namespace, name);
        }
        function createLView(parentLView, tView, context, flags, host, tHostNode, rendererFactory, renderer, sanitizer, injector) {
            var lView = tView.blueprint.slice();
            return lView[HOST] = host, lView[FLAGS] = 140 | flags, resetPreOrderHookFlags(lView), 
            lView[PARENT] = lView[DECLARATION_VIEW] = parentLView, lView[CONTEXT] = context, 
            lView[RENDERER_FACTORY] = rendererFactory || parentLView && parentLView[RENDERER_FACTORY], 
            lView[RENDERER] = renderer || parentLView && parentLView[RENDERER], lView[SANITIZER] = sanitizer || parentLView && parentLView[SANITIZER] || null, 
            lView[INJECTOR$1] = injector || parentLView && parentLView[INJECTOR$1] || null, 
            lView[T_HOST] = tHostNode, lView;
        }
        function createNodeAtIndex(index, type, native, name, attrs) {
            var lView = getLView(), tView = lView[TVIEW], adjustedIndex = index + HEADER_OFFSET;
            lView[adjustedIndex] = native;
            var previousOrParentTNode = getPreviousOrParentTNode(), isParent = getIsParent(), tNode = tView.data[adjustedIndex];
            if (null == tNode) {
                var parent_1 = isParent ? previousOrParentTNode : previousOrParentTNode && previousOrParentTNode.parent;
                tNode = tView.data[adjustedIndex] = createTNode(parent_1 && parent_1 !== lView[T_HOST] ? parent_1 : null, type, adjustedIndex, name, attrs);
            }
            return previousOrParentTNode && (!isParent || null != previousOrParentTNode.child || null === tNode.parent && 2 !== previousOrParentTNode.type ? isParent || (previousOrParentTNode.next = tNode) : previousOrParentTNode.child = tNode), 
            null == tView.firstChild && (tView.firstChild = tNode), setPreviousOrParentTNode(tNode), 
            setIsParent(!0), tNode;
        }
        function assignTViewNodeToLView(tView, tParentNode, index, lView) {
            var tNode = tView.node;
            return null == tNode && (tView.node = tNode = createTNode(tParentNode, 2, index, null, null)), 
            lView[T_HOST] = tNode;
        }
        function renderEmbeddedTemplate(viewToRender, tView, context) {
            var oldView, _isParent = getIsParent(), _previousOrParentTNode = getPreviousOrParentTNode();
            if (512 & viewToRender[FLAGS]) tickRootContext(getRootContext(viewToRender)); else try {
                setIsParent(!0), setPreviousOrParentTNode(null), oldView = enterView(viewToRender, viewToRender[T_HOST]), 
                resetPreOrderHookFlags(viewToRender), namespaceHTML(), tView.template(getRenderFlags(viewToRender), context), 
                viewToRender[TVIEW].firstTemplatePass = !1, refreshDescendantViews(viewToRender);
            } finally {
                leaveView(oldView), setIsParent(_isParent), setPreviousOrParentTNode(_previousOrParentTNode);
            }
        }
        function renderComponentOrTemplate(hostView, context, templateFn) {
            var rendererFactory = hostView[RENDERER_FACTORY], oldView = enterView(hostView, hostView[T_HOST]), normalExecutionPath = !getCheckNoChangesMode(), creationModeIsActive = isCreationMode(hostView);
            try {
                normalExecutionPath && !creationModeIsActive && rendererFactory.begin && rendererFactory.begin(), 
                creationModeIsActive && (templateFn && (namespaceHTML(), templateFn(1, context)), 
                refreshDescendantViews(hostView), hostView[FLAGS] &= -5), resetPreOrderHookFlags(hostView), 
                templateFn && templateFn(2, context), refreshDescendantViews(hostView);
            } finally {
                normalExecutionPath && !creationModeIsActive && rendererFactory.end && rendererFactory.end(), 
                leaveView(oldView);
            }
        }
        function getRenderFlags(view) {
            return isCreationMode(view) ? 1 : 2;
        }
        function createDirectivesAndLocals(tView, lView, localRefs, localRefExtractor) {
            if (void 0 === localRefExtractor && (localRefExtractor = getNativeByTNode), bindingsEnabled) {
                var previousOrParentTNode = getPreviousOrParentTNode();
                tView.firstTemplatePass && function(tView, viewData, directives, tNode, localRefs) {
                    var exportsMap = localRefs ? {
                        "": -1
                    } : null;
                    if (directives) {
                        initNodeFlags(tNode, tView.data.length, directives.length);
                        for (var i = 0; i < directives.length; i++) (def = directives[i]).providersResolver && def.providersResolver(def);
                        generateExpandoInstructionBlock(tView, tNode, directives.length);
                        var initialPreOrderHooksLength = tView.preOrderHooks && tView.preOrderHooks.length || 0, initialPreOrderCheckHooksLength = tView.preOrderCheckHooks && tView.preOrderCheckHooks.length || 0, nodeIndex = tNode.index - HEADER_OFFSET;
                        for (i = 0; i < directives.length; i++) {
                            var def, directiveDefIdx = tView.data.length;
                            baseResolveDirective(tView, viewData, def = directives[i], def.factory), saveNameToExportMap(tView.data.length - 1, def, exportsMap), 
                            registerPreOrderHooks(directiveDefIdx, def, tView, nodeIndex, initialPreOrderHooksLength, initialPreOrderCheckHooksLength);
                        }
                    }
                    exportsMap && function(tNode, localRefs, exportsMap) {
                        if (localRefs) for (var localNames = tNode.localNames = [], i = 0; i < localRefs.length; i += 2) {
                            var index = exportsMap[localRefs[i + 1]];
                            if (null == index) throw new Error("Export of name '" + localRefs[i + 1] + "' not found!");
                            localNames.push(localRefs[i], index);
                        }
                    }(tNode, localRefs, exportsMap);
                }(tView, lView, function(tView, viewData, tNode) {
                    var registry = tView.directiveRegistry, matches = null;
                    if (registry) for (var i = 0; i < registry.length; i++) {
                        var def = registry[i];
                        isNodeMatchingSelectorList(tNode, def.selectors, !1) && (matches || (matches = []), 
                        diPublicInInjector(getOrCreateNodeInjectorForNode(getPreviousOrParentTNode(), viewData), viewData, def.type), 
                        isComponentDef(def) ? (1 & tNode.flags && throwMultipleComponentError(tNode), tNode.flags = 1, 
                        matches.unshift(def)) : matches.push(def));
                    }
                    return matches;
                }(tView, lView, previousOrParentTNode), previousOrParentTNode, localRefs || null), 
                function(tView, lView, tNode) {
                    var start = tNode.directiveStart, end = tNode.directiveEnd;
                    !tView.firstTemplatePass && start < end && getOrCreateNodeInjectorForNode(tNode, lView);
                    for (var i = start; i < end; i++) {
                        var def = tView.data[i];
                        isComponentDef(def) && addComponentLogic(lView, tNode, def), postProcessDirective(lView, getNodeInjectable(tView.data, lView, i, tNode), def, i);
                    }
                }(tView, lView, previousOrParentTNode), function(tView, viewData, tNode) {
                    for (var end = tNode.directiveEnd, expando = tView.expandoInstructions, firstTemplatePass = tView.firstTemplatePass, i = tNode.directiveStart; i < end; i++) {
                        var def = tView.data[i];
                        def.hostBindings ? invokeHostBindingsInCreationMode(def, expando, viewData[i], tNode, firstTemplatePass) : firstTemplatePass && expando.push(null);
                    }
                }(tView, lView, previousOrParentTNode), function(viewData, tNode, localRefExtractor) {
                    var localNames = tNode.localNames;
                    if (localNames) for (var localIndex = tNode.index + 1, i = 0; i < localNames.length; i += 2) {
                        var index = localNames[i + 1], value = -1 === index ? localRefExtractor(tNode, viewData) : viewData[index];
                        viewData[localIndex++] = value;
                    }
                }(lView, previousOrParentTNode, localRefExtractor);
            }
        }
        function getOrCreateTView(templateFn, consts, vars, directives, pipes, viewQuery, schemas) {
            return templateFn.ngPrivateData || (templateFn.ngPrivateData = createTView(-1, templateFn, consts, vars, directives, pipes, viewQuery, schemas));
        }
        function createTView(viewIndex, templateFn, consts, vars, directives, pipes, viewQuery, schemas) {
            var bindingStartIndex = HEADER_OFFSET + consts, initialViewLength = bindingStartIndex + vars, blueprint = function(bindingStartIndex, initialViewLength) {
                var blueprint = new Array(initialViewLength).fill(null, 0, bindingStartIndex).fill(NO_CHANGE, bindingStartIndex);
                return blueprint[BINDING_INDEX] = bindingStartIndex, blueprint;
            }(bindingStartIndex, initialViewLength);
            return blueprint[TVIEW] = {
                id: viewIndex,
                blueprint: blueprint,
                template: templateFn,
                viewQuery: viewQuery,
                node: null,
                data: blueprint.slice().fill(null, bindingStartIndex),
                bindingStartIndex: bindingStartIndex,
                viewQueryStartIndex: initialViewLength,
                expandoStartIndex: initialViewLength,
                expandoInstructions: null,
                firstTemplatePass: !0,
                staticViewQueries: !1,
                staticContentQueries: !1,
                preOrderHooks: null,
                preOrderCheckHooks: null,
                contentHooks: null,
                contentCheckHooks: null,
                viewHooks: null,
                viewCheckHooks: null,
                destroyHooks: null,
                cleanup: null,
                contentQueries: null,
                components: null,
                directiveRegistry: "function" == typeof directives ? directives() : directives,
                pipeRegistry: "function" == typeof pipes ? pipes() : pipes,
                firstChild: null,
                schemas: schemas
            };
        }
        function createTNode(tParent, type, adjustedIndex, tagName, attrs) {
            return {
                type: type,
                index: adjustedIndex,
                injectorIndex: tParent ? tParent.injectorIndex : -1,
                directiveStart: -1,
                directiveEnd: -1,
                propertyMetadataStartIndex: -1,
                propertyMetadataEndIndex: -1,
                flags: 0,
                providerIndexes: 0,
                tagName: tagName,
                attrs: attrs,
                localNames: null,
                initialInputs: void 0,
                inputs: void 0,
                outputs: void 0,
                tViews: null,
                next: null,
                projectionNext: null,
                child: null,
                parent: tParent,
                stylingTemplate: null,
                projection: null,
                onElementCreationFns: null
            };
        }
        function generatePropertyAliases(tNode, direction) {
            var tView = getLView()[TVIEW], propStore = null, start = tNode.directiveStart, end = tNode.directiveEnd;
            if (end > start) for (var isInput = 0 === direction, defs = tView.data, i = start; i < end; i++) {
                var directiveDef = defs[i], propertyAliasMap = isInput ? directiveDef.inputs : directiveDef.outputs;
                for (var publicName in propertyAliasMap) if (propertyAliasMap.hasOwnProperty(publicName)) {
                    var internalName = propertyAliasMap[publicName];
                    (propStore = propStore || {}).hasOwnProperty(publicName) ? propStore[publicName].push(i, publicName, internalName) : propStore[publicName] = [ i, publicName, internalName ];
                }
            }
            return propStore;
        }
        function invokeHostBindingsInCreationMode(def, expando, directive, tNode, firstTemplatePass) {
            var previousExpandoLength = expando.length;
            setCurrentDirectiveDef(def);
            var elementIndex = tNode.index - HEADER_OFFSET;
            setActiveHost(directive, elementIndex), def.hostBindings(1, directive, elementIndex), 
            setActiveHost(null), setCurrentDirectiveDef(null), previousExpandoLength === expando.length && firstTemplatePass && expando.push(def.hostBindings);
        }
        function generateExpandoInstructionBlock(tView, tNode, directiveCount) {
            var elementIndex = -(tNode.index - HEADER_OFFSET), providerCount = tView.data.length - (65535 & tNode.providerIndexes);
            (tView.expandoInstructions || (tView.expandoInstructions = [])).push(elementIndex, providerCount, directiveCount);
        }
        function postProcessDirective(viewData, directive, def, directiveDefIdx) {
            var previousOrParentTNode = getPreviousOrParentTNode();
            postProcessBaseDirective(viewData, previousOrParentTNode, directive), previousOrParentTNode && previousOrParentTNode.attrs && function(directiveIndex, instance, def, tNode) {
                var initialInputData = previousOrParentTNode.initialInputs;
                (void 0 === initialInputData || directiveIndex >= initialInputData.length) && (initialInputData = function(directiveIndex, inputs, tNode) {
                    var initialInputData = tNode.initialInputs || (tNode.initialInputs = []);
                    initialInputData[directiveIndex] = null;
                    for (var attrs = tNode.attrs, i = 0; i < attrs.length; ) {
                        var attrName = attrs[i];
                        if (0 !== attrName) {
                            if ("number" == typeof attrName) break;
                            var minifiedInputName = inputs[attrName], attrValue = attrs[i + 1];
                            void 0 !== minifiedInputName && (initialInputData[directiveIndex] || (initialInputData[directiveIndex] = [])).push(attrName, minifiedInputName, attrValue), 
                            i += 2;
                        } else i += 4;
                    }
                    return initialInputData;
                }(directiveIndex, def.inputs, previousOrParentTNode));
                var initialInputs = initialInputData[directiveIndex];
                if (initialInputs) for (var setInput = def.setInput, i = 0; i < initialInputs.length; ) {
                    var publicName = initialInputs[i++], privateName = initialInputs[i++], value = initialInputs[i++];
                    setInput ? def.setInput(instance, value, publicName, privateName) : instance[privateName] = value;
                }
            }(directiveDefIdx, directive, def), viewData[TVIEW].firstTemplatePass && def.contentQueries && (previousOrParentTNode.flags |= 4), 
            isComponentDef(def) && (getComponentViewByIndex(previousOrParentTNode.index, viewData)[CONTEXT] = directive);
        }
        function postProcessBaseDirective(lView, previousOrParentTNode, directive) {
            var native = getNativeByTNode(previousOrParentTNode, lView);
            attachPatchData(directive, lView), native && attachPatchData(native, lView);
        }
        function queueComponentIndexForCheck(previousOrParentTNode) {
            var tView = getLView()[TVIEW];
            (tView.components || (tView.components = [])).push(previousOrParentTNode.index);
        }
        function saveNameToExportMap(index, def, exportsMap) {
            if (exportsMap) {
                if (def.exportAs) for (var i = 0; i < def.exportAs.length; i++) exportsMap[def.exportAs[i]] = index;
                def.template && (exportsMap[""] = index);
            }
        }
        function initNodeFlags(tNode, index, numberOfDirectives) {
            tNode.flags = 1 & tNode.flags, tNode.directiveStart = index, tNode.directiveEnd = index + numberOfDirectives, 
            tNode.providerIndexes = index;
        }
        function baseResolveDirective(tView, viewData, def, directiveFactory) {
            tView.data.push(def);
            var nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), null);
            tView.blueprint.push(nodeInjectorFactory), viewData.push(nodeInjectorFactory);
        }
        function addComponentLogic(lView, previousOrParentTNode, def) {
            var native = getNativeByTNode(previousOrParentTNode, lView), componentView = addToViewTree(lView, createLView(lView, getOrCreateTView(def.template, def.consts, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas), null, def.onPush ? 64 : 16, lView[previousOrParentTNode.index], previousOrParentTNode, lView[RENDERER_FACTORY], lView[RENDERER_FACTORY].createRenderer(native, def)));
            componentView[T_HOST] = previousOrParentTNode, lView[previousOrParentTNode.index] = componentView, 
            lView[TVIEW].firstTemplatePass && queueComponentIndexForCheck(previousOrParentTNode);
        }
        function createLContainer(hostNative, currentView, native, tNode, isForViewContainerRef) {
            return [ hostNative, !0, isForViewContainerRef ? -1 : 0, currentView, null, null, tNode, native, [] ];
        }
        function addToViewTree(lView, lViewOrLContainer) {
            return lView[CHILD_HEAD] ? lView[CHILD_TAIL][NEXT] = lViewOrLContainer : lView[CHILD_HEAD] = lViewOrLContainer, 
            lView[CHILD_TAIL] = lViewOrLContainer, lViewOrLContainer;
        }
        function markViewDirty(lView) {
            for (;lView; ) {
                lView[FLAGS] |= 64;
                var parent_2 = getLViewParent(lView);
                if (isRootView(lView) && !parent_2) return lView;
                lView = parent_2;
            }
            return null;
        }
        function tickRootContext(rootContext) {
            for (var i = 0; i < rootContext.components.length; i++) {
                var rootComponent = rootContext.components[i];
                renderComponentOrTemplate(readPatchedLView(rootComponent), rootComponent);
            }
        }
        function detectChangesInternal(view, context) {
            var rendererFactory = view[RENDERER_FACTORY];
            rendererFactory.begin && rendererFactory.begin();
            try {
                isCreationMode(view) && checkView(view, context), checkView(view, context);
            } catch (error) {
                throw handleError(view, error), error;
            } finally {
                rendererFactory.end && rendererFactory.end();
            }
        }
        function detectChangesInRootView(lView) {
            tickRootContext(lView[CONTEXT]);
        }
        function checkView(hostView, component) {
            var hostTView = hostView[TVIEW], oldView = enterView(hostView, hostView[T_HOST]), templateFn = hostTView.template, creationMode = isCreationMode(hostView);
            try {
                resetPreOrderHookFlags(hostView), namespaceHTML(), creationMode && executeViewQueryFn(1, hostTView, component), 
                templateFn(getRenderFlags(hostView), component), refreshDescendantViews(hostView), 
                creationMode && !hostTView.staticViewQueries || executeViewQueryFn(2, hostTView, component);
            } finally {
                leaveView(oldView);
            }
        }
        function executeViewQueryFn(flags, tView, component) {
            var viewQuery = tView.viewQuery;
            viewQuery && (setCurrentQueryIndex(tView.viewQueryStartIndex), viewQuery(flags, component));
        }
        function storeBindingMetadata(lView, prefix, suffix) {
            void 0 === prefix && (prefix = ""), void 0 === suffix && (suffix = "");
            var tData = lView[TVIEW].data, lastBindingIndex = lView[BINDING_INDEX] - 1;
            return null == tData[lastBindingIndex] ? tData[lastBindingIndex] = INTERPOLATION_DELIMITER + prefix + INTERPOLATION_DELIMITER + suffix : null;
        }
        var CLEAN_PROMISE = _CLEAN_PROMISE;
        function initializeTNodeInputs(tNode) {
            return tNode ? (void 0 === tNode.inputs && (tNode.inputs = generatePropertyAliases(tNode, 0)), 
            tNode.inputs) : null;
        }
        function getCleanup(view) {
            return view[CLEANUP] || (view[CLEANUP] = []);
        }
        function getTViewCleanup(view) {
            return view[TVIEW].cleanup || (view[TVIEW].cleanup = []);
        }
        function loadComponentRenderer(tNode, lView) {
            return lView[tNode.index][RENDERER];
        }
        function handleError(lView, error) {
            var injector = lView[INJECTOR$1], errorHandler = injector ? injector.get(ErrorHandler, null) : null;
            errorHandler && errorHandler.handleError(error);
        }
        function setInputsForProperty(lView, inputs, value) {
            for (var tView = lView[TVIEW], i = 0; i < inputs.length; ) {
                var index = inputs[i++], publicName = inputs[i++], privateName = inputs[i++], instance = lView[index], def = tView.data[index];
                def.setInput ? def.setInput(instance, value, publicName, privateName) : instance[privateName] = value;
            }
        }
        function applyOnCreateInstructions(tNode) {
            var fns;
            if (fns = tNode.onElementCreationFns) {
                for (var i = 0; i < fns.length; i++) fns[i]();
                tNode.onElementCreationFns = null;
            }
        }
        function allocHostVars(count) {
            var lView = getLView(), tView = lView[TVIEW];
            tView.firstTemplatePass && (function(tView, def, hostVars) {
                var expando = tView.expandoInstructions, length = expando.length;
                length >= 2 && expando[length - 2] === def.hostBindings ? expando[length - 1] = expando[length - 1] + hostVars : expando.push(def.hostBindings, hostVars);
            }(tView, currentDirectiveDef, count), function(tView, lView, totalHostVars) {
                for (var i = 0; i < totalHostVars; i++) lView.push(NO_CHANGE), tView.blueprint.push(NO_CHANGE), 
                tView.data.push(null);
            }(tView, lView, count));
        }
        function getLContainer(tNode, embeddedView) {
            var container = embeddedView[PARENT];
            return -1 === tNode.index ? isLContainer(container) ? container : null : container;
        }
        function getContainerRenderParent(tViewNode, view) {
            var container = getLContainer(tViewNode, view);
            return container ? nativeParentNode(view[RENDERER], container[NATIVE]) : null;
        }
        var projectionNodeStack = [];
        function walkTNodeTree(viewToWalk, action, renderer, renderParent, beforeNode) {
            for (var e_1, _a, rootTNode = viewToWalk[TVIEW].node, projectionNodeIndex = -1, currentView = viewToWalk, tNode = rootTNode.child; tNode; ) {
                var nextTNode = null;
                if (3 === tNode.type || 4 === tNode.type) {
                    executeNodeAction(action, renderer, renderParent, getNativeByTNode(tNode, currentView), tNode, beforeNode);
                    var nodeOrContainer = currentView[tNode.index];
                    isLContainer(nodeOrContainer) && (executeNodeAction(action, renderer, renderParent, nodeOrContainer[NATIVE], tNode, beforeNode), 
                    nodeOrContainer[VIEWS].length && (nextTNode = (currentView = nodeOrContainer[VIEWS][0])[TVIEW].node, 
                    beforeNode = nodeOrContainer[NATIVE]));
                } else if (0 === tNode.type) {
                    var lContainer = currentView[tNode.index];
                    executeNodeAction(action, renderer, renderParent, lContainer[NATIVE], tNode, beforeNode), 
                    lContainer[VIEWS].length && (nextTNode = (currentView = lContainer[VIEWS][0])[TVIEW].node, 
                    beforeNode = lContainer[NATIVE]);
                } else if (1 === tNode.type) {
                    var componentView = findComponentView(currentView), head = componentView[T_HOST].projection[tNode.projection];
                    if (Array.isArray(head)) try {
                        for (var head_1 = __values(head), head_1_1 = head_1.next(); !head_1_1.done; head_1_1 = head_1.next()) executeNodeAction(action, renderer, renderParent, head_1_1.value, tNode, beforeNode);
                    } catch (e_1_1) {
                        e_1 = {
                            error: e_1_1
                        };
                    } finally {
                        try {
                            head_1_1 && !head_1_1.done && (_a = head_1.return) && _a.call(head_1);
                        } finally {
                            if (e_1) throw e_1.error;
                        }
                    } else projectionNodeStack[++projectionNodeIndex] = tNode, projectionNodeStack[++projectionNodeIndex] = currentView, 
                    head && (nextTNode = (currentView = componentView[PARENT])[TVIEW].data[head.index]);
                } else nextTNode = tNode.child;
                if (null === nextTNode) for (null === tNode.projectionNext && 2 & tNode.flags && (currentView = projectionNodeStack[projectionNodeIndex--], 
                tNode = projectionNodeStack[projectionNodeIndex--]), nextTNode = 2 & tNode.flags ? tNode.projectionNext : 4 === tNode.type && tNode.child || tNode.next; !nextTNode; ) {
                    if (null === (tNode = tNode.parent || currentView[T_HOST]) || tNode === rootTNode) return;
                    if (0 === tNode.type && (beforeNode = (currentView = getLViewParent(currentView))[tNode.index][NATIVE]), 
                    2 === tNode.type) {
                        for (;!currentView[NEXT] && currentView[PARENT] && (!tNode.parent || !tNode.parent.next); ) {
                            if (tNode === rootTNode) return;
                            if (isLContainer(currentView = currentView[PARENT])) {
                                tNode = currentView[T_HOST], beforeNode = (currentView = currentView[PARENT])[tNode.index][NATIVE];
                                break;
                            }
                            tNode = currentView[T_HOST];
                        }
                        nextTNode = currentView[NEXT] ? (currentView = currentView[NEXT])[T_HOST] : 4 === tNode.type && tNode.child || tNode.next;
                    } else nextTNode = tNode.next;
                }
                tNode = nextTNode;
            }
        }
        function executeNodeAction(action, renderer, parent, node, tNode, beforeNode) {
            0 === action ? nativeInsertBefore(renderer, parent, node, beforeNode || null) : 1 === action ? function(renderer, rNode, isHostElement) {
                var nativeParent = nativeParentNode(renderer, rNode);
                nativeParent && function(renderer, parent, child, isHostElement) {
                    isProceduralRenderer(renderer) ? renderer.removeChild(parent, child, isHostElement) : parent.removeChild(child);
                }(renderer, nativeParent, rNode, isHostElement);
            }(renderer, node, isComponent(tNode)) : 2 === action && renderer.destroyNode(node);
        }
        function addRemoveViewFromContainer(viewToWalk, insertMode, beforeNode) {
            var renderParent = getContainerRenderParent(viewToWalk[TVIEW].node, viewToWalk);
            renderParent && walkTNodeTree(viewToWalk, insertMode ? 0 : 1, viewToWalk[RENDERER], renderParent, beforeNode);
        }
        function insertView(lView, lContainer, index) {
            var views = lContainer[VIEWS];
            index > 0 && (views[index - 1][NEXT] = lView), index < views.length ? (lView[NEXT] = views[index], 
            views.splice(index, 0, lView)) : (views.push(lView), lView[NEXT] = null), lView[PARENT] = lContainer, 
            lView[QUERIES] && lView[QUERIES].insertView(index), lView[FLAGS] |= 128;
        }
        function detachView(lContainer, removeIndex) {
            var views = lContainer[VIEWS], viewToDetach = views[removeIndex];
            return removeIndex > 0 && (views[removeIndex - 1][NEXT] = viewToDetach[NEXT]), views.splice(removeIndex, 1), 
            addRemoveViewFromContainer(viewToDetach, !1), 128 & viewToDetach[FLAGS] && !(256 & viewToDetach[FLAGS]) && viewToDetach[QUERIES] && viewToDetach[QUERIES].removeView(), 
            viewToDetach[PARENT] = null, viewToDetach[NEXT] = null, viewToDetach[FLAGS] &= -129, 
            viewToDetach;
        }
        function destroyLView(view) {
            if (!(256 & view[FLAGS])) {
                var renderer = view[RENDERER];
                isProceduralRenderer(renderer) && renderer.destroyNode && walkTNodeTree(view, 2, renderer, null), 
                function(rootView) {
                    var lViewOrLContainer = rootView[CHILD_HEAD];
                    if (!lViewOrLContainer) return cleanUpView(rootView);
                    for (;lViewOrLContainer; ) {
                        var next = null;
                        if (isLView(lViewOrLContainer)) next = lViewOrLContainer[CHILD_HEAD]; else {
                            var views = lViewOrLContainer[VIEWS];
                            views.length > 0 && (next = views[0]);
                        }
                        if (!next) {
                            for (;lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView; ) cleanUpView(lViewOrLContainer), 
                            lViewOrLContainer = getParentState(lViewOrLContainer, rootView);
                            cleanUpView(lViewOrLContainer || rootView), next = lViewOrLContainer && lViewOrLContainer[NEXT];
                        }
                        lViewOrLContainer = next;
                    }
                }(view);
            }
        }
        function getParentState(lViewOrLContainer, rootView) {
            var tNode;
            return isLView(lViewOrLContainer) && (tNode = lViewOrLContainer[T_HOST]) && 2 === tNode.type ? getLContainer(tNode, lViewOrLContainer) : lViewOrLContainer[PARENT] === rootView ? null : lViewOrLContainer[PARENT];
        }
        function cleanUpView(view) {
            if (isLView(view) && !(256 & view[FLAGS])) {
                view[FLAGS] &= -129, view[FLAGS] |= 256, function(view) {
                    var destroyHooks, tView = view[TVIEW];
                    if (null != tView && null != (destroyHooks = tView.destroyHooks)) for (var i = 0; i < destroyHooks.length; i += 2) {
                        var context = view[destroyHooks[i]];
                        context instanceof NodeInjectorFactory || destroyHooks[i + 1].call(context);
                    }
                }(view), function(lView) {
                    var tCleanup = lView[TVIEW].cleanup;
                    if (null != tCleanup) {
                        for (var lCleanup = lView[CLEANUP], i = 0; i < tCleanup.length - 1; i += 2) if ("string" == typeof tCleanup[i]) {
                            var idxOrTargetGetter = tCleanup[i + 1], target = "function" == typeof idxOrTargetGetter ? idxOrTargetGetter(lView) : unwrapRNode(lView[idxOrTargetGetter]), useCaptureOrSubIdx = tCleanup[i + 3];
                            "boolean" == typeof useCaptureOrSubIdx ? target.removeEventListener(tCleanup[i], lCleanup[tCleanup[i + 2]], useCaptureOrSubIdx) : useCaptureOrSubIdx >= 0 ? lCleanup[useCaptureOrSubIdx]() : lCleanup[-useCaptureOrSubIdx].unsubscribe(), 
                            i += 2;
                        } else "number" == typeof tCleanup[i] ? (0, lCleanup[tCleanup[i]])() : tCleanup[i].call(lCleanup[tCleanup[i + 1]]);
                        lView[CLEANUP] = null;
                    }
                }(view);
                var hostTNode = view[T_HOST];
                hostTNode && 3 === hostTNode.type && isProceduralRenderer(view[RENDERER]) && view[RENDERER].destroy(), 
                viewAttachedToContainer(view) && view[QUERIES] && view[QUERIES].removeView();
            }
        }
        function nativeInsertBefore(renderer, parent, child, beforeNode) {
            isProceduralRenderer(renderer) ? renderer.insertBefore(parent, child, beforeNode) : parent.insertBefore(child, beforeNode, !0);
        }
        function nativeAppendOrInsertBefore(renderer, parent, child, beforeNode) {
            beforeNode ? nativeInsertBefore(renderer, parent, child, beforeNode) : function(renderer, parent, child) {
                isProceduralRenderer(renderer) ? renderer.appendChild(parent, child) : parent.appendChild(child);
            }(renderer, parent, child);
        }
        function nativeParentNode(renderer, node) {
            return isProceduralRenderer(renderer) ? renderer.parentNode(node) : node.parentNode;
        }
        function appendChild(childEl, childTNode, currentView) {
            var e_2, _a, renderParent = function(tNode, currentView) {
                if (isRootView(currentView)) return nativeParentNode(currentView[RENDERER], getNativeByTNode(tNode, currentView));
                var parent = function(tNode) {
                    for (;null != tNode.parent && (4 === tNode.parent.type || 5 === tNode.parent.type); ) tNode = tNode.parent;
                    return tNode;
                }(tNode).parent;
                if (null == parent) {
                    var hostTNode = currentView[T_HOST];
                    return 2 === hostTNode.type ? getContainerRenderParent(hostTNode, currentView) : function(currentView) {
                        var hostTNode = currentView[T_HOST];
                        return hostTNode && 3 === hostTNode.type ? getNativeByTNode(hostTNode, getLViewParent(currentView)) : null;
                    }(currentView);
                }
                if (1 & parent.flags) {
                    var tData = currentView[TVIEW].data, encapsulation = tData[tData[parent.index].directiveStart].encapsulation;
                    if (encapsulation !== ViewEncapsulation.ShadowDom && encapsulation !== ViewEncapsulation.Native) return null;
                }
                return getNativeByTNode(parent, currentView);
            }(childTNode, currentView);
            if (null != renderParent) {
                var renderer = currentView[RENDERER], anchorNode = function(parentTNode, lView) {
                    if (2 === parentTNode.type) {
                        var lContainer = getLContainer(parentTNode, lView), views = lContainer[VIEWS];
                        return getBeforeNodeForView(views.indexOf(lView), views, lContainer[NATIVE]);
                    }
                    return 4 === parentTNode.type || 5 === parentTNode.type ? getNativeByTNode(parentTNode, lView) : null;
                }(childTNode.parent || currentView[T_HOST], currentView);
                if (Array.isArray(childEl)) try {
                    for (var childEl_1 = __values(childEl), childEl_1_1 = childEl_1.next(); !childEl_1_1.done; childEl_1_1 = childEl_1.next()) nativeAppendOrInsertBefore(renderer, renderParent, childEl_1_1.value, anchorNode);
                } catch (e_2_1) {
                    e_2 = {
                        error: e_2_1
                    };
                } finally {
                    try {
                        childEl_1_1 && !childEl_1_1.done && (_a = childEl_1.return) && _a.call(childEl_1);
                    } finally {
                        if (e_2) throw e_2.error;
                    }
                } else nativeAppendOrInsertBefore(renderer, renderParent, childEl, anchorNode);
            }
        }
        function getBeforeNodeForView(index, views, containerNative) {
            if (index + 1 < views.length) {
                var view = views[index + 1], viewTNode = view[T_HOST];
                return viewTNode.child ? getNativeByTNode(viewTNode.child, view) : containerNative;
            }
            return containerNative;
        }
        function appendProjectedNode(projectedTNode, tProjectionNode, currentView, projectionView) {
            var native = getNativeByTNode(projectedTNode, projectionView);
            appendChild(native, tProjectionNode, currentView), attachPatchData(native, projectionView);
            var nodeOrContainer = projectionView[projectedTNode.index];
            if (0 === projectedTNode.type) for (var views = nodeOrContainer[VIEWS], i = 0; i < views.length; i++) addRemoveViewFromContainer(views[i], !0, nodeOrContainer[NATIVE]); else {
                if (4 === projectedTNode.type) for (var ngContainerChildTNode = projectedTNode.child; ngContainerChildTNode; ) appendProjectedNode(ngContainerChildTNode, tProjectionNode, currentView, projectionView), 
                ngContainerChildTNode = ngContainerChildTNode.next;
                isLContainer(nodeOrContainer) && appendChild(nodeOrContainer[NATIVE], tProjectionNode, currentView);
            }
        }
        function template(index, templateFn, consts, vars, tagName, attrs, localRefs, localRefExtractor) {
            var lView = getLView(), tView = lView[TVIEW], tContainerNode = function(index, tagName, attrs) {
                var lView = getLView(), adjustedIndex = index + HEADER_OFFSET, comment = lView[RENDERER].createComment(""), tNode = createNodeAtIndex(index, 0, comment, tagName, attrs), lContainer = lView[adjustedIndex] = createLContainer(lView[adjustedIndex], lView, comment, tNode);
                return appendChild(comment, tNode, lView), addToViewTree(lView, lContainer), tNode;
            }(index, tagName || null, attrs || null);
            tView.firstTemplatePass && (tContainerNode.tViews = createTView(-1, templateFn, consts, vars, tView.directiveRegistry, tView.pipeRegistry, null, null)), 
            createDirectivesAndLocals(tView, lView, localRefs, localRefExtractor), function(lView, tContainerNode) {
                var queries = lView[QUERIES];
                queries && (queries.addNode(tContainerNode), lView[tContainerNode.index][QUERIES] = queries.container());
            }(lView, tContainerNode), attachPatchData(getNativeByTNode(tContainerNode, lView), lView), 
            registerPostOrderHooks(tView, tContainerNode), setIsParent(!1);
        }
        function store(index, value) {
            var lView = getLView(), tView = lView[TVIEW], adjustedIndex = index + HEADER_OFFSET;
            adjustedIndex >= tView.data.length && (tView.data[adjustedIndex] = null, tView.blueprint[adjustedIndex] = null), 
            lView[adjustedIndex] = value;
        }
        function reference(index) {
            return loadInternal(contextLView, index);
        }
        function load(index) {
            return loadInternal(getLView(), index);
        }
        function directiveInject(token, flags) {
            return void 0 === flags && (flags = InjectFlags.Default), token = resolveForwardRef(token), 
            getOrCreateInjectable(getPreviousOrParentTNode(), getLView(), token, flags);
        }
        var BRAND = "__SANITIZER_TRUSTED_BRAND__", _devMode = !0, _runModeLocked = !1;
        function isDevMode() {
            return _runModeLocked = !0, _devMode;
        }
        var InertBodyHelper = function() {
            function InertBodyHelper(defaultDoc) {
                if (this.defaultDoc = defaultDoc, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"), 
                this.inertBodyElement = this.inertDocument.body, null == this.inertBodyElement) {
                    var inertHtml = this.inertDocument.createElement("html");
                    this.inertDocument.appendChild(inertHtml), this.inertBodyElement = this.inertDocument.createElement("body"), 
                    inertHtml.appendChild(this.inertBodyElement);
                }
                this.inertBodyElement.innerHTML = '<svg><g onload="this.parentNode.remove()"></g></svg>', 
                !this.inertBodyElement.querySelector || this.inertBodyElement.querySelector("svg") ? (this.inertBodyElement.innerHTML = '<svg><p><style><img src="</style><img src=x onerror=alert(1)//">', 
                this.getInertBodyElement = this.inertBodyElement.querySelector && this.inertBodyElement.querySelector("svg img") && function() {
                    try {
                        return !!window.DOMParser;
                    } catch (_a) {
                        return !1;
                    }
                }() ? this.getInertBodyElement_DOMParser : this.getInertBodyElement_InertDocument) : this.getInertBodyElement = this.getInertBodyElement_XHR;
            }
            return InertBodyHelper.prototype.getInertBodyElement_XHR = function(html) {
                html = "<body><remove></remove>" + html + "</body>";
                try {
                    html = encodeURI(html);
                } catch (_a) {
                    return null;
                }
                var xhr = new XMLHttpRequest();
                xhr.responseType = "document", xhr.open("GET", "data:text/html;charset=utf-8," + html, !1), 
                xhr.send(void 0);
                var body = xhr.response.body;
                return body.removeChild(body.firstChild), body;
            }, InertBodyHelper.prototype.getInertBodyElement_DOMParser = function(html) {
                html = "<body><remove></remove>" + html + "</body>";
                try {
                    var body = new window.DOMParser().parseFromString(html, "text/html").body;
                    return body.removeChild(body.firstChild), body;
                } catch (_a) {
                    return null;
                }
            }, InertBodyHelper.prototype.getInertBodyElement_InertDocument = function(html) {
                var templateEl = this.inertDocument.createElement("template");
                return "content" in templateEl ? (templateEl.innerHTML = html, templateEl) : (this.inertBodyElement.innerHTML = html, 
                this.defaultDoc.documentMode && this.stripCustomNsAttrs(this.inertBodyElement), 
                this.inertBodyElement);
            }, InertBodyHelper.prototype.stripCustomNsAttrs = function(el) {
                for (var elAttrs = el.attributes, i = elAttrs.length - 1; 0 < i; i--) {
                    var attrName = elAttrs.item(i).name;
                    "xmlns:ns1" !== attrName && 0 !== attrName.indexOf("ns1:") || el.removeAttribute(attrName);
                }
                for (var childNode = el.firstChild; childNode; ) childNode.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(childNode), 
                childNode = childNode.nextSibling;
            }, InertBodyHelper;
        }(), SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:\/?#]*(?:[\/?#]|$))/gi, DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;
        function _sanitizeUrl(url) {
            return (url = String(url)).match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN) ? url : (isDevMode() && console.warn("WARNING: sanitizing unsafe URL value " + url + " (see http://g.co/ng/security#xss)"), 
            "unsafe:" + url);
        }
        function tagSet(tags) {
            var e_1, _a, res = {};
            try {
                for (var _b = __values(tags.split(",")), _c = _b.next(); !_c.done; _c = _b.next()) res[_c.value] = !0;
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally {
                try {
                    _c && !_c.done && (_a = _b.return) && _a.call(_b);
                } finally {
                    if (e_1) throw e_1.error;
                }
            }
            return res;
        }
        function core_merge() {
            for (var e_2, _a, sets = [], _i = 0; _i < arguments.length; _i++) sets[_i] = arguments[_i];
            var res = {};
            try {
                for (var sets_1 = __values(sets), sets_1_1 = sets_1.next(); !sets_1_1.done; sets_1_1 = sets_1.next()) {
                    var s = sets_1_1.value;
                    for (var v in s) s.hasOwnProperty(v) && (res[v] = !0);
                }
            } catch (e_2_1) {
                e_2 = {
                    error: e_2_1
                };
            } finally {
                try {
                    sets_1_1 && !sets_1_1.done && (_a = sets_1.return) && _a.call(sets_1);
                } finally {
                    if (e_2) throw e_2.error;
                }
            }
            return res;
        }
        var inertBodyHelper, VOID_ELEMENTS = tagSet("area,br,col,hr,img,wbr"), OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet("rp,rt"), OPTIONAL_END_TAG_ELEMENTS = core_merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS), VALID_ELEMENTS = core_merge(VOID_ELEMENTS, core_merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), core_merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), OPTIONAL_END_TAG_ELEMENTS), URI_ATTRS = tagSet("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), SRCSET_ATTRS = tagSet("srcset"), VALID_ATTRS = core_merge(URI_ATTRS, SRCSET_ATTRS, tagSet("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width")), SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet("script,style,template"), SanitizingHtmlSerializer = function() {
            function SanitizingHtmlSerializer() {
                this.sanitizedSomething = !1, this.buf = [];
            }
            return SanitizingHtmlSerializer.prototype.sanitizeChildren = function(el) {
                for (var current = el.firstChild, traverseContent = !0; current; ) if (current.nodeType === Node.ELEMENT_NODE ? traverseContent = this.startElement(current) : current.nodeType === Node.TEXT_NODE ? this.chars(current.nodeValue) : this.sanitizedSomething = !0, 
                traverseContent && current.firstChild) current = current.firstChild; else for (;current; ) {
                    current.nodeType === Node.ELEMENT_NODE && this.endElement(current);
                    var next = this.checkClobberedElement(current, current.nextSibling);
                    if (next) {
                        current = next;
                        break;
                    }
                    current = this.checkClobberedElement(current, current.parentNode);
                }
                return this.buf.join("");
            }, SanitizingHtmlSerializer.prototype.startElement = function(element) {
                var srcset, tagName = element.nodeName.toLowerCase();
                if (!VALID_ELEMENTS.hasOwnProperty(tagName)) return this.sanitizedSomething = !0, 
                !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);
                this.buf.push("<"), this.buf.push(tagName);
                for (var elAttrs = element.attributes, i = 0; i < elAttrs.length; i++) {
                    var elAttr = elAttrs.item(i), attrName = elAttr.name, lower = attrName.toLowerCase();
                    if (VALID_ATTRS.hasOwnProperty(lower)) {
                        var value = elAttr.value;
                        URI_ATTRS[lower] && (value = _sanitizeUrl(value)), SRCSET_ATTRS[lower] && (srcset = value, 
                        value = (srcset = String(srcset)).split(",").map(function(srcset) {
                            return _sanitizeUrl(srcset.trim());
                        }).join(", ")), this.buf.push(" ", attrName, '="', encodeEntities(value), '"');
                    } else this.sanitizedSomething = !0;
                }
                return this.buf.push(">"), !0;
            }, SanitizingHtmlSerializer.prototype.endElement = function(current) {
                var tagName = current.nodeName.toLowerCase();
                VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName) && (this.buf.push("</"), 
                this.buf.push(tagName), this.buf.push(">"));
            }, SanitizingHtmlSerializer.prototype.chars = function(chars) {
                this.buf.push(encodeEntities(chars));
            }, SanitizingHtmlSerializer.prototype.checkClobberedElement = function(node, nextNode) {
                if (nextNode && (node.compareDocumentPosition(nextNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error("Failed to sanitize html because the element is clobbered: " + node.outerHTML);
                return nextNode;
            }, SanitizingHtmlSerializer;
        }(), SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
        function encodeEntities(value) {
            return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(match) {
                return "&#" + (1024 * (match.charCodeAt(0) - 55296) + (match.charCodeAt(1) - 56320) + 65536) + ";";
            }).replace(NON_ALPHANUMERIC_REGEXP, function(match) {
                return "&#" + match.charCodeAt(0) + ";";
            }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }
        function getTemplateContent(el) {
            return "content" in el && function(el) {
                return el.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === el.nodeName;
            }(el) ? el.content : null;
        }
        var SecurityContext = function(SecurityContext) {
            return SecurityContext[SecurityContext.NONE = 0] = "NONE", SecurityContext[SecurityContext.HTML = 1] = "HTML", 
            SecurityContext[SecurityContext.STYLE = 2] = "STYLE", SecurityContext[SecurityContext.SCRIPT = 3] = "SCRIPT", 
            SecurityContext[SecurityContext.URL = 4] = "URL", SecurityContext[SecurityContext.RESOURCE_URL = 5] = "RESOURCE_URL", 
            SecurityContext;
        }({}), Sanitizer = function() {
            return function() {};
        }(), SAFE_STYLE_VALUE = new RegExp("^([-,.\"'%_!# a-zA-Z0-9]+|(?:(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|3d)?|(?:rgb|hsl)a?|(?:repeating-)?(?:linear|radial)-gradient|(?:calc|attr))\\([-0-9.%, #a-zA-Z]+\\))$", "g"), URL_RE = /^url\(([^)]+)\)$/;
        function sanitizeUrl(unsafeUrl) {
            var lView, value, sanitizer = (lView = getLView()) && lView[SANITIZER];
            return sanitizer ? sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || "" : ("Url", 
            (value = unsafeUrl) instanceof String && "Url" === value[BRAND] ? unsafeUrl.toString() : _sanitizeUrl(renderStringify(unsafeUrl)));
        }
        function elementStart(index, name, attrs, localRefs) {
            var lView = getLView(), tView = lView[TVIEW], native = elementCreate(name), renderer = lView[RENDERER], tNode = createNodeAtIndex(index, 3, native, name, attrs || null), initialStylesIndex = 0, initialClassesIndex = 0;
            if (attrs && (function(tView, tNode, attrs, attrsStartIndex) {
                if (tView.firstTemplatePass && !tNode.stylingTemplate) {
                    var stylingAttrsStartIndex = attrsStylingIndexOf(attrs, attrsStartIndex);
                    stylingAttrsStartIndex >= 0 && (tNode.stylingTemplate = initializeStaticContext(attrs, stylingAttrsStartIndex));
                }
            }(tView, tNode, attrs, setUpAttributes(native, attrs)), tNode.stylingTemplate && (initialStylesIndex = renderInitialStyles(native, tNode.stylingTemplate, renderer), 
            initialClassesIndex = renderInitialClasses(native, tNode.stylingTemplate, renderer))), 
            appendChild(native, tNode, lView), createDirectivesAndLocals(tView, lView, localRefs), 
            0 === elementDepthCount && attachPatchData(native, lView), elementDepthCount++, 
            tView.firstTemplatePass) {
                var inputData = initializeTNodeInputs(tNode);
                inputData && inputData.hasOwnProperty("class") && (tNode.flags |= 8), inputData && inputData.hasOwnProperty("style") && (tNode.flags |= 16);
            }
            tNode.stylingTemplate && (renderInitialClasses(native, tNode.stylingTemplate, renderer, initialClassesIndex), 
            renderInitialStyles(native, tNode.stylingTemplate, renderer, initialStylesIndex));
            var currentQueries = lView[QUERIES];
            currentQueries && (currentQueries.addNode(tNode), lView[QUERIES] = currentQueries.clone()), 
            function(tView, tNode, lView) {
                if (function(tNode) {
                    return 0 != (4 & tNode.flags);
                }(tNode)) for (var end = tNode.directiveEnd, directiveIndex = tNode.directiveStart; directiveIndex < end; directiveIndex++) {
                    var def = tView.data[directiveIndex];
                    def.contentQueries && def.contentQueries(1, lView[directiveIndex], directiveIndex);
                }
            }(tView, tNode, lView);
        }
        function elementEnd() {
            var previousOrParentTNode = getPreviousOrParentTNode();
            getIsParent() ? setIsParent(!1) : setPreviousOrParentTNode(previousOrParentTNode = previousOrParentTNode.parent), 
            previousOrParentTNode.onElementCreationFns && applyOnCreateInstructions(previousOrParentTNode);
            var lView = getLView(), currentQueries = lView[QUERIES];
            if (currentQueries && (lView[QUERIES] = currentQueries.parent), registerPostOrderHooks(getLView()[TVIEW], previousOrParentTNode), 
            elementDepthCount--, hasClassInput(previousOrParentTNode)) {
                var stylingContext = getStylingContext(previousOrParentTNode.index, lView);
                setInputsForProperty(lView, previousOrParentTNode.inputs.class, getInitialClassNameValue(stylingContext));
            }
            hasStyleInput(previousOrParentTNode) && (stylingContext = getStylingContext(previousOrParentTNode.index, lView), 
            setInputsForProperty(lView, previousOrParentTNode.inputs.style, function(context) {
                var initialStyleValues = stylingContext[3], styleString = initialStyleValues[1];
                if (null === styleString) {
                    styleString = "";
                    for (var i = 2; i < initialStyleValues.length; i += 3) {
                        var value = initialStyleValues[i + 1];
                        null !== value && (styleString += (styleString.length ? ";" : "") + initialStyleValues[i] + ":" + value);
                    }
                    initialStyleValues[1] = styleString;
                }
                return styleString;
            }()));
        }
        function core_element(index, name, attrs, localRefs) {
            elementStart(index, name, attrs, localRefs), elementEnd();
        }
        function elementAttribute(index, name, value, sanitizer, namespace) {
            if (value !== NO_CHANGE) {
                var lView = getLView(), renderer = lView[RENDERER], element_1 = getNativeByIndex(index, lView);
                if (null == value) isProceduralRenderer(renderer) ? renderer.removeAttribute(element_1, name, namespace) : element_1.removeAttribute(name); else {
                    var tNode = getTNode(index, lView), strValue = null == sanitizer ? renderStringify(value) : sanitizer(value, tNode.tagName || "", name);
                    isProceduralRenderer(renderer) ? renderer.setAttribute(element_1, name, strValue, namespace) : namespace ? element_1.setAttributeNS(namespace, name, strValue) : element_1.setAttribute(name, strValue);
                }
            }
        }
        function elementHostAttrs(attrs) {
            var tNode = getPreviousOrParentTNode(), stylingAttrsStartIndex = attrsStylingIndexOf(attrs, setUpAttributes(getNativeByTNode(tNode, getLView()), attrs));
            if (stylingAttrsStartIndex >= 0) {
                var directive = getActiveHostContext();
                tNode.stylingTemplate ? patchContextWithStaticAttrs(tNode.stylingTemplate, attrs, stylingAttrsStartIndex, directive) : tNode.stylingTemplate = initializeStaticContext(attrs, stylingAttrsStartIndex, directive);
            }
        }
        function getCurrentView() {
            return getLView();
        }
        function core_isPromise(obj) {
            return !!obj && "function" == typeof obj.then;
        }
        function listener(eventName, listenerFn, useCapture, eventTargetResolver) {
            void 0 === useCapture && (useCapture = !1), listenerInternal(eventName, listenerFn, useCapture, eventTargetResolver);
        }
        function componentHostSyntheticListener(eventName, listenerFn, useCapture, eventTargetResolver) {
            void 0 === useCapture && (useCapture = !1), listenerInternal(eventName, listenerFn, useCapture, eventTargetResolver, loadComponentRenderer);
        }
        function listenerInternal(eventName, listenerFn, useCapture, eventTargetResolver, loadRendererFn) {
            void 0 === useCapture && (useCapture = !1);
            var lView = getLView(), tNode = getPreviousOrParentTNode(), tView = lView[TVIEW], tCleanup = tView.firstTemplatePass && (tView.cleanup || (tView.cleanup = []));
            if (3 === tNode.type) {
                var native = getNativeByTNode(tNode, lView), resolved = eventTargetResolver ? eventTargetResolver(native) : {}, target = resolved.target || native, renderer = loadRendererFn ? loadRendererFn(tNode, lView) : lView[RENDERER], lCleanupIndex = (lCleanup = getCleanup(lView)).length, useCaptureOrSubIdx = useCapture;
                if (isProceduralRenderer(renderer)) {
                    listenerFn = wrapListener(tNode, lView, listenerFn, !1);
                    var cleanupFn = renderer.listen(resolved.name || target, eventName, listenerFn);
                    lCleanup.push(listenerFn, cleanupFn), useCaptureOrSubIdx = lCleanupIndex + 1;
                } else listenerFn = wrapListener(tNode, lView, listenerFn, !0), target.addEventListener(eventName, listenerFn, useCapture), 
                lCleanup.push(listenerFn);
                tCleanup && tCleanup.push(eventName, eventTargetResolver ? function(_lView) {
                    return eventTargetResolver(unwrapRNode(_lView[tNode.index])).target;
                } : tNode.index, lCleanupIndex, useCaptureOrSubIdx);
            }
            void 0 === tNode.outputs && (tNode.outputs = generatePropertyAliases(tNode, 1));
            var props, outputs = tNode.outputs;
            if (outputs && (props = outputs[eventName])) {
                var propsLength = props.length;
                if (propsLength) for (var lCleanup = getCleanup(lView), i = 0; i < propsLength; i += 3) {
                    var subscription = lView[props[i]][props[i + 2]].subscribe(listenerFn), idx = lCleanup.length;
                    lCleanup.push(listenerFn, subscription), tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));
                }
            }
        }
        function wrapListener(tNode, lView, listenerFn, wrapWithPreventDefault) {
            return function(e) {
                var startView = 1 & tNode.flags ? getComponentViewByIndex(tNode.index, lView) : lView;
                0 == (32 & lView[FLAGS]) && markViewDirty(startView);
                try {
                    var result = listenerFn(e);
                    return wrapWithPreventDefault && !1 === result && (e.preventDefault(), e.returnValue = !1), 
                    result;
                } catch (error) {
                    handleError(lView, error);
                }
            };
        }
        function nextContext(level) {
            return void 0 === level && (level = 1), function(level) {
                return void 0 === level && (level = 1), (contextLView = function(nestingLevel, currentView) {
                    for (;nestingLevel > 0; ) currentView = currentView[DECLARATION_VIEW], nestingLevel--;
                    return currentView;
                }(level, contextLView))[CONTEXT];
            }(level);
        }
        function projectionDef(selectors, textSelectors) {
            var componentNode = findComponentView(getLView())[T_HOST];
            if (!componentNode.projection) for (var projectionHeads = componentNode.projection = new Array(selectors ? selectors.length + 1 : 1).fill(null), tails = projectionHeads.slice(), componentChild = componentNode.child; null !== componentChild; ) {
                var bucketIndex = selectors ? matchingProjectionSelectorIndex(componentChild, selectors, textSelectors) : 0;
                tails[bucketIndex] ? tails[bucketIndex].projectionNext = componentChild : projectionHeads[bucketIndex] = componentChild, 
                tails[bucketIndex] = componentChild, componentChild = componentChild.next;
            }
        }
        function projection(nodeIndex, selectorIndex, attrs) {
            void 0 === selectorIndex && (selectorIndex = 0);
            var lView = getLView(), tProjectionNode = createNodeAtIndex(nodeIndex, 1, null, null, attrs || null);
            null === tProjectionNode.projection && (tProjectionNode.projection = selectorIndex), 
            setIsParent(!1), function appendProjectedNodes(lView, tProjectionNode, selectorIndex, componentView) {
                var projectedView = componentView[PARENT], nodeToProject = componentView[T_HOST].projection[selectorIndex];
                if (Array.isArray(nodeToProject)) appendChild(nodeToProject, tProjectionNode, lView); else for (;nodeToProject; ) 1 === nodeToProject.type ? appendProjectedNodes(lView, tProjectionNode, nodeToProject.projection, findComponentView(projectedView)) : (nodeToProject.flags |= 2, 
                appendProjectedNode(nodeToProject, tProjectionNode, lView, projectedView)), nodeToProject = nodeToProject.projectionNext;
            }(lView, tProjectionNode, selectorIndex, findComponentView(lView));
        }
        var _symbolIterator = null;
        function core_getSymbolIterator() {
            if (!_symbolIterator) {
                var Symbol_1 = _global.Symbol;
                if (Symbol_1 && Symbol_1.iterator) _symbolIterator = Symbol_1.iterator; else for (var keys = Object.getOwnPropertyNames(Map.prototype), i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    "entries" !== key && "size" !== key && Map.prototype[key] === Map.prototype.entries && (_symbolIterator = key);
                }
            }
            return _symbolIterator;
        }
        function looseIdentical(a, b) {
            return a === b || "number" == typeof a && "number" == typeof b && isNaN(a) && isNaN(b);
        }
        var WrappedValue = function() {
            function WrappedValue(value) {
                this.wrapped = value;
            }
            return WrappedValue.wrap = function(value) {
                return new WrappedValue(value);
            }, WrappedValue.unwrap = function(value) {
                return WrappedValue.isWrapped(value) ? value.wrapped : value;
            }, WrappedValue.isWrapped = function(value) {
                return value instanceof WrappedValue;
            }, WrappedValue;
        }();
        function isListLikeIterable(obj) {
            return !!isJsObject(obj) && (Array.isArray(obj) || !(obj instanceof Map) && core_getSymbolIterator() in obj);
        }
        function isJsObject(o) {
            return null !== o && ("function" == typeof o || "object" == typeof o);
        }
        function bindingUpdated(lView, bindingIndex, value) {
            var a, b;
            return b = value, ((a = lView[bindingIndex]) == a || b == b) && a !== b && (lView[bindingIndex] = value, 
            !0);
        }
        function bind(value) {
            var lView = getLView(), bindingIndex = lView[BINDING_INDEX]++;
            return storeBindingMetadata(lView), bindingUpdated(lView, bindingIndex, value) ? value : NO_CHANGE;
        }
        function elementProperty(index, propName, value, sanitizer, nativeOnly) {
            elementPropertyInternal(index, propName, value, sanitizer, nativeOnly);
        }
        function componentHostSyntheticProperty(index, propName, value, sanitizer, nativeOnly) {
            elementPropertyInternal(index, propName, value, sanitizer, nativeOnly, loadComponentRenderer);
        }
        var ATTR_TO_PROP = {
            class: "className",
            for: "htmlFor",
            formaction: "formAction",
            innerHtml: "innerHTML",
            readonly: "readOnly",
            tabindex: "tabIndex"
        };
        function elementPropertyInternal(index, propName, value, sanitizer, nativeOnly, loadRendererFn) {
            if (value !== NO_CHANGE) {
                var inputData, dataValue, lView = getLView(), element = getNativeByIndex(index, lView), tNode = getTNode(index, lView);
                if (!nativeOnly && (inputData = initializeTNodeInputs(tNode)) && (dataValue = inputData[propName])) setInputsForProperty(lView, dataValue, value), 
                isComponent(tNode) && function(lView, viewIndex) {
                    var childComponentLView = getComponentViewByIndex(index + HEADER_OFFSET, lView);
                    16 & childComponentLView[FLAGS] || (childComponentLView[FLAGS] |= 64);
                }(lView); else if (3 === tNode.type) {
                    !function(tNode, lView, propName, tData, nativeOnly) {
                        var lastBindingIndex = lView[BINDING_INDEX] - 1, bindingMetadata = tData[lastBindingIndex];
                        bindingMetadata[0] == INTERPOLATION_DELIMITER && (tData[lastBindingIndex] = propName + bindingMetadata, 
                        nativeOnly || (-1 == tNode.propertyMetadataStartIndex && (tNode.propertyMetadataStartIndex = lastBindingIndex), 
                        tNode.propertyMetadataEndIndex = lastBindingIndex + 1));
                    }(tNode, lView, propName = ATTR_TO_PROP[propName] || propName, lView[TVIEW].data, nativeOnly);
                    var renderer = loadRendererFn ? loadRendererFn(tNode, lView) : lView[RENDERER];
                    value = null != sanitizer ? sanitizer(value, tNode.tagName || "", propName) : value, 
                    isProceduralRenderer(renderer) ? renderer.setProperty(element, propName, value) : isAnimationProp(propName) || (element.setProperty ? element.setProperty(propName, value) : element[propName] = value);
                }
            }
        }
        function interpolation1(prefix, v0, suffix) {
            var lView = getLView(), different = bindingUpdated(lView, lView[BINDING_INDEX]++, v0);
            return storeBindingMetadata(lView, prefix, suffix), different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;
        }
        function core_select(index) {
            var lView = getLView();
            executePreOrderHooks(lView, lView[TVIEW], getCheckNoChangesMode(), index);
        }
        function elementStyling(classBindingNames, styleBindingNames, styleSanitizer) {
            var tNode = getPreviousOrParentTNode();
            tNode.stylingTemplate || (tNode.stylingTemplate = createEmptyStylingContext()), 
            initElementStyling(tNode, classBindingNames, styleBindingNames, styleSanitizer, null);
        }
        function elementHostStyling(classBindingNames, styleBindingNames, styleSanitizer) {
            var tNode = getPreviousOrParentTNode();
            tNode.stylingTemplate || (tNode.stylingTemplate = createEmptyStylingContext());
            var directive = getActiveHostContext();
            allocateDirectiveIntoContext(tNode.stylingTemplate, directive), (tNode.onElementCreationFns = tNode.onElementCreationFns || []).push(function() {
                return initElementStyling(tNode, classBindingNames, styleBindingNames, styleSanitizer, directive);
            });
        }
        function initElementStyling(tNode, classBindingNames, styleBindingNames, styleSanitizer, directive) {
            !function(context, directiveRef, classBindingNames, styleBindingNames, styleSanitizer) {
                if (!(16 & context[1])) {
                    var directiveIndex = function(context, directiveRef, styleSanitizer) {
                        var directiveIndex, directiveRefs = context[2], nextOffsetInsertionIndex = context[5].length, detectedIndex = getDirectiveRegistryValuesIndexOf(directiveRefs, directiveRef);
                        if (-1 === detectedIndex) detectedIndex = directiveRefs.length, directiveIndex = directiveRefs.length / 4, 
                        allocateDirectiveIntoContext(context, directiveRef), directiveRefs[detectedIndex + 1] = nextOffsetInsertionIndex, 
                        directiveRefs[detectedIndex + 3] = styleSanitizer || null; else {
                            if (directiveRefs[detectedIndex + 1] >= 0) return -1;
                            directiveIndex = detectedIndex / 4, directiveRefs[detectedIndex + 1] = nextOffsetInsertionIndex, 
                            directiveRefs[detectedIndex + 3] = styleSanitizer || null;
                        }
                        return directiveIndex;
                    }(context, directive || null, styleSanitizer);
                    if (-1 !== directiveIndex) {
                        styleBindingNames && (styleBindingNames = function(entries) {
                            for (var newEntries = [], i = 0; i < entries.length; i++) newEntries.push(hyphenate(entries[i]));
                            return newEntries;
                        }(styleBindingNames));
                        var singlePropOffsetValues = context[5], totalCurrentClassBindings = singlePropOffsetValues[1], totalCurrentStyleBindings = singlePropOffsetValues[0], cachedClassMapValues = context[6], cachedStyleMapValues = context[7], stylesOffset = 4 * totalCurrentStyleBindings, singleClassesStartIndex = 9 + stylesOffset, multiStylesStartIndex = singleClassesStartIndex + 4 * totalCurrentClassBindings, multiClassesStartIndex = multiStylesStartIndex + stylesOffset, currentSinglePropsLength = singlePropOffsetValues.length;
                        singlePropOffsetValues.push(styleBindingNames ? styleBindingNames.length : 0, classBindingNames ? classBindingNames.length : 0);
                        var insertionOffset = 0, filteredStyleBindingNames = [];
                        if (styleBindingNames && styleBindingNames.length) for (var i_1 = 0; i_1 < styleBindingNames.length; i_1++) {
                            var name_1 = styleBindingNames[i_1];
                            -1 == (singlePropIndex = getMatchingBindingIndex(context, name_1, 9, singleClassesStartIndex)) && (singlePropIndex = singleClassesStartIndex + insertionOffset, 
                            insertionOffset += 4, filteredStyleBindingNames.push(name_1)), singlePropOffsetValues.push(singlePropIndex);
                        }
                        var filteredClassBindingNames = [];
                        if (classBindingNames && classBindingNames.length) for (var i_2 = 0; i_2 < classBindingNames.length; i_2++) {
                            var singlePropIndex, name_2 = classBindingNames[i_2];
                            -1 == (singlePropIndex = getMatchingBindingIndex(context, name_2, singleClassesStartIndex, multiStylesStartIndex)) ? (singlePropIndex = multiStylesStartIndex + insertionOffset, 
                            insertionOffset += 4, filteredClassBindingNames.push(name_2)) : singlePropIndex += 4 * filteredStyleBindingNames.length, 
                            singlePropOffsetValues.push(singlePropIndex);
                        }
                        var i = 2;
                        if (filteredStyleBindingNames.length) for (;i < currentSinglePropsLength; ) {
                            var totalStyles = singlePropOffsetValues[i + 0], totalClasses = singlePropOffsetValues[i + 1];
                            if (totalClasses) for (var start = i + 2 + totalStyles, j = start; j < start + totalClasses; j++) singlePropOffsetValues[j] += 4 * filteredStyleBindingNames.length;
                            i += 2 + (totalStyles + totalClasses);
                        }
                        for (var totalNewEntries = filteredClassBindingNames.length + filteredStyleBindingNames.length, i_3 = 9; i_3 < context.length; i_3 += 4) {
                            var isMultiBased = i_3 >= multiStylesStartIndex, isClassBased = i_3 >= (isMultiBased ? multiClassesStartIndex : singleClassesStartIndex), flag = getPointers(context, i_3), staticIndex = getInitialIndex(flag), singleOrMultiIndex = getMultiOrSingleIndex(flag);
                            setFlag(context, i_3, pointers(flag, staticIndex, singleOrMultiIndex += isMultiBased ? isClassBased ? 4 * filteredStyleBindingNames.length : 0 : 4 * totalNewEntries + 4 * (isClassBased ? filteredStyleBindingNames.length : 0)));
                        }
                        for (var i_4 = 0; i_4 < 4 * filteredStyleBindingNames.length; i_4++) context.splice(multiClassesStartIndex, 0, null), 
                        context.splice(singleClassesStartIndex, 0, null), singleClassesStartIndex++, multiStylesStartIndex++, 
                        multiClassesStartIndex += 2;
                        for (var i_5 = 0; i_5 < 4 * filteredClassBindingNames.length; i_5++) context.splice(multiStylesStartIndex, 0, null), 
                        context.push(null), multiStylesStartIndex++, multiClassesStartIndex++;
                        for (var initialClasses = context[4], initialStyles = context[3], i_6 = 0; i_6 < totalNewEntries; i_6++) {
                            var entryIsClassBased = i_6 >= filteredStyleBindingNames.length, adjustedIndex = entryIsClassBased ? i_6 - filteredStyleBindingNames.length : i_6, propName = entryIsClassBased ? filteredClassBindingNames[adjustedIndex] : filteredStyleBindingNames[adjustedIndex], multiIndex = void 0, singleIndex = void 0;
                            entryIsClassBased ? (multiIndex = multiClassesStartIndex + 4 * (totalCurrentClassBindings + adjustedIndex), 
                            singleIndex = singleClassesStartIndex + 4 * (totalCurrentClassBindings + adjustedIndex)) : (multiIndex = multiStylesStartIndex + 4 * (totalCurrentStyleBindings + adjustedIndex), 
                            singleIndex = 9 + 4 * (totalCurrentStyleBindings + adjustedIndex));
                            var initialValuesToLookup = entryIsClassBased ? initialClasses : initialStyles, indexForInitial = getInitialStylingValuesIndexOf(initialValuesToLookup, propName);
                            -1 === indexForInitial ? indexForInitial = addOrUpdateStaticStyle(null, initialValuesToLookup, propName, !entryIsClassBased && null, directiveIndex) + 1 : indexForInitial += 1;
                            var initialFlag = prepareInitialFlag(context, propName, entryIsClassBased, styleSanitizer || null);
                            setFlag(context, singleIndex, pointers(initialFlag, indexForInitial, multiIndex)), 
                            setProp(context, singleIndex, propName), setValue(context, singleIndex, null), setPlayerBuilderIndex(context, singleIndex, 0, directiveIndex), 
                            setFlag(context, multiIndex, pointers(initialFlag, indexForInitial, singleIndex)), 
                            setProp(context, multiIndex, propName), setValue(context, multiIndex, null), setPlayerBuilderIndex(context, multiIndex, 0, directiveIndex);
                        }
                        singlePropOffsetValues[1] = totalCurrentClassBindings + filteredClassBindingNames.length, 
                        singlePropOffsetValues[0] = totalCurrentStyleBindings + filteredStyleBindingNames.length, 
                        cachedClassMapValues[0] += filteredClassBindingNames.length, cachedStyleMapValues[0] += filteredStyleBindingNames.length;
                        var newStylesSpaceAllocationSize = 4 * filteredStyleBindingNames.length, newClassesSpaceAllocationSize = 4 * filteredClassBindingNames.length, cachedStyleMapIndex = cachedStyleMapValues.length;
                        registerMultiMapEntry(context, directiveIndex, !1, multiStylesStartIndex + 4 * totalCurrentStyleBindings, filteredStyleBindingNames.length);
                        for (var i_7 = 1; i_7 < cachedStyleMapIndex; i_7 += 4) cachedStyleMapValues[i_7 + 1] += newClassesSpaceAllocationSize + newStylesSpaceAllocationSize;
                        var cachedClassMapIndex = cachedClassMapValues.length;
                        registerMultiMapEntry(context, directiveIndex, !0, multiClassesStartIndex + 4 * totalCurrentClassBindings, filteredClassBindingNames.length);
                        for (var i_8 = 1; i_8 < cachedClassMapIndex; i_8 += 4) cachedClassMapValues[i_8 + 1] += 2 * newStylesSpaceAllocationSize + newClassesSpaceAllocationSize;
                        setFlag(context, 1, pointers(0, 0, multiStylesStartIndex));
                    }
                }
            }(tNode.stylingTemplate, 0, classBindingNames, styleBindingNames, styleSanitizer);
        }
        function elementHostStyleProp(styleIndex, value, suffix, forceOverride) {
            elementStylePropInternal(getActiveHostContext(), getActiveHostElementIndex(), styleIndex, value, suffix, forceOverride);
        }
        function elementStylePropInternal(directive, index, styleIndex, value, suffix, forceOverride) {
            var valueToAdd = null;
            null !== value && (valueToAdd = suffix ? renderStringify(value) + suffix : value), 
            function(context, offset, input, directiveRef, forceOverride) {
                updateSingleStylingValue(context, styleIndex, valueToAdd, !1, directive, forceOverride);
            }(getStylingContext(index + HEADER_OFFSET, getLView()), 0, 0, 0, forceOverride);
        }
        function elementClassProp(index, classIndex, value, forceOverride) {
            elementClassPropInternal(null, index, classIndex, value, forceOverride);
        }
        function elementHostClassProp(classIndex, value, forceOverride) {
            elementClassPropInternal(getActiveHostContext(), getActiveHostElementIndex(), classIndex, value, forceOverride);
        }
        function elementClassPropInternal(directive, index, classIndex, value, forceOverride) {
            var input = value instanceof BoundPlayerFactory ? value : function(value) {
                return "boolean" == typeof value ? value : !!value || null;
            }(value);
            !function(context, offset, input, directiveRef, forceOverride) {
                updateSingleStylingValue(context, classIndex, input, !0, directive, forceOverride);
            }(getStylingContext(index + HEADER_OFFSET, getLView()), 0, input, 0, forceOverride);
        }
        function elementStylingMap(index, classes, styles) {
            elementStylingMapInternal(null, index, classes, styles);
        }
        function elementHostStylingMap(classes, styles) {
            elementStylingMapInternal(getActiveHostContext(), getActiveHostElementIndex(), classes, styles);
        }
        function elementStylingMapInternal(directive, index, classes, styles) {
            var lView = getLView(), tNode = getTNode(index, lView), stylingContext = getStylingContext(index + HEADER_OFFSET, lView);
            if (!directive) {
                if (hasClassInput(tNode) && classes !== NO_CHANGE) {
                    var initialClasses = getInitialClassNameValue(stylingContext), classInputVal = (initialClasses.length ? initialClasses + " " : "") + function(classes) {
                        return classes && "string" != typeof classes && (classes = Object.keys(classes).join(" ")), 
                        classes || "";
                    }(classes);
                    setInputsForProperty(lView, tNode.inputs.class, classInputVal), classes = NO_CHANGE;
                }
                if (hasStyleInput(tNode) && styles !== NO_CHANGE) {
                    var initialStyles = getInitialClassNameValue(stylingContext), styleInputVal = (initialStyles.length ? initialStyles + " " : "") + function(styles) {
                        var str = "";
                        if (styles) for (var props = Object.keys(styles), i = 0; i < props.length; i++) {
                            var prop = props[i];
                            str += (i ? ";" : "") + prop + ":" + styles[prop];
                        }
                        return str;
                    }(styles);
                    setInputsForProperty(lView, tNode.inputs.style, styleInputVal), styles = NO_CHANGE;
                }
            }
            !function(context, classesInput, stylesInput, directiveRef) {
                var directiveIndex = getDirectiveIndexFromRegistry(context, directive || null);
                stylesInput = stylesInput || null;
                var ignoreAllClassUpdates = isMultiValueCacheHit(context, !0, directiveIndex, classesInput = classesInput || null), ignoreAllStyleUpdates = isMultiValueCacheHit(context, !1, directiveIndex, stylesInput);
                if (!ignoreAllClassUpdates || !ignoreAllStyleUpdates) {
                    classesInput = classesInput === NO_CHANGE ? readCachedMapValue(context, !0, directiveIndex) : classesInput, 
                    stylesInput = stylesInput === NO_CHANGE ? readCachedMapValue(context, !1, directiveIndex) : stylesInput;
                    var element = context[0], classesPlayerBuilder = classesInput instanceof BoundPlayerFactory ? new ClassAndStylePlayerBuilder(classesInput, element, 1) : null, stylesPlayerBuilder = stylesInput instanceof BoundPlayerFactory ? new ClassAndStylePlayerBuilder(stylesInput, element, 2) : null, classesValue = classesPlayerBuilder ? classesInput.value : classesInput, stylesValue = stylesPlayerBuilder ? stylesInput.value : stylesInput, classNames = EMPTY_ARRAY$1, applyAllClasses = !1, playerBuildersAreDirty = !1, classesPlayerBuilderIndex = classesPlayerBuilder ? 1 : 0;
                    hasPlayerBuilderChanged(context, classesPlayerBuilder, 1) && (setPlayerBuilder(context, classesPlayerBuilder, 1), 
                    playerBuildersAreDirty = !0);
                    var stylesPlayerBuilderIndex = stylesPlayerBuilder ? 3 : 0;
                    hasPlayerBuilderChanged(context, stylesPlayerBuilder, 3) && (setPlayerBuilder(context, stylesPlayerBuilder, 3), 
                    playerBuildersAreDirty = !0), ignoreAllClassUpdates || ("string" == typeof classesValue ? (classNames = classesValue.split(/\s+/), 
                    applyAllClasses = !0) : classNames = classesValue ? Object.keys(classesValue) : EMPTY_ARRAY$1);
                    var multiStylesStartIndex = getMultiStylesStartIndex(context), multiClassesStartIndex = getMultiClassesStartIndex(context), multiClassesEndIndex = context.length;
                    if (!ignoreAllStyleUpdates) {
                        var totalNewEntries = patchStylingMapIntoContext(context, directiveIndex, stylesPlayerBuilderIndex, multiStylesStartIndex, multiClassesStartIndex, stylesValue ? Object.keys(stylesValue) : EMPTY_ARRAY$1, stylesValue || EMPTY_OBJ, stylesInput, !1);
                        totalNewEntries && (multiClassesStartIndex += 4 * totalNewEntries, multiClassesEndIndex += 4 * totalNewEntries);
                    }
                    ignoreAllClassUpdates || patchStylingMapIntoContext(context, directiveIndex, classesPlayerBuilderIndex, multiClassesStartIndex, multiClassesEndIndex, classNames, applyAllClasses || classesValue || EMPTY_OBJ, classesInput, !0), 
                    playerBuildersAreDirty && setContextPlayersDirty(context, !0);
                }
            }(stylingContext, classes, styles);
        }
        function elementStylingApply(index) {
            elementStylingApplyInternal(null, index);
        }
        function elementHostStylingApply() {
            elementStylingApplyInternal(getActiveHostContext(), getActiveHostElementIndex());
        }
        function elementStylingApplyInternal(directive, index) {
            var rootContext, res_1, nothingScheduled, lView = getLView(), isFirstRender = 0 != (8 & lView[FLAGS]);
            (function(context, renderer, rootOrView, isFirstRender, classesStore, stylesStore, directiveRef) {
                var totalPlayersQueued = 0, targetDirectiveIndex = getDirectiveIndexFromRegistry(context, directive || null);
                if (function(context) {
                    return isDirty(context, 1);
                }(context) && function(context, directiveIndex) {
                    return context[2][4 * targetDirectiveIndex + 2];
                }(context)) {
                    for (var flushPlayerBuilders = 8 & context[1], native = context[0], multiStartIndex = getMultiStylesStartIndex(context), stillDirty = !1, i = 9; i < context.length; i += 4) if (isDirty(context, i)) {
                        var flag = getPointers(context, i), directiveIndex = getDirectiveIndexFromEntry(context, i);
                        if (targetDirectiveIndex !== directiveIndex) {
                            stillDirty = !0;
                            continue;
                        }
                        var prop = getProp(context, i), value = getValue(context, i), styleSanitizer = 4 & flag ? getStyleSanitizer(context, directiveIndex) : null, playerBuilder = getPlayerBuilder(context, i), isClassBased = !!(2 & flag), valueToApply = value;
                        i < multiStartIndex && !valueExists(valueToApply) && (valueToApply = getValue(context, getMultiOrSingleIndex(flag))), 
                        valueExists(valueToApply) || (valueToApply = getInitialValue(context, flag)), (!isFirstRender || valueToApply) && (isClassBased ? setClass(native, prop, !!valueToApply, renderer, null, playerBuilder) : setStyle(native, prop, valueToApply, renderer, styleSanitizer, null, playerBuilder)), 
                        setDirty(context, i, !1);
                    }
                    if (flushPlayerBuilders) {
                        var rootContext = Array.isArray(rootOrView) ? getRootContext(rootOrView) : rootOrView, playerContext = context[8], playersStartIndex = playerContext[0];
                        for (i = 1; i < playersStartIndex; i += 2) {
                            var builder = playerContext[i], playerInsertionIndex = i + 1, oldPlayer = playerContext[playerInsertionIndex];
                            if (builder) {
                                var player = builder.buildPlayer(oldPlayer, isFirstRender);
                                void 0 !== player && (null != player && addPlayerInternal(playerContext, rootContext, native, player, playerInsertionIndex) && totalPlayersQueued++, 
                                oldPlayer && oldPlayer.destroy());
                            } else oldPlayer && oldPlayer.destroy();
                        }
                        setContextPlayersDirty(context, !1);
                    }
                    setDirectiveDirty(context, targetDirectiveIndex, !1), setContextDirty(context, stillDirty);
                }
                return totalPlayersQueued;
            })(getStylingContext(index + HEADER_OFFSET, lView), lView[RENDERER], lView, isFirstRender) > 0 && (nothingScheduled = 0 === (rootContext = getRootContext(lView)).flags, 
            rootContext.flags |= 2, nothingScheduled && rootContext.clean == _CLEAN_PROMISE && (rootContext.clean = new Promise(function(r) {
                return res_1 = r;
            }), rootContext.scheduler(function() {
                if (1 & rootContext.flags && (rootContext.flags &= -2, tickRootContext(rootContext)), 
                2 & rootContext.flags) {
                    rootContext.flags &= -3;
                    var playerHandler = rootContext.playerHandler;
                    playerHandler && playerHandler.flushPlayers();
                }
                rootContext.clean = _CLEAN_PROMISE, res_1(null);
            })));
        }
        function core_text(index, value) {
            var lView = getLView(), textNative = function(value, renderer) {
                return isProceduralRenderer(renderer) ? renderer.createText(renderStringify(value)) : renderer.createTextNode(renderStringify(value));
            }(value, lView[RENDERER]), tNode = createNodeAtIndex(index, 3, textNative, null, null);
            setIsParent(!1), appendChild(textNative, tNode, lView);
        }
        function textBinding(index, value) {
            if (value !== NO_CHANGE) {
                var lView = getLView(), element = getNativeByIndex(index, lView), renderer = lView[RENDERER];
                isProceduralRenderer(renderer) ? renderer.setValue(element, renderStringify(value)) : element.textContent = renderStringify(value);
            }
        }
        function loadLContext(target, throwOnNotFound) {
            void 0 === throwOnNotFound && (throwOnNotFound = !0);
            var context = function(target) {
                var instance, mpValue = readPatchedData(target);
                if (mpValue) {
                    if (Array.isArray(mpValue)) {
                        var lView = mpValue, nodeIndex = void 0, component = void 0, directives = void 0;
                        if ((instance = target) && instance.constructor && instance.constructor.ngComponentDef) {
                            if (-1 == (nodeIndex = function(lView, componentInstance) {
                                var componentIndices = lView[TVIEW].components;
                                if (componentIndices) for (var i = 0; i < componentIndices.length; i++) {
                                    var elementComponentIndex = componentIndices[i];
                                    if (getComponentViewByIndex(elementComponentIndex, lView)[CONTEXT] === componentInstance) return elementComponentIndex;
                                } else if (getComponentViewByIndex(HEADER_OFFSET, lView)[CONTEXT] === componentInstance) return HEADER_OFFSET;
                                return -1;
                            }(lView, target))) throw new Error("The provided component was not found in the application");
                            component = target;
                        } else if (target && target.constructor && target.constructor.ngDirectiveDef) {
                            if (-1 == (nodeIndex = function(lView, directiveInstance) {
                                for (var tNode = lView[TVIEW].firstChild; tNode; ) {
                                    for (var directiveIndexEnd = tNode.directiveEnd, i = tNode.directiveStart; i < directiveIndexEnd; i++) if (lView[i] === directiveInstance) return tNode.index;
                                    tNode = traverseNextElement(tNode);
                                }
                                return -1;
                            }(lView, target))) throw new Error("The provided directive was not found in the application");
                            directives = function(nodeIndex, lView, includeComponents) {
                                var tNode = lView[TVIEW].data[nodeIndex], directiveStartIndex = tNode.directiveStart;
                                return 0 == directiveStartIndex ? EMPTY_ARRAY$1 : (1 & tNode.flags && directiveStartIndex++, 
                                lView.slice(directiveStartIndex, tNode.directiveEnd));
                            }(nodeIndex, lView);
                        } else if (-1 == (nodeIndex = findViaNativeElement(lView, target))) return null;
                        var existingCtx = readPatchedData(native = unwrapRNode(lView[nodeIndex])), context = existingCtx && !Array.isArray(existingCtx) ? existingCtx : createLContext(lView, nodeIndex, native);
                        if (component && void 0 === context.component && (context.component = component, 
                        attachPatchData(context.component, context)), directives && void 0 === context.directives) {
                            context.directives = directives;
                            for (var i = 0; i < directives.length; i++) attachPatchData(directives[i], context);
                        }
                        attachPatchData(context.native, context), mpValue = context;
                    }
                } else for (var rElement = target, parent_1 = rElement; parent_1 = parent_1.parentNode; ) {
                    var parentContext = readPatchedData(parent_1);
                    if (parentContext) {
                        if (lView = void 0, !(lView = Array.isArray(parentContext) ? parentContext : parentContext.lView)) return null;
                        var index = findViaNativeElement(lView, rElement);
                        if (index >= 0) {
                            var native;
                            attachPatchData(native = unwrapRNode(lView[index]), context = createLContext(lView, index, native)), 
                            mpValue = context;
                            break;
                        }
                    }
                }
                return mpValue || null;
            }(target);
            if (!context && throwOnNotFound) throw new Error("Invalid ng target");
            return context;
        }
        function loadLContextFromNode(node) {
            if (!(node instanceof Node)) throw new Error("Expecting instance of DOM Node");
            return loadLContext(node);
        }
        function isBrowserEvents(listener) {
            return "boolean" == typeof listener.useCapture;
        }
        function sortListeners(a, b) {
            return a.name == b.name ? 0 : a.name < b.name ? -1 : 1;
        }
        function createRootContext(scheduler, playerHandler) {
            return {
                components: [],
                scheduler: scheduler || defaultScheduler,
                clean: CLEAN_PROMISE,
                playerHandler: playerHandler || null,
                flags: 0
            };
        }
        function LifecycleHooksFeature(component, def) {
            var rootTView = readPatchedLView(component)[TVIEW], dirIndex = rootTView.data.length - 1;
            registerPreOrderHooks(dirIndex, def, rootTView, -1, -1, -1), registerPostOrderHooks(rootTView, {
                directiveStart: dirIndex,
                directiveEnd: dirIndex + 1
            });
        }
        var SimpleChange = function() {
            function SimpleChange(previousValue, currentValue, firstChange) {
                this.previousValue = previousValue, this.currentValue = currentValue, this.firstChange = firstChange;
            }
            return SimpleChange.prototype.isFirstChange = function() {
                return this.firstChange;
            }, SimpleChange;
        }();
        function NgOnChangesFeature() {
            return NgOnChangesFeatureImpl.ngInherit = !0, NgOnChangesFeatureImpl;
        }
        function NgOnChangesFeatureImpl(definition) {
            definition.type.prototype.ngOnChanges && (definition.setInput = ngOnChangesSetInput, 
            definition.onChanges = function() {
                var simpleChangesStore = getSimpleChangesStore(this), current = simpleChangesStore && simpleChangesStore.current;
                if (current) {
                    var previous = simpleChangesStore.previous;
                    if (previous === EMPTY_OBJ) simpleChangesStore.previous = current; else for (var key in current) previous[key] = current[key];
                    simpleChangesStore.current = null, this.ngOnChanges(current);
                }
            });
        }
        function ngOnChangesSetInput(instance, value, publicName, privateName) {
            var simpleChangesStore = getSimpleChangesStore(instance) || function(instance, store) {
                return instance[SIMPLE_CHANGES_STORE] = {
                    previous: EMPTY_OBJ,
                    current: null
                };
            }(instance), current = simpleChangesStore.current || (simpleChangesStore.current = {}), previous = simpleChangesStore.previous, declaredName = this.declaredInputs[publicName], previousChange = previous[declaredName];
            current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ), 
            instance[privateName] = value;
        }
        var SIMPLE_CHANGES_STORE = "__ngSimpleChanges__";
        function getSimpleChangesStore(instance) {
            return instance[SIMPLE_CHANGES_STORE] || null;
        }
        function InheritDefinitionFeature(definition) {
            for (var superType = Object.getPrototypeOf(definition.type.prototype).constructor, _loop_1 = function() {
                var e_1, _a, superDef = void 0;
                if (isComponentDef(definition)) superDef = superType.ngComponentDef || superType.ngDirectiveDef; else {
                    if (superType.ngComponentDef) throw new Error("Directives cannot inherit Components");
                    superDef = superType.ngDirectiveDef;
                }
                var baseDef = superType.ngBaseDef;
                if (baseDef || superDef) {
                    var writeableDef = definition;
                    writeableDef.inputs = maybeUnwrapEmpty(definition.inputs), writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs), 
                    writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);
                }
                if (baseDef && (fillProperties(definition.inputs, baseDef.inputs), fillProperties(definition.declaredInputs, baseDef.declaredInputs), 
                fillProperties(definition.outputs, baseDef.outputs)), superDef) {
                    var prevHostBindings_1 = definition.hostBindings, superHostBindings_1 = superDef.hostBindings;
                    superHostBindings_1 && (definition.hostBindings = prevHostBindings_1 ? function(rf, ctx, elementIndex) {
                        superHostBindings_1(rf, ctx, elementIndex), prevHostBindings_1(rf, ctx, elementIndex);
                    } : superHostBindings_1);
                    var prevViewQuery_1 = definition.viewQuery, superViewQuery_1 = superDef.viewQuery;
                    superViewQuery_1 && (definition.viewQuery = prevViewQuery_1 ? function(rf, ctx) {
                        superViewQuery_1(rf, ctx), prevViewQuery_1(rf, ctx);
                    } : superViewQuery_1);
                    var prevContentQueries_1 = definition.contentQueries, superContentQueries_1 = superDef.contentQueries;
                    superContentQueries_1 && (definition.contentQueries = prevContentQueries_1 ? function(rf, ctx, directiveIndex) {
                        superContentQueries_1(rf, ctx, directiveIndex), prevContentQueries_1(rf, ctx, directiveIndex);
                    } : superContentQueries_1), fillProperties(definition.inputs, superDef.inputs), 
                    fillProperties(definition.declaredInputs, superDef.declaredInputs), fillProperties(definition.outputs, superDef.outputs), 
                    definition.afterContentChecked = definition.afterContentChecked || superDef.afterContentChecked, 
                    definition.afterContentInit = definition.afterContentInit || superDef.afterContentInit, 
                    definition.afterViewChecked = definition.afterViewChecked || superDef.afterViewChecked, 
                    definition.afterViewInit = definition.afterViewInit || superDef.afterViewInit, definition.doCheck = definition.doCheck || superDef.doCheck, 
                    definition.onDestroy = definition.onDestroy || superDef.onDestroy, definition.onInit = definition.onInit || superDef.onInit;
                    var features = superDef.features;
                    if (features) try {
                        for (var features_1 = __values(features), features_1_1 = features_1.next(); !features_1_1.done; features_1_1 = features_1.next()) {
                            var feature = features_1_1.value;
                            feature && feature.ngInherit && feature(definition);
                        }
                    } catch (e_1_1) {
                        e_1 = {
                            error: e_1_1
                        };
                    } finally {
                        try {
                            features_1_1 && !features_1_1.done && (_a = features_1.return) && _a.call(features_1);
                        } finally {
                            if (e_1) throw e_1.error;
                        }
                    }
                } else {
                    var superPrototype = superType.prototype;
                    superPrototype && (definition.afterContentChecked = definition.afterContentChecked || superPrototype.ngAfterContentChecked, 
                    definition.afterContentInit = definition.afterContentInit || superPrototype.ngAfterContentInit, 
                    definition.afterViewChecked = definition.afterViewChecked || superPrototype.ngAfterViewChecked, 
                    definition.afterViewInit = definition.afterViewInit || superPrototype.ngAfterViewInit, 
                    definition.doCheck = definition.doCheck || superPrototype.ngDoCheck, definition.onDestroy = definition.onDestroy || superPrototype.ngOnDestroy, 
                    definition.onInit = definition.onInit || superPrototype.ngOnInit, superPrototype.ngOnChanges && NgOnChangesFeature()(definition));
                }
                superType = Object.getPrototypeOf(superType);
            }; superType; ) _loop_1();
        }
        function maybeUnwrapEmpty(value) {
            return value === EMPTY_OBJ ? {} : value === EMPTY_ARRAY$1 ? [] : value;
        }
        var APP_ROOT = new InjectionToken("The presence of this token marks an injector as being the root injector."), NOT_YET = {}, CIRCULAR$1 = {}, EMPTY_ARRAY$2 = [], NULL_INJECTOR$1 = void 0;
        function getNullInjector() {
            return void 0 === NULL_INJECTOR$1 && (NULL_INJECTOR$1 = new NullInjector()), NULL_INJECTOR$1;
        }
        var R3Injector = function() {
            function R3Injector(def, additionalProviders, parent, source) {
                void 0 === source && (source = null);
                var _this = this;
                this.parent = parent, this.records = new Map(), this.injectorDefTypes = new Set(), 
                this.onDestroy = new Set(), this._destroyed = !1;
                var dedupStack = [];
                deepForEach([ def ], function(injectorDef) {
                    return _this.processInjectorType(injectorDef, [], dedupStack);
                }), additionalProviders && deepForEach(additionalProviders, function(provider) {
                    return _this.processProvider(provider, def, additionalProviders);
                }), this.records.set(INJECTOR, makeRecord(void 0, this)), this.isRootInjector = this.records.has(APP_ROOT), 
                this.injectorDefTypes.forEach(function(defType) {
                    return _this.get(defType);
                }), this.source = source || (def instanceof Array ? null : stringify(def));
            }
            return Object.defineProperty(R3Injector.prototype, "destroyed", {
                get: function() {
                    return this._destroyed;
                },
                enumerable: !0,
                configurable: !0
            }), R3Injector.prototype.destroy = function() {
                this.assertNotDestroyed(), this._destroyed = !0;
                try {
                    this.onDestroy.forEach(function(service) {
                        return service.ngOnDestroy();
                    });
                } finally {
                    this.records.clear(), this.onDestroy.clear(), this.injectorDefTypes.clear();
                }
            }, R3Injector.prototype.get = function(token, notFoundValue, flags) {
                void 0 === notFoundValue && (notFoundValue = Injector.THROW_IF_NOT_FOUND), void 0 === flags && (flags = InjectFlags.Default), 
                this.assertNotDestroyed();
                var value, previousInjector = setCurrentInjector(this);
                try {
                    if (!(flags & InjectFlags.SkipSelf)) {
                        var record = this.records.get(token);
                        if (void 0 === record) {
                            var def = ("function" == typeof (value = token) || "object" == typeof value && value instanceof InjectionToken) && getInjectableDef(token);
                            def && this.injectableDefInScope(def) && (record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET), 
                            this.records.set(token, record));
                        }
                        if (void 0 !== record) return this.hydrate(token, record);
                    }
                    return (flags & InjectFlags.Self ? getNullInjector() : this.parent).get(token, flags & InjectFlags.Optional ? null : notFoundValue);
                } catch (e) {
                    if ("NullInjectorError" === e.name) {
                        if ((e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || []).unshift(stringify(token)), 
                        previousInjector) throw e;
                        return catchInjectorError(e, token, "R3InjectorError", this.source);
                    }
                    throw e;
                } finally {
                    setCurrentInjector(previousInjector);
                }
            }, R3Injector.prototype.assertNotDestroyed = function() {
                if (this._destroyed) throw new Error("Injector has already been destroyed.");
            }, R3Injector.prototype.processInjectorType = function(defOrWrappedDef, parents, dedupStack) {
                var _this = this;
                if (defOrWrappedDef = resolveForwardRef(defOrWrappedDef)) {
                    var def = getInjectorDef(defOrWrappedDef), ngModule = null == def && defOrWrappedDef.ngModule || void 0, defType = void 0 === ngModule ? defOrWrappedDef : ngModule, isDuplicate = -1 !== dedupStack.indexOf(defType), providers = void 0 !== ngModule && defOrWrappedDef.providers || EMPTY_ARRAY$2;
                    if (void 0 !== ngModule && (def = getInjectorDef(ngModule)), null != def) {
                        if (this.injectorDefTypes.add(defType), this.records.set(defType, makeRecord(def.factory, NOT_YET)), 
                        null != def.imports && !isDuplicate) {
                            dedupStack.push(defType);
                            try {
                                deepForEach(def.imports, function(imported) {
                                    return _this.processInjectorType(imported, parents, dedupStack);
                                });
                            } finally {}
                        }
                        var defProviders = def.providers;
                        if (null != defProviders && !isDuplicate) {
                            var injectorType_1 = defOrWrappedDef;
                            deepForEach(defProviders, function(provider) {
                                return _this.processProvider(provider, injectorType_1, defProviders);
                            });
                        }
                        var ngModuleType = defOrWrappedDef.ngModule;
                        deepForEach(providers, function(provider) {
                            return _this.processProvider(provider, ngModuleType, providers);
                        });
                    }
                }
            }, R3Injector.prototype.processProvider = function(provider, ngModuleType, providers) {
                var token = isTypeProvider(provider = resolveForwardRef(provider)) ? provider : resolveForwardRef(provider && provider.provide), record = function(provider, ngModuleType, providers) {
                    var factory = providerToFactory(provider, ngModuleType, providers);
                    return isValueProvider(provider) ? makeRecord(void 0, provider.useValue) : makeRecord(factory, NOT_YET);
                }(provider, ngModuleType, providers);
                if (isTypeProvider(provider) || !0 !== provider.multi) {
                    var existing = this.records.get(token);
                    if (existing && void 0 !== existing.multi) throw new Error("Mixed multi-provider for " + stringify(token));
                } else {
                    var multiRecord_1 = this.records.get(token);
                    if (multiRecord_1) {
                        if (void 0 === multiRecord_1.multi) throw new Error("Mixed multi-provider for " + token + ".");
                    } else (multiRecord_1 = makeRecord(void 0, NOT_YET, !0)).factory = function() {
                        return injectArgs(multiRecord_1.multi);
                    }, this.records.set(token, multiRecord_1);
                    token = provider, multiRecord_1.multi.push(provider);
                }
                this.records.set(token, record);
            }, R3Injector.prototype.hydrate = function(token, record) {
                if (record.value === CIRCULAR$1) throw new Error("Cannot instantiate cyclic dependency! " + stringify(token));
                var value;
                return record.value === NOT_YET && (record.value = CIRCULAR$1, record.value = record.factory()), 
                "object" == typeof record.value && record.value && null !== (value = record.value) && "object" == typeof value && "function" == typeof value.ngOnDestroy && this.onDestroy.add(record.value), 
                record.value;
            }, R3Injector.prototype.injectableDefInScope = function(def) {
                return !!def.providedIn && ("string" == typeof def.providedIn ? "any" === def.providedIn || "root" === def.providedIn && this.isRootInjector : this.injectorDefTypes.has(def.providedIn));
            }, R3Injector;
        }();
        function injectableDefOrInjectorDefFactory(token) {
            var injectableDef = getInjectableDef(token);
            if (null === injectableDef) {
                var injectorDef = getInjectorDef(token);
                if (null !== injectorDef) return injectorDef.factory;
                if (token instanceof InjectionToken) throw new Error("Token " + stringify(token) + " is missing an ngInjectableDef definition.");
                if (token instanceof Function) {
                    var paramLength = token.length;
                    if (paramLength > 0) {
                        var args = new Array(paramLength).fill("?");
                        throw new Error("Can't resolve all parameters for " + stringify(token) + ": (" + args.join(", ") + ").");
                    }
                    return function() {
                        return new token();
                    };
                }
                throw new Error("unreachable");
            }
            return injectableDef.factory;
        }
        function providerToFactory(provider, ngModuleType, providers) {
            var value, factory = void 0;
            if (isTypeProvider(provider)) return injectableDefOrInjectorDefFactory(resolveForwardRef(provider));
            if (isValueProvider(provider)) factory = function() {
                return resolveForwardRef(provider.useValue);
            }; else if ((value = provider) && value.useExisting) factory = function() {
                return inject(resolveForwardRef(provider.useExisting));
            }; else if (provider && provider.useFactory) factory = function() {
                return provider.useFactory.apply(provider, __spread(injectArgs(provider.deps || [])));
            }; else {
                var classRef_1 = resolveForwardRef(provider && (provider.useClass || provider.provide));
                if (!classRef_1) {
                    var ngModuleDetail = "";
                    throw ngModuleType && providers && (ngModuleDetail = " - only instances of Provider and Type are allowed, got: [" + providers.map(function(v) {
                        return v == provider ? "?" + provider + "?" : "...";
                    }).join(", ") + "]"), new Error("Invalid provider for the NgModule '" + stringify(ngModuleType) + "'" + ngModuleDetail);
                }
                if (!provider.deps) return injectableDefOrInjectorDefFactory(classRef_1);
                factory = function() {
                    return new (classRef_1.bind.apply(classRef_1, __spread([ void 0 ], injectArgs(provider.deps))))();
                };
            }
            return factory;
        }
        function makeRecord(factory, value, multi) {
            return void 0 === multi && (multi = !1), {
                factory: factory,
                value: value,
                multi: multi ? [] : void 0
            };
        }
        function deepForEach(input, fn) {
            input.forEach(function(value) {
                return Array.isArray(value) ? deepForEach(value, fn) : fn(value);
            });
        }
        function isValueProvider(value) {
            return null !== value && "object" == typeof value && USE_VALUE$2 in value;
        }
        function isTypeProvider(value) {
            return "function" == typeof value;
        }
        function resolveProvider$1(provider, tInjectables, lInjectablesBlueprint, isComponent, isViewProvider) {
            if (provider = resolveForwardRef(provider), Array.isArray(provider)) for (var i = 0; i < provider.length; i++) resolveProvider$1(provider[i], tInjectables, lInjectablesBlueprint, isComponent, isViewProvider); else {
                var lView = getLView(), token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide), providerFactory = providerToFactory(provider), tNode = getPreviousOrParentTNode(), beginIndex = 65535 & tNode.providerIndexes, endIndex = tNode.directiveStart, cptViewProvidersCount = tNode.providerIndexes >> 16;
                if (provider.useClass || isTypeProvider(provider)) {
                    var ngOnDestroy = (provider.useClass || provider).prototype.ngOnDestroy;
                    if (ngOnDestroy) {
                        var tView = lView[TVIEW];
                        (tView.destroyHooks || (tView.destroyHooks = [])).push(tInjectables.length, ngOnDestroy);
                    }
                }
                if (isTypeProvider(provider) || !provider.multi) {
                    var factory = new NodeInjectorFactory(providerFactory, isViewProvider, directiveInject), existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);
                    -1 == existingFactoryIndex ? (diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), lView, token), 
                    tInjectables.push(token), tNode.directiveStart++, tNode.directiveEnd++, isViewProvider && (tNode.providerIndexes += 65536), 
                    lInjectablesBlueprint.push(factory), lView.push(factory)) : (lInjectablesBlueprint[existingFactoryIndex] = factory, 
                    lView[existingFactoryIndex] = factory);
                } else {
                    var existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex), existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount), doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingViewProvidersFactoryIndex];
                    isViewProvider && !doesViewProvidersFactoryExist || !isViewProvider && !(existingProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingProvidersFactoryIndex]) ? (diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), lView, token), 
                    factory = function(factoryFn, index, isViewProvider, isComponent, f) {
                        var factory = new NodeInjectorFactory(factoryFn, isViewProvider, directiveInject);
                        return factory.multi = [], factory.index = index, factory.componentProviders = 0, 
                        multiFactoryAdd(factory, f, isComponent && !isViewProvider), factory;
                    }(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent, providerFactory), 
                    !isViewProvider && doesViewProvidersFactoryExist && (lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory), 
                    tInjectables.push(token), tNode.directiveStart++, tNode.directiveEnd++, isViewProvider && (tNode.providerIndexes += 65536), 
                    lInjectablesBlueprint.push(factory), lView.push(factory)) : multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent), 
                    !isViewProvider && isComponent && doesViewProvidersFactoryExist && lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;
                }
            }
        }
        function multiFactoryAdd(multiFactory, factory, isComponentProvider) {
            multiFactory.multi.push(factory), isComponentProvider && multiFactory.componentProviders++;
        }
        function indexOf(item, arr, begin, end) {
            for (var i = begin; i < end; i++) if (arr[i] === item) return i;
            return -1;
        }
        function multiProvidersFactoryResolver(_, tData, lData, tNode) {
            return multiResolve(this.multi, []);
        }
        function multiViewProvidersFactoryResolver(_, tData, lData, tNode) {
            var result, factories = this.multi;
            if (this.providerFactory) {
                var componentCount = this.providerFactory.componentProviders, multiProviders = getNodeInjectable(tData, lData, this.providerFactory.index, tNode);
                multiResolve(factories, result = multiProviders.slice(0, componentCount));
                for (var i = componentCount; i < multiProviders.length; i++) result.push(multiProviders[i]);
            } else multiResolve(factories, result = []);
            return result;
        }
        function multiResolve(factories, result) {
            for (var i = 0; i < factories.length; i++) result.push((0, factories[i])());
            return result;
        }
        function ProvidersFeature(providers, viewProviders) {
            return void 0 === viewProviders && (viewProviders = []), function(definition) {
                definition.providersResolver = function(def, processProvidersFn) {
                    return function(def, providers, viewProviders) {
                        var tView = getLView()[TVIEW];
                        if (tView.firstTemplatePass) {
                            var isComponent = isComponentDef(def);
                            resolveProvider$1(viewProviders, tView.data, tView.blueprint, isComponent, !0), 
                            resolveProvider$1(providers, tView.data, tView.blueprint, isComponent, !1);
                        }
                    }(def, processProvidersFn ? processProvidersFn(providers) : providers, viewProviders);
                };
            };
        }
        var R3ElementRef, R3TemplateRef, R3ViewContainerRef, core_ComponentRef = function() {
            return function() {};
        }(), core_ComponentFactory = function() {
            return function() {};
        }(), _NullComponentFactoryResolver = function() {
            function _NullComponentFactoryResolver() {}
            return _NullComponentFactoryResolver.prototype.resolveComponentFactory = function(component) {
                throw function(component) {
                    var error = Error("No component factory found for " + stringify(component) + ". Did you add it to @NgModule.entryComponents?");
                    return error.ngComponent = component, error;
                }(component);
            }, _NullComponentFactoryResolver;
        }(), core_ComponentFactoryResolver = function() {
            function ComponentFactoryResolver() {}
            return ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver(), ComponentFactoryResolver;
        }(), NgModuleRef = function() {
            return function() {};
        }(), core_NgModuleFactory = function() {
            return function() {};
        }(), core_ViewRef = function() {
            function ViewRef(_lView, _context, _componentIndex) {
                this._context = _context, this._componentIndex = _componentIndex, this._appRef = null, 
                this._viewContainerRef = null, this._tViewNode = null, this._lView = _lView;
            }
            return Object.defineProperty(ViewRef.prototype, "rootNodes", {
                get: function() {
                    return null == this._lView[HOST] ? function collectNativeNodes(lView, parentTNode, result) {
                        for (var tNodeChild = parentTNode.child; tNodeChild; ) {
                            var nativeNode = getNativeByTNode(tNodeChild, lView);
                            if (nativeNode && result.push(nativeNode), 4 === tNodeChild.type) collectNativeNodes(lView, tNodeChild, result); else if (1 === tNodeChild.type) for (var componentView = findComponentView(lView), componentHost = componentView[T_HOST], parentView = getLViewParent(componentView), currentProjectedNode = componentHost.projection[tNodeChild.projection]; currentProjectedNode && parentView; ) result.push(getNativeByTNode(currentProjectedNode, parentView)), 
                            currentProjectedNode = currentProjectedNode.next;
                            tNodeChild = tNodeChild.next;
                        }
                        return result;
                    }(this._lView, this._lView[T_HOST], []) : [];
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(ViewRef.prototype, "context", {
                get: function() {
                    return this._context ? this._context : this._lookUpContext();
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(ViewRef.prototype, "destroyed", {
                get: function() {
                    return 256 == (256 & this._lView[FLAGS]);
                },
                enumerable: !0,
                configurable: !0
            }), ViewRef.prototype.destroy = function() {
                if (this._appRef) this._appRef.detachView(this); else if (this._viewContainerRef) {
                    var index = this._viewContainerRef.indexOf(this);
                    index > -1 && this._viewContainerRef.detach(index), this._viewContainerRef = null;
                }
                destroyLView(this._lView);
            }, ViewRef.prototype.onDestroy = function(callback) {
                var view, cleanupFn;
                cleanupFn = callback, getCleanup(view = this._lView).push(cleanupFn), view[TVIEW].firstTemplatePass && getTViewCleanup(view).push(view[CLEANUP].length - 1, null);
            }, ViewRef.prototype.markForCheck = function() {
                markViewDirty(this._lView);
            }, ViewRef.prototype.detach = function() {
                this._lView[FLAGS] &= -129;
            }, ViewRef.prototype.reattach = function() {
                this._lView[FLAGS] |= 128;
            }, ViewRef.prototype.detectChanges = function() {
                detectChangesInternal(this._lView, this.context);
            }, ViewRef.prototype.checkNoChanges = function() {
                !function(view, context) {
                    setCheckNoChangesMode(!0);
                    try {
                        detectChangesInternal(view, context);
                    } finally {
                        setCheckNoChangesMode(!1);
                    }
                }(this._lView, this.context);
            }, ViewRef.prototype.attachToViewContainerRef = function(vcRef) {
                if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!");
                this._viewContainerRef = vcRef;
            }, ViewRef.prototype.detachFromAppRef = function() {
                var lView;
                this._appRef = null, walkTNodeTree(lView = this._lView, 1, lView[RENDERER], null);
            }, ViewRef.prototype.attachToAppRef = function(appRef) {
                if (this._viewContainerRef) throw new Error("This view is already attached to a ViewContainer!");
                this._appRef = appRef;
            }, ViewRef.prototype._lookUpContext = function() {
                return this._context = getLViewParent(this._lView)[this._componentIndex];
            }, ViewRef;
        }(), core_RootViewRef = function(_super) {
            function RootViewRef(_view) {
                var _this = _super.call(this, _view, null, -1) || this;
                return _this._view = _view, _this;
            }
            return __extends(RootViewRef, _super), RootViewRef.prototype.detectChanges = function() {
                detectChangesInRootView(this._view);
            }, RootViewRef.prototype.checkNoChanges = function() {
                !function(lView) {
                    setCheckNoChangesMode(!0);
                    try {
                        detectChangesInRootView(lView);
                    } finally {
                        setCheckNoChangesMode(!1);
                    }
                }(this._view);
            }, Object.defineProperty(RootViewRef.prototype, "context", {
                get: function() {
                    return null;
                },
                enumerable: !0,
                configurable: !0
            }), RootViewRef;
        }(core_ViewRef);
        function createElementRef(ElementRefToken, tNode, view) {
            return R3ElementRef || (R3ElementRef = function(_super) {
                function ElementRef_() {
                    return null !== _super && _super.apply(this, arguments) || this;
                }
                return __extends(ElementRef_, _super), ElementRef_;
            }(ElementRefToken)), new R3ElementRef(getNativeByTNode(tNode, view));
        }
        function createTemplateRef(TemplateRefToken, ElementRefToken, hostTNode, hostView) {
            if (R3TemplateRef || (R3TemplateRef = function(_super) {
                function TemplateRef_(_declarationParentView, elementRef, _tView, _hostLContainer, _injectorIndex) {
                    var _this = _super.call(this) || this;
                    return _this._declarationParentView = _declarationParentView, _this.elementRef = elementRef, 
                    _this._tView = _tView, _this._hostLContainer = _hostLContainer, _this._injectorIndex = _injectorIndex, 
                    _this;
                }
                return __extends(TemplateRef_, _super), TemplateRef_.prototype.createEmbeddedView = function(context, container, index) {
                    var lView = function(tView, context, declarationView, queries, injectorIndex) {
                        var _isParent = getIsParent(), _previousOrParentTNode = getPreviousOrParentTNode();
                        setIsParent(!0), setPreviousOrParentTNode(null);
                        var lView = createLView(declarationView, tView, context, 16, null, null);
                        return lView[DECLARATION_VIEW] = declarationView, queries && (lView[QUERIES] = queries.createView()), 
                        assignTViewNodeToLView(tView, null, -1, lView), tView.firstTemplatePass && (tView.node.injectorIndex = injectorIndex), 
                        setIsParent(_isParent), setPreviousOrParentTNode(_previousOrParentTNode), lView;
                    }(this._tView, context, this._declarationParentView, this._hostLContainer[QUERIES], this._injectorIndex);
                    container && insertView(lView, container, index), renderEmbeddedTemplate(lView, this._tView, context);
                    var viewRef = new core_ViewRef(lView, context, -1);
                    return viewRef._tViewNode = lView[T_HOST], viewRef;
                }, TemplateRef_;
            }(TemplateRefToken)), 0 === hostTNode.type) {
                var hostContainer = hostView[hostTNode.index];
                return new R3TemplateRef(hostView, createElementRef(ElementRefToken, hostTNode, hostView), hostTNode.tViews, hostContainer, hostTNode.injectorIndex);
            }
            return null;
        }
        var ElementRef = function() {
            function ElementRef(nativeElement) {
                this.nativeElement = nativeElement;
            }
            return ElementRef.__NG_ELEMENT_ID__ = function() {
                return SWITCH_ELEMENT_REF_FACTORY(ElementRef);
            }, ElementRef;
        }(), SWITCH_ELEMENT_REF_FACTORY = function(ElementRefToken) {
            return createElementRef(ElementRefToken, getPreviousOrParentTNode(), getLView());
        }, RendererFactory2 = function() {
            return function() {};
        }(), RendererStyleFlags2 = function(RendererStyleFlags2) {
            return RendererStyleFlags2[RendererStyleFlags2.Important = 1] = "Important", RendererStyleFlags2[RendererStyleFlags2.DashCase = 2] = "DashCase", 
            RendererStyleFlags2;
        }({}), VERSION = new (function() {
            return function(full) {
                this.full = full, this.major = full.split(".")[0], this.minor = full.split(".")[1], 
                this.patch = full.split(".").slice(2).join(".");
            };
        }())("8.0.0-beta.10+123.sha-a6809e0.with-local-changes"), DefaultIterableDifferFactory = function() {
            function DefaultIterableDifferFactory() {}
            return DefaultIterableDifferFactory.prototype.supports = function(obj) {
                return isListLikeIterable(obj);
            }, DefaultIterableDifferFactory.prototype.create = function(trackByFn) {
                return new DefaultIterableDiffer(trackByFn);
            }, DefaultIterableDifferFactory;
        }(), trackByIdentity = function(index, item) {
            return item;
        }, DefaultIterableDiffer = function() {
            function DefaultIterableDiffer(trackByFn) {
                this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, 
                this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, 
                this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, 
                this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = trackByFn || trackByIdentity;
            }
            return DefaultIterableDiffer.prototype.forEachItem = function(fn) {
                var record;
                for (record = this._itHead; null !== record; record = record._next) fn(record);
            }, DefaultIterableDiffer.prototype.forEachOperation = function(fn) {
                for (var nextIt = this._itHead, nextRemove = this._removalsHead, addRemoveOffset = 0, moveOffsets = null; nextIt || nextRemove; ) {
                    var record = !nextRemove || nextIt && nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? nextIt : nextRemove, adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets), currentIndex = record.currentIndex;
                    if (record === nextRemove) addRemoveOffset--, nextRemove = nextRemove._nextRemoved; else if (nextIt = nextIt._next, 
                    null == record.previousIndex) addRemoveOffset++; else {
                        moveOffsets || (moveOffsets = []);
                        var localMovePreviousIndex = adjPreviousIndex - addRemoveOffset, localCurrentIndex = currentIndex - addRemoveOffset;
                        if (localMovePreviousIndex != localCurrentIndex) {
                            for (var i = 0; i < localMovePreviousIndex; i++) {
                                var offset = i < moveOffsets.length ? moveOffsets[i] : moveOffsets[i] = 0, index = offset + i;
                                localCurrentIndex <= index && index < localMovePreviousIndex && (moveOffsets[i] = offset + 1);
                            }
                            moveOffsets[record.previousIndex] = localCurrentIndex - localMovePreviousIndex;
                        }
                    }
                    adjPreviousIndex !== currentIndex && fn(record, adjPreviousIndex, currentIndex);
                }
            }, DefaultIterableDiffer.prototype.forEachPreviousItem = function(fn) {
                var record;
                for (record = this._previousItHead; null !== record; record = record._nextPrevious) fn(record);
            }, DefaultIterableDiffer.prototype.forEachAddedItem = function(fn) {
                var record;
                for (record = this._additionsHead; null !== record; record = record._nextAdded) fn(record);
            }, DefaultIterableDiffer.prototype.forEachMovedItem = function(fn) {
                var record;
                for (record = this._movesHead; null !== record; record = record._nextMoved) fn(record);
            }, DefaultIterableDiffer.prototype.forEachRemovedItem = function(fn) {
                var record;
                for (record = this._removalsHead; null !== record; record = record._nextRemoved) fn(record);
            }, DefaultIterableDiffer.prototype.forEachIdentityChange = function(fn) {
                var record;
                for (record = this._identityChangesHead; null !== record; record = record._nextIdentityChange) fn(record);
            }, DefaultIterableDiffer.prototype.diff = function(collection) {
                if (null == collection && (collection = []), !isListLikeIterable(collection)) throw new Error("Error trying to diff '" + stringify(collection) + "'. Only arrays and iterables are allowed");
                return this.check(collection) ? this : null;
            }, DefaultIterableDiffer.prototype.onDestroy = function() {}, DefaultIterableDiffer.prototype.check = function(collection) {
                var _this = this;
                this._reset();
                var index, item, itemTrackBy, record = this._itHead, mayBeDirty = !1;
                if (Array.isArray(collection)) {
                    this.length = collection.length;
                    for (var index_1 = 0; index_1 < this.length; index_1++) itemTrackBy = this._trackByFn(index_1, item = collection[index_1]), 
                    null !== record && looseIdentical(record.trackById, itemTrackBy) ? (mayBeDirty && (record = this._verifyReinsertion(record, item, itemTrackBy, index_1)), 
                    looseIdentical(record.item, item) || this._addIdentityChange(record, item)) : (record = this._mismatch(record, item, itemTrackBy, index_1), 
                    mayBeDirty = !0), record = record._next;
                } else index = 0, function(obj, fn) {
                    if (Array.isArray(obj)) for (var i = 0; i < obj.length; i++) fn(obj[i]); else for (var iterator = obj[core_getSymbolIterator()](), item = void 0; !(item = iterator.next()).done; ) fn(item.value);
                }(collection, function(item) {
                    itemTrackBy = _this._trackByFn(index, item), null !== record && looseIdentical(record.trackById, itemTrackBy) ? (mayBeDirty && (record = _this._verifyReinsertion(record, item, itemTrackBy, index)), 
                    looseIdentical(record.item, item) || _this._addIdentityChange(record, item)) : (record = _this._mismatch(record, item, itemTrackBy, index), 
                    mayBeDirty = !0), record = record._next, index++;
                }), this.length = index;
                return this._truncate(record), this.collection = collection, this.isDirty;
            }, Object.defineProperty(DefaultIterableDiffer.prototype, "isDirty", {
                get: function() {
                    return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead;
                },
                enumerable: !0,
                configurable: !0
            }), DefaultIterableDiffer.prototype._reset = function() {
                if (this.isDirty) {
                    var record = void 0, nextRecord = void 0;
                    for (record = this._previousItHead = this._itHead; null !== record; record = record._next) record._nextPrevious = record._next;
                    for (record = this._additionsHead; null !== record; record = record._nextAdded) record.previousIndex = record.currentIndex;
                    for (this._additionsHead = this._additionsTail = null, record = this._movesHead; null !== record; record = nextRecord) record.previousIndex = record.currentIndex, 
                    nextRecord = record._nextMoved;
                    this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, 
                    this._identityChangesHead = this._identityChangesTail = null;
                }
            }, DefaultIterableDiffer.prototype._mismatch = function(record, item, itemTrackBy, index) {
                var previousRecord;
                return null === record ? previousRecord = this._itTail : (previousRecord = record._prev, 
                this._remove(record)), null !== (record = null === this._linkedRecords ? null : this._linkedRecords.get(itemTrackBy, index)) ? (looseIdentical(record.item, item) || this._addIdentityChange(record, item), 
                this._moveAfter(record, previousRecord, index)) : null !== (record = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(itemTrackBy, null)) ? (looseIdentical(record.item, item) || this._addIdentityChange(record, item), 
                this._reinsertAfter(record, previousRecord, index)) : record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index), 
                record;
            }, DefaultIterableDiffer.prototype._verifyReinsertion = function(record, item, itemTrackBy, index) {
                var reinsertRecord = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(itemTrackBy, null);
                return null !== reinsertRecord ? record = this._reinsertAfter(reinsertRecord, record._prev, index) : record.currentIndex != index && (record.currentIndex = index, 
                this._addToMoves(record, index)), record;
            }, DefaultIterableDiffer.prototype._truncate = function(record) {
                for (;null !== record; ) {
                    var nextRecord = record._next;
                    this._addToRemovals(this._unlink(record)), record = nextRecord;
                }
                null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), 
                null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), 
                null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null);
            }, DefaultIterableDiffer.prototype._reinsertAfter = function(record, prevRecord, index) {
                null !== this._unlinkedRecords && this._unlinkedRecords.remove(record);
                var prev = record._prevRemoved, next = record._nextRemoved;
                return null === prev ? this._removalsHead = next : prev._nextRemoved = next, null === next ? this._removalsTail = prev : next._prevRemoved = prev, 
                this._insertAfter(record, prevRecord, index), this._addToMoves(record, index), record;
            }, DefaultIterableDiffer.prototype._moveAfter = function(record, prevRecord, index) {
                return this._unlink(record), this._insertAfter(record, prevRecord, index), this._addToMoves(record, index), 
                record;
            }, DefaultIterableDiffer.prototype._addAfter = function(record, prevRecord, index) {
                return this._insertAfter(record, prevRecord, index), this._additionsTail = null === this._additionsTail ? this._additionsHead = record : this._additionsTail._nextAdded = record, 
                record;
            }, DefaultIterableDiffer.prototype._insertAfter = function(record, prevRecord, index) {
                var next = null === prevRecord ? this._itHead : prevRecord._next;
                return record._next = next, record._prev = prevRecord, null === next ? this._itTail = record : next._prev = record, 
                null === prevRecord ? this._itHead = record : prevRecord._next = record, null === this._linkedRecords && (this._linkedRecords = new _DuplicateMap()), 
                this._linkedRecords.put(record), record.currentIndex = index, record;
            }, DefaultIterableDiffer.prototype._remove = function(record) {
                return this._addToRemovals(this._unlink(record));
            }, DefaultIterableDiffer.prototype._unlink = function(record) {
                null !== this._linkedRecords && this._linkedRecords.remove(record);
                var prev = record._prev, next = record._next;
                return null === prev ? this._itHead = next : prev._next = next, null === next ? this._itTail = prev : next._prev = prev, 
                record;
            }, DefaultIterableDiffer.prototype._addToMoves = function(record, toIndex) {
                return record.previousIndex === toIndex ? record : (this._movesTail = null === this._movesTail ? this._movesHead = record : this._movesTail._nextMoved = record, 
                record);
            }, DefaultIterableDiffer.prototype._addToRemovals = function(record) {
                return null === this._unlinkedRecords && (this._unlinkedRecords = new _DuplicateMap()), 
                this._unlinkedRecords.put(record), record.currentIndex = null, record._nextRemoved = null, 
                null === this._removalsTail ? (this._removalsTail = this._removalsHead = record, 
                record._prevRemoved = null) : (record._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = record), 
                record;
            }, DefaultIterableDiffer.prototype._addIdentityChange = function(record, item) {
                return record.item = item, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = record : this._identityChangesTail._nextIdentityChange = record, 
                record;
            }, DefaultIterableDiffer;
        }(), IterableChangeRecord_ = function() {
            return function(item, trackById) {
                this.item = item, this.trackById = trackById, this.currentIndex = null, this.previousIndex = null, 
                this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, 
                this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, 
                this._nextMoved = null, this._nextIdentityChange = null;
            };
        }(), _DuplicateItemRecordList = function() {
            function _DuplicateItemRecordList() {
                this._head = null, this._tail = null;
            }
            return _DuplicateItemRecordList.prototype.add = function(record) {
                null === this._head ? (this._head = this._tail = record, record._nextDup = null, 
                record._prevDup = null) : (this._tail._nextDup = record, record._prevDup = this._tail, 
                record._nextDup = null, this._tail = record);
            }, _DuplicateItemRecordList.prototype.get = function(trackById, atOrAfterIndex) {
                var record;
                for (record = this._head; null !== record; record = record._nextDup) if ((null === atOrAfterIndex || atOrAfterIndex <= record.currentIndex) && looseIdentical(record.trackById, trackById)) return record;
                return null;
            }, _DuplicateItemRecordList.prototype.remove = function(record) {
                var prev = record._prevDup, next = record._nextDup;
                return null === prev ? this._head = next : prev._nextDup = next, null === next ? this._tail = prev : next._prevDup = prev, 
                null === this._head;
            }, _DuplicateItemRecordList;
        }(), _DuplicateMap = function() {
            function _DuplicateMap() {
                this.map = new Map();
            }
            return _DuplicateMap.prototype.put = function(record) {
                var key = record.trackById, duplicates = this.map.get(key);
                duplicates || (duplicates = new _DuplicateItemRecordList(), this.map.set(key, duplicates)), 
                duplicates.add(record);
            }, _DuplicateMap.prototype.get = function(trackById, atOrAfterIndex) {
                var recordList = this.map.get(trackById);
                return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
            }, _DuplicateMap.prototype.remove = function(record) {
                var key = record.trackById;
                return this.map.get(key).remove(record) && this.map.delete(key), record;
            }, Object.defineProperty(_DuplicateMap.prototype, "isEmpty", {
                get: function() {
                    return 0 === this.map.size;
                },
                enumerable: !0,
                configurable: !0
            }), _DuplicateMap.prototype.clear = function() {
                this.map.clear();
            }, _DuplicateMap;
        }();
        function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
            var previousIndex = item.previousIndex;
            if (null === previousIndex) return previousIndex;
            var moveOffset = 0;
            return moveOffsets && previousIndex < moveOffsets.length && (moveOffset = moveOffsets[previousIndex]), 
            previousIndex + addRemoveOffset + moveOffset;
        }
        var DefaultKeyValueDifferFactory = function() {
            function DefaultKeyValueDifferFactory() {}
            return DefaultKeyValueDifferFactory.prototype.supports = function(obj) {
                return obj instanceof Map || isJsObject(obj);
            }, DefaultKeyValueDifferFactory.prototype.create = function() {
                return new DefaultKeyValueDiffer();
            }, DefaultKeyValueDifferFactory;
        }(), DefaultKeyValueDiffer = function() {
            function DefaultKeyValueDiffer() {
                this._records = new Map(), this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, 
                this._changesHead = null, this._changesTail = null, this._additionsHead = null, 
                this._additionsTail = null, this._removalsHead = null, this._removalsTail = null;
            }
            return Object.defineProperty(DefaultKeyValueDiffer.prototype, "isDirty", {
                get: function() {
                    return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead;
                },
                enumerable: !0,
                configurable: !0
            }), DefaultKeyValueDiffer.prototype.forEachItem = function(fn) {
                var record;
                for (record = this._mapHead; null !== record; record = record._next) fn(record);
            }, DefaultKeyValueDiffer.prototype.forEachPreviousItem = function(fn) {
                var record;
                for (record = this._previousMapHead; null !== record; record = record._nextPrevious) fn(record);
            }, DefaultKeyValueDiffer.prototype.forEachChangedItem = function(fn) {
                var record;
                for (record = this._changesHead; null !== record; record = record._nextChanged) fn(record);
            }, DefaultKeyValueDiffer.prototype.forEachAddedItem = function(fn) {
                var record;
                for (record = this._additionsHead; null !== record; record = record._nextAdded) fn(record);
            }, DefaultKeyValueDiffer.prototype.forEachRemovedItem = function(fn) {
                var record;
                for (record = this._removalsHead; null !== record; record = record._nextRemoved) fn(record);
            }, DefaultKeyValueDiffer.prototype.diff = function(map) {
                if (map) {
                    if (!(map instanceof Map || isJsObject(map))) throw new Error("Error trying to diff '" + stringify(map) + "'. Only maps and objects are allowed");
                } else map = new Map();
                return this.check(map) ? this : null;
            }, DefaultKeyValueDiffer.prototype.onDestroy = function() {}, DefaultKeyValueDiffer.prototype.check = function(map) {
                var _this = this;
                this._reset();
                var insertBefore = this._mapHead;
                if (this._appendAfter = null, this._forEach(map, function(value, key) {
                    if (insertBefore && insertBefore.key === key) _this._maybeAddToChanges(insertBefore, value), 
                    _this._appendAfter = insertBefore, insertBefore = insertBefore._next; else {
                        var record = _this._getOrCreateRecordForKey(key, value);
                        insertBefore = _this._insertBeforeOrAppend(insertBefore, record);
                    }
                }), insertBefore) {
                    insertBefore._prev && (insertBefore._prev._next = null), this._removalsHead = insertBefore;
                    for (var record = insertBefore; null !== record; record = record._nextRemoved) record === this._mapHead && (this._mapHead = null), 
                    this._records.delete(record.key), record._nextRemoved = record._next, record.previousValue = record.currentValue, 
                    record.currentValue = null, record._prev = null, record._next = null;
                }
                return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), 
                this.isDirty;
            }, DefaultKeyValueDiffer.prototype._insertBeforeOrAppend = function(before, record) {
                if (before) {
                    var prev = before._prev;
                    return record._next = before, record._prev = prev, before._prev = record, prev && (prev._next = record), 
                    before === this._mapHead && (this._mapHead = record), this._appendAfter = before, 
                    before;
                }
                return this._appendAfter ? (this._appendAfter._next = record, record._prev = this._appendAfter) : this._mapHead = record, 
                this._appendAfter = record, null;
            }, DefaultKeyValueDiffer.prototype._getOrCreateRecordForKey = function(key, value) {
                if (this._records.has(key)) {
                    var record_1 = this._records.get(key);
                    this._maybeAddToChanges(record_1, value);
                    var prev = record_1._prev, next = record_1._next;
                    return prev && (prev._next = next), next && (next._prev = prev), record_1._next = null, 
                    record_1._prev = null, record_1;
                }
                var record = new KeyValueChangeRecord_(key);
                return this._records.set(key, record), record.currentValue = value, this._addToAdditions(record), 
                record;
            }, DefaultKeyValueDiffer.prototype._reset = function() {
                if (this.isDirty) {
                    var record = void 0;
                    for (this._previousMapHead = this._mapHead, record = this._previousMapHead; null !== record; record = record._next) record._nextPrevious = record._next;
                    for (record = this._changesHead; null !== record; record = record._nextChanged) record.previousValue = record.currentValue;
                    for (record = this._additionsHead; null != record; record = record._nextAdded) record.previousValue = record.currentValue;
                    this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, 
                    this._removalsHead = null;
                }
            }, DefaultKeyValueDiffer.prototype._maybeAddToChanges = function(record, newValue) {
                looseIdentical(newValue, record.currentValue) || (record.previousValue = record.currentValue, 
                record.currentValue = newValue, this._addToChanges(record));
            }, DefaultKeyValueDiffer.prototype._addToAdditions = function(record) {
                null === this._additionsHead ? this._additionsHead = this._additionsTail = record : (this._additionsTail._nextAdded = record, 
                this._additionsTail = record);
            }, DefaultKeyValueDiffer.prototype._addToChanges = function(record) {
                null === this._changesHead ? this._changesHead = this._changesTail = record : (this._changesTail._nextChanged = record, 
                this._changesTail = record);
            }, DefaultKeyValueDiffer.prototype._forEach = function(obj, fn) {
                obj instanceof Map ? obj.forEach(fn) : Object.keys(obj).forEach(function(k) {
                    return fn(obj[k], k);
                });
            }, DefaultKeyValueDiffer;
        }(), KeyValueChangeRecord_ = function() {
            return function(key) {
                this.key = key, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, 
                this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, 
                this._nextChanged = null;
            };
        }(), IterableDiffers = function() {
            function IterableDiffers(factories) {
                this.factories = factories;
            }
            return IterableDiffers.create = function(factories, parent) {
                if (null != parent) {
                    var copied = parent.factories.slice();
                    factories = factories.concat(copied);
                }
                return new IterableDiffers(factories);
            }, IterableDiffers.extend = function(factories) {
                return {
                    provide: IterableDiffers,
                    useFactory: function(parent) {
                        if (!parent) throw new Error("Cannot extend IterableDiffers without a parent injector");
                        return IterableDiffers.create(factories, parent);
                    },
                    deps: [ [ IterableDiffers, new SkipSelf(), new Optional() ] ]
                };
            }, IterableDiffers.prototype.find = function(iterable) {
                var type, factory = this.factories.find(function(f) {
                    return f.supports(iterable);
                });
                if (null != factory) return factory;
                throw new Error("Cannot find a differ supporting object '" + iterable + "' of type '" + ((type = iterable).name || typeof type) + "'");
            }, IterableDiffers.ngInjectableDef = defineInjectable({
                providedIn: "root",
                factory: function() {
                    return new IterableDiffers([ new DefaultIterableDifferFactory() ]);
                }
            }), IterableDiffers;
        }(), KeyValueDiffers = function() {
            function KeyValueDiffers(factories) {
                this.factories = factories;
            }
            return KeyValueDiffers.create = function(factories, parent) {
                if (parent) {
                    var copied = parent.factories.slice();
                    factories = factories.concat(copied);
                }
                return new KeyValueDiffers(factories);
            }, KeyValueDiffers.extend = function(factories) {
                return {
                    provide: KeyValueDiffers,
                    useFactory: function(parent) {
                        if (!parent) throw new Error("Cannot extend KeyValueDiffers without a parent injector");
                        return KeyValueDiffers.create(factories, parent);
                    },
                    deps: [ [ KeyValueDiffers, new SkipSelf(), new Optional() ] ]
                };
            }, KeyValueDiffers.prototype.find = function(kv) {
                var factory = this.factories.find(function(f) {
                    return f.supports(kv);
                });
                if (factory) return factory;
                throw new Error("Cannot find a differ supporting object '" + kv + "'");
            }, KeyValueDiffers.ngInjectableDef = defineInjectable({
                providedIn: "root",
                factory: function() {
                    return new KeyValueDiffers([ new DefaultKeyValueDifferFactory() ]);
                }
            }), KeyValueDiffers;
        }(), ChangeDetectorRef = function() {
            function ChangeDetectorRef() {}
            return ChangeDetectorRef.__NG_ELEMENT_ID__ = function() {
                return SWITCH_CHANGE_DETECTOR_REF_FACTORY();
            }, ChangeDetectorRef;
        }(), SWITCH_CHANGE_DETECTOR_REF_FACTORY = function() {
            return function(hostTNode, hostView, context) {
                if (isComponent(hostTNode)) {
                    var componentIndex = hostTNode.directiveStart, componentView = getComponentViewByIndex(hostTNode.index, hostView);
                    return new core_ViewRef(componentView, null, componentIndex);
                }
                if (3 === hostTNode.type || 0 === hostTNode.type || 4 === hostTNode.type) {
                    var hostComponentView = findComponentView(hostView);
                    return new core_ViewRef(hostComponentView, hostComponentView[CONTEXT], -1);
                }
                return null;
            }(getPreviousOrParentTNode(), getLView());
        }, keyValDiff = [ new DefaultKeyValueDifferFactory() ], defaultIterableDiffers = new IterableDiffers([ new DefaultIterableDifferFactory() ]), defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff), TemplateRef = function() {
            function TemplateRef() {}
            return TemplateRef.__NG_ELEMENT_ID__ = function() {
                return SWITCH_TEMPLATE_REF_FACTORY(TemplateRef, ElementRef);
            }, TemplateRef;
        }(), SWITCH_TEMPLATE_REF_FACTORY = function(TemplateRefToken, ElementRefToken) {
            return createTemplateRef(TemplateRefToken, ElementRefToken, getPreviousOrParentTNode(), getLView());
        }, ViewContainerRef = function() {
            function ViewContainerRef() {}
            return ViewContainerRef.__NG_ELEMENT_ID__ = function() {
                return SWITCH_VIEW_CONTAINER_REF_FACTORY(ViewContainerRef, ElementRef);
            }, ViewContainerRef;
        }(), SWITCH_VIEW_CONTAINER_REF_FACTORY = function(ViewContainerRefToken, ElementRefToken) {
            return function(ViewContainerRefToken, ElementRefToken, hostTNode, hostView) {
                var lContainer;
                R3ViewContainerRef || (R3ViewContainerRef = function(_super) {
                    function ViewContainerRef_(_lContainer, _hostTNode, _hostView) {
                        var _this = _super.call(this) || this;
                        return _this._lContainer = _lContainer, _this._hostTNode = _hostTNode, _this._hostView = _hostView, 
                        _this._viewRefs = [], _this;
                    }
                    return __extends(ViewContainerRef_, _super), Object.defineProperty(ViewContainerRef_.prototype, "element", {
                        get: function() {
                            return createElementRef(ElementRefToken, this._hostTNode, this._hostView);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(ViewContainerRef_.prototype, "injector", {
                        get: function() {
                            return new NodeInjector(this._hostTNode, this._hostView);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(ViewContainerRef_.prototype, "parentInjector", {
                        get: function() {
                            var parentLocation = getParentInjectorLocation(this._hostTNode, this._hostView), parentView = getParentInjectorView(parentLocation, this._hostView), parentTNode = function(location, startView, startTNode) {
                                if (startTNode.parent && -1 !== startTNode.parent.injectorIndex) {
                                    for (var injectorIndex = startTNode.parent.injectorIndex, parentTNode_1 = startTNode.parent; null != parentTNode_1.parent && injectorIndex == parentTNode_1.injectorIndex; ) parentTNode_1 = parentTNode_1.parent;
                                    return parentTNode_1;
                                }
                                for (var viewOffset = getParentInjectorViewOffset(location), parentView = startView, parentTNode = startView[T_HOST]; viewOffset > 1; ) parentTNode = (parentView = parentView[DECLARATION_VIEW])[T_HOST], 
                                viewOffset--;
                                return parentTNode;
                            }(parentLocation, this._hostView, this._hostTNode);
                            return hasParentInjector(parentLocation) && null != parentTNode ? new NodeInjector(parentTNode, parentView) : new NodeInjector(null, this._hostView);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), ViewContainerRef_.prototype.clear = function() {
                        for (;this._lContainer[VIEWS].length; ) this.remove(0);
                    }, ViewContainerRef_.prototype.get = function(index) {
                        return this._viewRefs[index] || null;
                    }, Object.defineProperty(ViewContainerRef_.prototype, "length", {
                        get: function() {
                            return this._lContainer[VIEWS].length;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), ViewContainerRef_.prototype.createEmbeddedView = function(templateRef, context, index) {
                        var adjustedIdx = this._adjustIndex(index), viewRef = templateRef.createEmbeddedView(context || {}, this._lContainer, adjustedIdx);
                        return viewRef.attachToViewContainerRef(this), this._viewRefs.splice(adjustedIdx, 0, viewRef), 
                        viewRef;
                    }, ViewContainerRef_.prototype.createComponent = function(componentFactory, index, injector, projectableNodes, ngModuleRef) {
                        var contextInjector = injector || this.parentInjector;
                        !ngModuleRef && null == componentFactory.ngModule && contextInjector && (ngModuleRef = contextInjector.get(NgModuleRef, null));
                        var componentRef = componentFactory.create(contextInjector, projectableNodes, void 0, ngModuleRef);
                        return this.insert(componentRef.hostView, index), componentRef;
                    }, ViewContainerRef_.prototype.insert = function(viewRef, index) {
                        if (viewRef.destroyed) throw new Error("Cannot insert a destroyed View in a ViewContainer!");
                        var lView = viewRef._lView, adjustedIdx = this._adjustIndex(index);
                        return viewAttachedToContainer(lView) ? this.move(viewRef, adjustedIdx) : (insertView(lView, this._lContainer, adjustedIdx), 
                        addRemoveViewFromContainer(lView, !0, getBeforeNodeForView(adjustedIdx, this._lContainer[VIEWS], this._lContainer[NATIVE])), 
                        viewRef.attachToViewContainerRef(this), this._viewRefs.splice(adjustedIdx, 0, viewRef), 
                        viewRef);
                    }, ViewContainerRef_.prototype.move = function(viewRef, newIndex) {
                        if (viewRef.destroyed) throw new Error("Cannot move a destroyed View in a ViewContainer!");
                        var index = this.indexOf(viewRef);
                        return -1 !== index && this.detach(index), this.insert(viewRef, newIndex), viewRef;
                    }, ViewContainerRef_.prototype.indexOf = function(viewRef) {
                        return this._viewRefs.indexOf(viewRef);
                    }, ViewContainerRef_.prototype.remove = function(index) {
                        var lContainer, removeIndex, view, adjustedIdx = this._adjustIndex(index, -1);
                        view = (lContainer = this._lContainer)[VIEWS][removeIndex = adjustedIdx], detachView(lContainer, removeIndex), 
                        destroyLView(view), this._viewRefs.splice(adjustedIdx, 1);
                    }, ViewContainerRef_.prototype.detach = function(index) {
                        var adjustedIdx = this._adjustIndex(index, -1), view = detachView(this._lContainer, adjustedIdx);
                        return null != this._viewRefs.splice(adjustedIdx, 1)[0] ? new core_ViewRef(view, view[CONTEXT], -1) : null;
                    }, ViewContainerRef_.prototype._adjustIndex = function(index, shift) {
                        return void 0 === shift && (shift = 0), null == index ? this._lContainer[VIEWS].length + shift : index;
                    }, ViewContainerRef_;
                }(ViewContainerRefToken));
                var slotValue = hostView[hostTNode.index];
                if (isLContainer(slotValue)) (lContainer = slotValue)[ACTIVE_INDEX] = -1; else {
                    var commentNode = hostView[RENDERER].createComment("");
                    if (isRootView(hostView)) {
                        var renderer = hostView[RENDERER], hostNative = getNativeByTNode(hostTNode, hostView);
                        nativeInsertBefore(renderer, nativeParentNode(renderer, hostNative), commentNode, function(renderer, node) {
                            return isProceduralRenderer(renderer) ? renderer.nextSibling(node) : node.nextSibling;
                        }(renderer, hostNative));
                    } else appendChild(commentNode, hostTNode, hostView);
                    hostView[hostTNode.index] = lContainer = createLContainer(slotValue, hostView, commentNode, hostTNode, !0), 
                    addToViewTree(hostView, lContainer);
                }
                return new R3ViewContainerRef(lContainer, hostTNode, hostView);
            }(ViewContainerRefToken, ElementRefToken, getPreviousOrParentTNode(), getLView());
        }, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {}, ComponentFactoryResolver$1 = function(_super) {
            function ComponentFactoryResolver(ngModule) {
                var _this = _super.call(this) || this;
                return _this.ngModule = ngModule, _this;
            }
            return __extends(ComponentFactoryResolver, _super), ComponentFactoryResolver.prototype.resolveComponentFactory = function(component) {
                var componentDef = getComponentDef(component);
                return new ComponentFactory$1(componentDef, this.ngModule);
            }, ComponentFactoryResolver;
        }(core_ComponentFactoryResolver);
        function toRefArray(map) {
            var array = [];
            for (var nonMinified in map) map.hasOwnProperty(nonMinified) && array.push({
                propName: map[nonMinified],
                templateName: nonMinified
            });
            return array;
        }
        var ROOT_CONTEXT = new InjectionToken("ROOT_CONTEXT_TOKEN", {
            providedIn: "root",
            factory: function() {
                return createRootContext(inject(SCHEDULER));
            }
        }), SCHEDULER = new InjectionToken("SCHEDULER_TOKEN", {
            providedIn: "root",
            factory: function() {
                return defaultScheduler;
            }
        }), ComponentFactory$1 = function(_super) {
            function ComponentFactory(componentDef, ngModule) {
                var _this = _super.call(this) || this;
                return _this.componentDef = componentDef, _this.ngModule = ngModule, _this.componentType = componentDef.type, 
                _this.selector = componentDef.selectors[0][0], _this.ngContentSelectors = componentDef.ngContentSelectors ? __spread([ "*" ], componentDef.ngContentSelectors) : [], 
                _this.isBoundToModule = !!ngModule, _this;
            }
            return __extends(ComponentFactory, _super), Object.defineProperty(ComponentFactory.prototype, "inputs", {
                get: function() {
                    return toRefArray(this.componentDef.inputs);
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(ComponentFactory.prototype, "outputs", {
                get: function() {
                    return toRefArray(this.componentDef.outputs);
                },
                enumerable: !0,
                configurable: !0
            }), ComponentFactory.prototype.create = function(injector, projectableNodes, rootSelectorOrNode, ngModule) {
                var elementOrSelector, defaultRenderer, isInternalRootView = void 0 === rootSelectorOrNode, rootViewInjector = (ngModule = ngModule || this.ngModule) ? function(rootViewInjector, moduleInjector) {
                    return {
                        get: function(token, notFoundValue, flags) {
                            var value = rootViewInjector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);
                            return value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ? value : moduleInjector.get(token, notFoundValue, flags);
                        }
                    };
                }(injector, ngModule.injector) : injector, rendererFactory = rootViewInjector.get(RendererFactory2, domRendererFactory3), sanitizer = rootViewInjector.get(Sanitizer, null), hostRNode = isInternalRootView ? elementCreate(this.selector, rendererFactory.createRenderer(null, this.componentDef)) : (elementOrSelector = rootSelectorOrNode, 
                defaultRenderer = rendererFactory.createRenderer(null, null), "string" == typeof elementOrSelector ? isProceduralRenderer(defaultRenderer) ? defaultRenderer.selectRootElement(elementOrSelector) : defaultRenderer.querySelector(elementOrSelector) : elementOrSelector), rootFlags = this.componentDef.onPush ? 576 : 528, rootContext = isInternalRootView ? createRootContext() : rootViewInjector.get(ROOT_CONTEXT), renderer = rendererFactory.createRenderer(hostRNode, this.componentDef);
                rootSelectorOrNode && hostRNode && (isProceduralRenderer(renderer) ? renderer.setAttribute(hostRNode, "ng-version", VERSION.full) : hostRNode.setAttribute("ng-version", VERSION.full));
                var component, tElementNode, rootLView = createLView(null, createTView(-1, null, 1, 0, null, null, null, null), rootContext, rootFlags, null, null, rendererFactory, renderer, sanitizer, rootViewInjector), oldLView = enterView(rootLView, null);
                try {
                    var componentView = function(rNode, def, rootView, rendererFactory, renderer, sanitizer) {
                        isParent = !1, previousOrParentTNode = null, elementDepthCount = 0, bindingsEnabled = !0;
                        var tView = rootView[TVIEW], tNode = createNodeAtIndex(0, 3, hostRNode, null, null), componentView = createLView(rootView, getOrCreateTView(def.template, def.consts, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas), null, def.onPush ? 64 : 16, rootView[HEADER_OFFSET], tNode, rendererFactory, renderer, void 0);
                        return tView.firstTemplatePass && (diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, rootView), rootView, def.type), 
                        tNode.flags = 1, initNodeFlags(tNode, rootView.length, 1), queueComponentIndexForCheck(tNode)), 
                        rootView[HEADER_OFFSET] = componentView;
                    }(0, this.componentDef, rootLView, rendererFactory, renderer);
                    tElementNode = getTNode(0, rootLView), projectableNodes && (tElementNode.projection = projectableNodes.map(function(nodesforSlot) {
                        return Array.from(nodesforSlot);
                    })), component = function(componentView, componentDef, rootView, rootContext, hostFeatures) {
                        var tView = rootView[TVIEW], component = function(tView, viewData, def) {
                            var rootTNode = getPreviousOrParentTNode();
                            tView.firstTemplatePass && (def.providersResolver && def.providersResolver(def), 
                            generateExpandoInstructionBlock(tView, rootTNode, 1), baseResolveDirective(tView, viewData, def, def.factory));
                            var directive = getNodeInjectable(tView.data, viewData, viewData.length - 1, rootTNode);
                            return postProcessBaseDirective(viewData, rootTNode, directive), directive;
                        }(tView, rootView, componentDef);
                        rootContext.components.push(component), componentView[CONTEXT] = component, hostFeatures && hostFeatures.forEach(function(feature) {
                            return feature(component, componentDef);
                        }), componentDef.contentQueries && componentDef.contentQueries(1, component, rootView.length - 1);
                        var rootTNode = getPreviousOrParentTNode();
                        if (tView.firstTemplatePass && componentDef.hostBindings && (invokeHostBindingsInCreationMode(componentDef, tView.expandoInstructions, component, rootTNode, tView.firstTemplatePass), 
                        rootTNode.onElementCreationFns && applyOnCreateInstructions(rootTNode)), rootTNode.stylingTemplate) {
                            var native = componentView[HOST];
                            renderInitialClasses(native, rootTNode.stylingTemplate, componentView[RENDERER]), 
                            renderInitialStyles(native, rootTNode.stylingTemplate, componentView[RENDERER]);
                        }
                        return component;
                    }(componentView, this.componentDef, rootLView, rootContext, [ LifecycleHooksFeature ]), 
                    addToViewTree(rootLView, componentView), refreshDescendantViews(rootLView);
                } finally {
                    leaveView(oldLView);
                }
                var componentRef = new ComponentRef$1(this.componentType, component, createElementRef(ElementRef, tElementNode, rootLView), rootLView, tElementNode);
                return isInternalRootView && (componentRef.hostView._tViewNode.child = tElementNode), 
                componentRef;
            }, ComponentFactory;
        }(core_ComponentFactory), ComponentRef$1 = function(_super) {
            function ComponentRef(componentType, instance, location, _rootLView, _tNode) {
                var _this = _super.call(this) || this;
                return _this.location = location, _this._rootLView = _rootLView, _this._tNode = _tNode, 
                _this.destroyCbs = [], _this.instance = instance, _this.hostView = _this.changeDetectorRef = new core_RootViewRef(_rootLView), 
                _this.hostView._tViewNode = assignTViewNodeToLView(_rootLView[TVIEW], null, -1, _rootLView), 
                _this.componentType = componentType, _this;
            }
            return __extends(ComponentRef, _super), Object.defineProperty(ComponentRef.prototype, "injector", {
                get: function() {
                    return new NodeInjector(this._tNode, this._rootLView);
                },
                enumerable: !0,
                configurable: !0
            }), ComponentRef.prototype.destroy = function() {
                this.destroyCbs.forEach(function(fn) {
                    return fn();
                }), this.destroyCbs = null, !this.hostView.destroyed && this.hostView.destroy();
            }, ComponentRef.prototype.onDestroy = function(callback) {
                this.destroyCbs.push(callback);
            }, ComponentRef;
        }(core_ComponentRef), COMPONENT_FACTORY_RESOLVER = {
            provide: core_ComponentFactoryResolver,
            useClass: ComponentFactoryResolver$1,
            deps: [ NgModuleRef ]
        }, core_NgModuleRef$1 = function(_super) {
            function NgModuleRef$1(ngModuleType, _parent) {
                var _this = _super.call(this) || this;
                _this._parent = _parent, _this._bootstrapComponents = [], _this.injector = _this, 
                _this.destroyCbs = [];
                var ngModuleDef = getNgModuleDef(ngModuleType);
                return _this._bootstrapComponents = maybeUnwrapFn(ngModuleDef.bootstrap), _this._r3Injector = function(defType, parent, additionalProviders, name) {
                    return void 0 === parent && (parent = null), void 0 === additionalProviders && (additionalProviders = null), 
                    parent = parent || getNullInjector(), new R3Injector(defType, additionalProviders, parent, name);
                }(ngModuleType, _parent, [ {
                    provide: NgModuleRef,
                    useValue: _this
                }, COMPONENT_FACTORY_RESOLVER ], stringify(ngModuleType)), _this.instance = _this.get(ngModuleType), 
                _this;
            }
            return __extends(NgModuleRef$1, _super), NgModuleRef$1.prototype.get = function(token, notFoundValue, injectFlags) {
                return void 0 === notFoundValue && (notFoundValue = Injector.THROW_IF_NOT_FOUND), 
                void 0 === injectFlags && (injectFlags = InjectFlags.Default), token === Injector || token === NgModuleRef || token === INJECTOR ? this : this._r3Injector.get(token, notFoundValue, injectFlags);
            }, Object.defineProperty(NgModuleRef$1.prototype, "componentFactoryResolver", {
                get: function() {
                    return this.get(core_ComponentFactoryResolver);
                },
                enumerable: !0,
                configurable: !0
            }), NgModuleRef$1.prototype.destroy = function() {
                var injector = this._r3Injector;
                !injector.destroyed && injector.destroy(), this.destroyCbs.forEach(function(fn) {
                    return fn();
                }), this.destroyCbs = null;
            }, NgModuleRef$1.prototype.onDestroy = function(callback) {
                this.destroyCbs.push(callback);
            }, NgModuleRef$1;
        }(NgModuleRef), NgModuleFactory$1 = function(_super) {
            function NgModuleFactory(moduleType) {
                var _this = _super.call(this) || this;
                return _this.moduleType = moduleType, _this;
            }
            return __extends(NgModuleFactory, _super), NgModuleFactory.prototype.create = function(parentInjector) {
                return new core_NgModuleRef$1(this.moduleType, parentInjector);
            }, NgModuleFactory;
        }(core_NgModuleFactory);
        function pureFunction1(slotOffset, pureFn, exp, thisArg) {
            var lView = getLView(), bindingIndex = bindingRootIndex + slotOffset;
            return bindingUpdated(lView, bindingIndex, exp) ? function(lView, bindingIndex, value) {
                return lView[bindingIndex] = value;
            }(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) : function(lView, bindingIndex) {
                return lView[bindingIndex];
            }(lView, bindingIndex + 1);
        }
        var core_EventEmitter = function(_super) {
            function EventEmitter(isAsync) {
                void 0 === isAsync && (isAsync = !1);
                var _this = _super.call(this) || this;
                return _this.__isAsync = isAsync, _this;
            }
            return __extends(EventEmitter, _super), EventEmitter.prototype.emit = function(value) {
                _super.prototype.next.call(this, value);
            }, EventEmitter.prototype.subscribe = function(generatorOrNext, error, complete) {
                var schedulerFn, errorFn = function(err) {
                    return null;
                }, completeFn = function() {
                    return null;
                };
                generatorOrNext && "object" == typeof generatorOrNext ? (schedulerFn = this.__isAsync ? function(value) {
                    setTimeout(function() {
                        return generatorOrNext.next(value);
                    });
                } : function(value) {
                    generatorOrNext.next(value);
                }, generatorOrNext.error && (errorFn = this.__isAsync ? function(err) {
                    setTimeout(function() {
                        return generatorOrNext.error(err);
                    });
                } : function(err) {
                    generatorOrNext.error(err);
                }), generatorOrNext.complete && (completeFn = this.__isAsync ? function() {
                    setTimeout(function() {
                        return generatorOrNext.complete();
                    });
                } : function() {
                    generatorOrNext.complete();
                })) : (schedulerFn = this.__isAsync ? function(value) {
                    setTimeout(function() {
                        return generatorOrNext(value);
                    });
                } : function(value) {
                    generatorOrNext(value);
                }, error && (errorFn = this.__isAsync ? function(err) {
                    setTimeout(function() {
                        return error(err);
                    });
                } : function(err) {
                    error(err);
                }), complete && (completeFn = this.__isAsync ? function() {
                    setTimeout(function() {
                        return complete();
                    });
                } : function() {
                    complete();
                }));
                var sink = _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
                return generatorOrNext instanceof Subscription_Subscription && generatorOrNext.add(sink), 
                sink;
            }, EventEmitter;
        }(Subject_Subject), QueryList = function() {
            function QueryList() {
                this.dirty = !0, this._results = [], this.changes = new core_EventEmitter(), this.length = 0;
            }
            return QueryList.prototype.map = function(fn) {
                return this._results.map(fn);
            }, QueryList.prototype.filter = function(fn) {
                return this._results.filter(fn);
            }, QueryList.prototype.find = function(fn) {
                return this._results.find(fn);
            }, QueryList.prototype.reduce = function(fn, init) {
                return this._results.reduce(fn, init);
            }, QueryList.prototype.forEach = function(fn) {
                this._results.forEach(fn);
            }, QueryList.prototype.some = function(fn) {
                return this._results.some(fn);
            }, QueryList.prototype.toArray = function() {
                return this._results.slice();
            }, QueryList.prototype[core_getSymbolIterator()] = function() {
                return this._results[core_getSymbolIterator()]();
            }, QueryList.prototype.toString = function() {
                return this._results.toString();
            }, QueryList.prototype.reset = function(resultsTree) {
                this._results = function(list) {
                    for (var result = [], i = 0; i < list.length; ) {
                        var item = list[i];
                        Array.isArray(item) ? item.length > 0 ? (list = item.concat(list.slice(i + 1)), 
                        i = 0) : i++ : (result.push(item), i++);
                    }
                    return result;
                }(resultsTree), this.dirty = !1, this.length = this._results.length, this.last = this._results[this.length - 1], 
                this.first = this._results[0];
            }, QueryList.prototype.notifyOnChanges = function() {
                this.changes.emit(this);
            }, QueryList.prototype.setDirty = function() {
                this.dirty = !0;
            }, QueryList.prototype.destroy = function() {
                this.changes.complete(), this.changes.unsubscribe();
            }, QueryList;
        }(), LQueries_ = function() {
            function LQueries_(parent, shallow, deep) {
                this.parent = parent, this.shallow = shallow, this.deep = deep;
            }
            return LQueries_.prototype.track = function(queryList, predicate, descend, read) {
                descend ? this.deep = createQuery(this.deep, queryList, predicate, null != read ? read : null) : this.shallow = createQuery(this.shallow, queryList, predicate, null != read ? read : null);
            }, LQueries_.prototype.clone = function() {
                return new LQueries_(this, null, this.deep);
            }, LQueries_.prototype.container = function() {
                var shallowResults = copyQueriesToContainer(this.shallow), deepResults = copyQueriesToContainer(this.deep);
                return shallowResults || deepResults ? new LQueries_(this, shallowResults, deepResults) : null;
            }, LQueries_.prototype.createView = function() {
                var shallowResults = copyQueriesToView(this.shallow), deepResults = copyQueriesToView(this.deep);
                return shallowResults || deepResults ? new LQueries_(this, shallowResults, deepResults) : null;
            }, LQueries_.prototype.insertView = function(index) {
                insertView$1(index, this.shallow), insertView$1(index, this.deep);
            }, LQueries_.prototype.addNode = function(tNode) {
                add(this.deep, tNode), add(this.shallow, tNode);
            }, LQueries_.prototype.removeView = function() {
                removeView$1(this.shallow), removeView$1(this.deep);
            }, LQueries_;
        }();
        function copyQueriesToContainer(query) {
            for (var result = null; query; ) {
                var containerValues = [];
                query.values.push(containerValues), result = {
                    next: result,
                    list: query.list,
                    predicate: query.predicate,
                    values: containerValues,
                    containerValues: null
                }, query = query.next;
            }
            return result;
        }
        function copyQueriesToView(query) {
            for (var result = null; query; ) result = {
                next: result,
                list: query.list,
                predicate: query.predicate,
                values: [],
                containerValues: query.values
            }, query = query.next;
            return result;
        }
        function insertView$1(index, query) {
            for (;query; ) query.containerValues.splice(index, 0, query.values), query.values.length && query.list.setDirty(), 
            query = query.next;
        }
        function removeView$1(query) {
            for (;query; ) {
                var containerValues = query.containerValues, viewValuesIdx = containerValues.indexOf(query.values);
                containerValues.splice(viewValuesIdx, 1)[0].length && query.list.setDirty(), query = query.next;
            }
        }
        function getIdxOfMatchingSelector(tNode, selector) {
            var localNames = tNode.localNames;
            if (localNames) for (var i = 0; i < localNames.length; i += 2) if (localNames[i] === selector) return localNames[i + 1];
            return null;
        }
        function queryByReadToken(read, tNode, currentView) {
            var factoryFn = read[NG_ELEMENT_ID];
            if ("function" == typeof factoryFn) return factoryFn();
            var matchingIdx = locateDirectiveOrProvider(tNode, currentView, read, !1, !1);
            return null !== matchingIdx ? getNodeInjectable(currentView[TVIEW].data, currentView, matchingIdx, tNode) : null;
        }
        function queryByTemplateRef(templateRefToken, tNode, currentView, read) {
            var templateRefResult = templateRefToken[NG_ELEMENT_ID]();
            return read ? templateRefResult ? queryByReadToken(read, tNode, currentView) : null : templateRefResult;
        }
        function queryRead(tNode, currentView, read, matchingIdx) {
            return read ? queryByReadToken(read, tNode, currentView) : matchingIdx > -1 ? getNodeInjectable(currentView[TVIEW].data, currentView, matchingIdx, tNode) : function(tNode, currentView) {
                return 3 === tNode.type || 4 === tNode.type ? createElementRef(ElementRef, tNode, currentView) : 0 === tNode.type ? createTemplateRef(TemplateRef, ElementRef, tNode, currentView) : null;
            }(tNode, currentView);
        }
        function add(query, tNode) {
            for (var currentView = getLView(); query; ) {
                var predicate = query.predicate, type = predicate.type;
                if (type) {
                    var result = null;
                    type === TemplateRef ? result = queryByTemplateRef(type, tNode, currentView, predicate.read) : null !== (matchingIdx = locateDirectiveOrProvider(tNode, currentView, type, !1, !1)) && (result = queryRead(tNode, currentView, predicate.read, matchingIdx)), 
                    null !== result && addMatch(query, result);
                } else for (var selector = predicate.selector, i = 0; i < selector.length; i++) {
                    var matchingIdx;
                    null !== (matchingIdx = getIdxOfMatchingSelector(tNode, selector[i])) && null !== (result = queryRead(tNode, currentView, predicate.read, matchingIdx)) && addMatch(query, result);
                }
                query = query.next;
            }
        }
        function addMatch(query, matchingValue) {
            query.values.push(matchingValue), query.list.setDirty();
        }
        function createPredicate(predicate, read) {
            var isArray = Array.isArray(predicate);
            return {
                type: isArray ? null : predicate,
                selector: isArray ? predicate : null,
                read: read
            };
        }
        function createQuery(previous, queryList, predicate, read) {
            return {
                next: previous,
                list: queryList,
                predicate: createPredicate(predicate, read),
                values: queryList._valuesTree,
                containerValues: null
            };
        }
        function core_query(predicate, descend, read) {
            var lView = getLView(), queryList = new QueryList(), queries = lView[QUERIES] || (lView[QUERIES] = new LQueries_(null, null, null));
            return queryList._valuesTree = [], queryList._static = !1, queries.track(queryList, predicate, descend, read), 
            function(lView, context, cleanupFn) {
                var lCleanup = getCleanup(lView);
                lCleanup.push(context), lView[TVIEW].firstTemplatePass && getTViewCleanup(lView).push(cleanupFn, lCleanup.length - 1);
            }(lView, queryList, queryList.destroy), queryList;
        }
        function queryRefresh(queryList) {
            var queryListImpl = queryList, creationMode = isCreationMode();
            return !(!queryList.dirty || creationMode !== queryListImpl._static || (queryList.reset(queryListImpl._valuesTree || []), 
            queryList.notifyOnChanges(), 0));
        }
        function viewQuery(predicate, descend, read) {
            var tView = getLView()[TVIEW];
            tView.firstTemplatePass && tView.expandoStartIndex++;
            var index = getCurrentQueryIndex(), viewQuery = core_query(predicate, descend, read);
            return store(index - HEADER_OFFSET, viewQuery), setCurrentQueryIndex(index + 1), 
            viewQuery;
        }
        function loadViewQuery() {
            var index = getCurrentQueryIndex();
            return setCurrentQueryIndex(index + 1), load(index - HEADER_OFFSET);
        }
        function contentQuery(directiveIndex, predicate, descend, read) {
            var lView = getLView(), tView = lView[TVIEW], contentQuery = core_query(predicate, descend, read);
            if ((lView[CONTENT_QUERIES] || (lView[CONTENT_QUERIES] = [])).push(contentQuery), 
            tView.firstTemplatePass) {
                var tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);
                directiveIndex !== (tView.contentQueries.length ? tView.contentQueries[tView.contentQueries.length - 1] : -1) && tViewContentQueries.push(directiveIndex);
            }
            return contentQuery;
        }
        function loadContentQuery() {
            var lView = getLView(), index = getCurrentQueryIndex();
            return setCurrentQueryIndex(index + 1), lView[CONTENT_QUERIES][index];
        }
        function templateRefExtractor(tNode, currentView) {
            return createTemplateRef(TemplateRef, ElementRef, tNode, currentView);
        }
        var NgModuleFactoryLoader = function() {
            return function() {};
        }(), APP_INITIALIZER = new InjectionToken("Application Initializer"), ApplicationInitStatus = function() {
            function ApplicationInitStatus(appInits) {
                var _this = this;
                this.appInits = appInits, this.initialized = !1, this.done = !1, this.donePromise = new Promise(function(res, rej) {
                    _this.resolve = res, _this.reject = rej;
                });
            }
            return ApplicationInitStatus.prototype.runInitializers = function() {
                var _this = this;
                if (!this.initialized) {
                    var asyncInitPromises = [], complete = function() {
                        _this.done = !0, _this.resolve();
                    };
                    if (this.appInits) for (var i = 0; i < this.appInits.length; i++) {
                        var initResult = this.appInits[i]();
                        core_isPromise(initResult) && asyncInitPromises.push(initResult);
                    }
                    Promise.all(asyncInitPromises).then(function() {
                        complete();
                    }).catch(function(e) {
                        _this.reject(e);
                    }), 0 === asyncInitPromises.length && complete(), this.initialized = !0;
                }
            }, ApplicationInitStatus.ngInjectableDef = defineInjectable({
                token: ApplicationInitStatus,
                factory: function(t) {
                    return new (t || ApplicationInitStatus)(inject(APP_INITIALIZER, 8));
                },
                providedIn: null
            }), ApplicationInitStatus;
        }(), APP_ID = new InjectionToken("AppId"), APP_ID_RANDOM_PROVIDER = {
            provide: APP_ID,
            useFactory: function() {
                return "" + _randomChar() + _randomChar() + _randomChar();
            },
            deps: []
        };
        function _randomChar() {
            return String.fromCharCode(97 + Math.floor(25 * Math.random()));
        }
        var trace, core_events, PLATFORM_INITIALIZER = new InjectionToken("Platform Initializer"), PLATFORM_ID = new InjectionToken("Platform ID"), APP_BOOTSTRAP_LISTENER = new InjectionToken("appBootstrapListener"), Console = function() {
            function Console() {}
            return Console.prototype.log = function(message) {
                console.log(message);
            }, Console.prototype.warn = function(message) {
                console.warn(message);
            }, Console.ngInjectableDef = defineInjectable({
                token: Console,
                factory: function(t) {
                    return new (t || Console)();
                },
                providedIn: null
            }), Console;
        }(), ModuleWithComponentFactories = function() {
            return function(ngModuleFactory, componentFactories) {
                this.ngModuleFactory = ngModuleFactory, this.componentFactories = componentFactories;
            };
        }(), Compiler_compileModuleSync__POST_R3__ = function(moduleType) {
            return new NgModuleFactory$1(moduleType);
        }, Compiler_compileModuleSync = Compiler_compileModuleSync__POST_R3__, Compiler_compileModuleAsync = function(moduleType) {
            return Promise.resolve(Compiler_compileModuleSync__POST_R3__(moduleType));
        }, Compiler_compileModuleAndAllComponentsSync__POST_R3__ = function(moduleType) {
            var ngModuleFactory = Compiler_compileModuleSync__POST_R3__(moduleType), componentFactories = maybeUnwrapFn(getNgModuleDef(moduleType).declarations).reduce(function(factories, declaration) {
                var componentDef = getComponentDef(declaration);
                return componentDef && factories.push(new ComponentFactory$1(componentDef)), factories;
            }, []);
            return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
        }, Compiler_compileModuleAndAllComponentsSync = Compiler_compileModuleAndAllComponentsSync__POST_R3__, Compiler_compileModuleAndAllComponentsAsync = function(moduleType) {
            return Promise.resolve(Compiler_compileModuleAndAllComponentsSync__POST_R3__(moduleType));
        }, Compiler = function() {
            function Compiler() {
                this.compileModuleSync = Compiler_compileModuleSync, this.compileModuleAsync = Compiler_compileModuleAsync, 
                this.compileModuleAndAllComponentsSync = Compiler_compileModuleAndAllComponentsSync, 
                this.compileModuleAndAllComponentsAsync = Compiler_compileModuleAndAllComponentsAsync;
            }
            return Compiler.prototype.clearCache = function() {}, Compiler.prototype.clearCacheFor = function(type) {}, 
            Compiler.prototype.getModuleId = function(moduleType) {}, Compiler.ngInjectableDef = defineInjectable({
                token: Compiler,
                factory: function(t) {
                    return new (t || Compiler)();
                },
                providedIn: null
            }), Compiler;
        }(), COMPILER_OPTIONS = new InjectionToken("compilerOptions");
        function detectWTF() {
            var wtf = _global.wtf;
            return !(!wtf || !(trace = wtf.trace) || (core_events = trace.events, 0));
        }
        var wtfEnabled = detectWTF();
        function noopScope(arg0, arg1) {
            return null;
        }
        var wtfCreateScope = wtfEnabled ? function(signature, flags) {
            return void 0 === flags && (flags = null), core_events.createScope(signature, flags);
        } : function(signature, flags) {
            return noopScope;
        }, wtfLeave = wtfEnabled ? function(scope, returnValue) {
            return trace.leaveScope(scope, returnValue), returnValue;
        } : function(s, r) {
            return r;
        }, core_promise = Promise.resolve(0);
        function scheduleMicroTask(fn) {
            "undefined" == typeof Zone ? core_promise.then(function() {
                fn && fn.apply(null, null);
            }) : Zone.current.scheduleMicroTask("scheduleMicrotask", fn);
        }
        var NgZone = function() {
            function NgZone(_a) {
                var zone, _b = _a.enableLongStackTrace, enableLongStackTrace = void 0 !== _b && _b;
                if (this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, 
                this.onUnstable = new core_EventEmitter(!1), this.onMicrotaskEmpty = new core_EventEmitter(!1), 
                this.onStable = new core_EventEmitter(!1), this.onError = new core_EventEmitter(!1), 
                "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js");
                Zone.assertZonePatched(), this._nesting = 0, this._outer = this._inner = Zone.current, 
                Zone.wtfZoneSpec && (this._inner = this._inner.fork(Zone.wtfZoneSpec)), Zone.TaskTrackingZoneSpec && (this._inner = this._inner.fork(new Zone.TaskTrackingZoneSpec())), 
                enableLongStackTrace && Zone.longStackTraceZoneSpec && (this._inner = this._inner.fork(Zone.longStackTraceZoneSpec)), 
                (zone = this)._inner = zone._inner.fork({
                    name: "angular",
                    properties: {
                        isAngularZone: !0
                    },
                    onInvokeTask: function(delegate, current, target, task, applyThis, applyArgs) {
                        try {
                            return onEnter(zone), delegate.invokeTask(target, task, applyThis, applyArgs);
                        } finally {
                            onLeave(zone);
                        }
                    },
                    onInvoke: function(delegate, current, target, callback, applyThis, applyArgs, source) {
                        try {
                            return onEnter(zone), delegate.invoke(target, callback, applyThis, applyArgs, source);
                        } finally {
                            onLeave(zone);
                        }
                    },
                    onHasTask: function(delegate, current, target, hasTaskState) {
                        delegate.hasTask(target, hasTaskState), current === target && ("microTask" == hasTaskState.change ? (zone.hasPendingMicrotasks = hasTaskState.microTask, 
                        checkStable(zone)) : "macroTask" == hasTaskState.change && (zone.hasPendingMacrotasks = hasTaskState.macroTask));
                    },
                    onHandleError: function(delegate, current, target, error) {
                        return delegate.handleError(target, error), zone.runOutsideAngular(function() {
                            return zone.onError.emit(error);
                        }), !1;
                    }
                });
            }
            return NgZone.isInAngularZone = function() {
                return !0 === Zone.current.get("isAngularZone");
            }, NgZone.assertInAngularZone = function() {
                if (!NgZone.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!");
            }, NgZone.assertNotInAngularZone = function() {
                if (NgZone.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!");
            }, NgZone.prototype.run = function(fn, applyThis, applyArgs) {
                return this._inner.run(fn, applyThis, applyArgs);
            }, NgZone.prototype.runTask = function(fn, applyThis, applyArgs, name) {
                var zone = this._inner, task = zone.scheduleEventTask("NgZoneEvent: " + name, fn, EMPTY_PAYLOAD, noop$1, noop$1);
                try {
                    return zone.runTask(task, applyThis, applyArgs);
                } finally {
                    zone.cancelTask(task);
                }
            }, NgZone.prototype.runGuarded = function(fn, applyThis, applyArgs) {
                return this._inner.runGuarded(fn, applyThis, applyArgs);
            }, NgZone.prototype.runOutsideAngular = function(fn) {
                return this._outer.run(fn);
            }, NgZone;
        }();
        function noop$1() {}
        var EMPTY_PAYLOAD = {};
        function checkStable(zone) {
            if (0 == zone._nesting && !zone.hasPendingMicrotasks && !zone.isStable) try {
                zone._nesting++, zone.onMicrotaskEmpty.emit(null);
            } finally {
                if (zone._nesting--, !zone.hasPendingMicrotasks) try {
                    zone.runOutsideAngular(function() {
                        return zone.onStable.emit(null);
                    });
                } finally {
                    zone.isStable = !0;
                }
            }
        }
        function onEnter(zone) {
            zone._nesting++, zone.isStable && (zone.isStable = !1, zone.onUnstable.emit(null));
        }
        function onLeave(zone) {
            zone._nesting--, checkStable(zone);
        }
        var core_platform, NoopNgZone = function() {
            function NoopNgZone() {
                this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, 
                this.onUnstable = new core_EventEmitter(), this.onMicrotaskEmpty = new core_EventEmitter(), 
                this.onStable = new core_EventEmitter(), this.onError = new core_EventEmitter();
            }
            return NoopNgZone.prototype.run = function(fn) {
                return fn();
            }, NoopNgZone.prototype.runGuarded = function(fn) {
                return fn();
            }, NoopNgZone.prototype.runOutsideAngular = function(fn) {
                return fn();
            }, NoopNgZone.prototype.runTask = function(fn) {
                return fn();
            }, NoopNgZone;
        }(), Testability = function() {
            function Testability(_ngZone) {
                var _this = this;
                this._ngZone = _ngZone, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, 
                this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), 
                _ngZone.run(function() {
                    _this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone");
                });
            }
            return Testability.prototype._watchAngularEvents = function() {
                var _this = this;
                this._ngZone.onUnstable.subscribe({
                    next: function() {
                        _this._didWork = !0, _this._isZoneStable = !1;
                    }
                }), this._ngZone.runOutsideAngular(function() {
                    _this._ngZone.onStable.subscribe({
                        next: function() {
                            NgZone.assertNotInAngularZone(), scheduleMicroTask(function() {
                                _this._isZoneStable = !0, _this._runCallbacksIfReady();
                            });
                        }
                    });
                });
            }, Testability.prototype.increasePendingRequestCount = function() {
                return this._pendingCount += 1, this._didWork = !0, this._pendingCount;
            }, Testability.prototype.decreasePendingRequestCount = function() {
                if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero");
                return this._runCallbacksIfReady(), this._pendingCount;
            }, Testability.prototype.isStable = function() {
                return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks;
            }, Testability.prototype._runCallbacksIfReady = function() {
                var _this = this;
                if (this.isStable()) scheduleMicroTask(function() {
                    for (;0 !== _this._callbacks.length; ) {
                        var cb = _this._callbacks.pop();
                        clearTimeout(cb.timeoutId), cb.doneCb(_this._didWork);
                    }
                    _this._didWork = !1;
                }); else {
                    var pending_1 = this.getPendingTasks();
                    this._callbacks = this._callbacks.filter(function(cb) {
                        return !cb.updateCb || !cb.updateCb(pending_1) || (clearTimeout(cb.timeoutId), !1);
                    }), this._didWork = !0;
                }
            }, Testability.prototype.getPendingTasks = function() {
                return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(function(t) {
                    return {
                        source: t.source,
                        creationLocation: t.creationLocation,
                        data: t.data
                    };
                }) : [];
            }, Testability.prototype.addCallback = function(cb, timeout, updateCb) {
                var _this = this, timeoutId = -1;
                timeout && timeout > 0 && (timeoutId = setTimeout(function() {
                    _this._callbacks = _this._callbacks.filter(function(cb) {
                        return cb.timeoutId !== timeoutId;
                    }), cb(_this._didWork, _this.getPendingTasks());
                }, timeout)), this._callbacks.push({
                    doneCb: cb,
                    timeoutId: timeoutId,
                    updateCb: updateCb
                });
            }, Testability.prototype.whenStable = function(doneCb, timeout, updateCb) {
                if (updateCb && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?');
                this.addCallback(doneCb, timeout, updateCb), this._runCallbacksIfReady();
            }, Testability.prototype.getPendingRequestCount = function() {
                return this._pendingCount;
            }, Testability.prototype.findProviders = function(using, provider, exactMatch) {
                return [];
            }, Testability.ngInjectableDef = defineInjectable({
                token: Testability,
                factory: function(t) {
                    return new (t || Testability)(inject(NgZone));
                },
                providedIn: null
            }), Testability;
        }(), core_TestabilityRegistry = function() {
            function TestabilityRegistry() {
                this._applications = new Map(), _testabilityGetter.addToWindow(this);
            }
            return TestabilityRegistry.prototype.registerApplication = function(token, testability) {
                this._applications.set(token, testability);
            }, TestabilityRegistry.prototype.unregisterApplication = function(token) {
                this._applications.delete(token);
            }, TestabilityRegistry.prototype.unregisterAllApplications = function() {
                this._applications.clear();
            }, TestabilityRegistry.prototype.getTestability = function(elem) {
                return this._applications.get(elem) || null;
            }, TestabilityRegistry.prototype.getAllTestabilities = function() {
                return Array.from(this._applications.values());
            }, TestabilityRegistry.prototype.getAllRootElements = function() {
                return Array.from(this._applications.keys());
            }, TestabilityRegistry.prototype.findTestabilityInTree = function(elem, findInAncestors) {
                return void 0 === findInAncestors && (findInAncestors = !0), _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
            }, (TestabilityRegistry = __decorate([ __metadata("design:paramtypes", []) ], TestabilityRegistry)).ngInjectableDef = defineInjectable({
                token: TestabilityRegistry,
                factory: function(t) {
                    return new (t || TestabilityRegistry)();
                },
                providedIn: null
            }), TestabilityRegistry;
        }(), _testabilityGetter = new (function() {
            function _NoopGetTestability() {}
            return _NoopGetTestability.prototype.addToWindow = function(registry) {}, _NoopGetTestability.prototype.findTestabilityInTree = function(registry, elem, findInAncestors) {
                return null;
            }, _NoopGetTestability;
        }())(), ALLOW_MULTIPLE_PLATFORMS = new InjectionToken("AllowMultipleToken"), NgProbeToken = function() {
            return function(name, token) {
                this.name = name, this.token = token;
            };
        }();
        function createPlatformFactory(parentPlatformFactory, name, providers) {
            void 0 === providers && (providers = []);
            var desc = "Platform: " + name, marker = new InjectionToken(desc);
            return function(extraProviders) {
                void 0 === extraProviders && (extraProviders = []);
                var platform = getPlatform();
                if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, !1)) if (parentPlatformFactory) parentPlatformFactory(providers.concat(extraProviders).concat({
                    provide: marker,
                    useValue: !0
                })); else {
                    var injectedProviders = providers.concat(extraProviders).concat({
                        provide: marker,
                        useValue: !0
                    });
                    !function(injector) {
                        if (core_platform && !core_platform.destroyed && !core_platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, !1)) throw new Error("There can be only one platform. Destroy the previous one to create a new one.");
                        core_platform = injector.get(PlatformRef);
                        var inits = injector.get(PLATFORM_INITIALIZER, null);
                        inits && inits.forEach(function(init) {
                            return init();
                        });
                    }(Injector.create({
                        providers: injectedProviders,
                        name: desc
                    }));
                }
                return function(requiredToken) {
                    var platform = getPlatform();
                    if (!platform) throw new Error("No platform exists!");
                    if (!platform.injector.get(requiredToken, null)) throw new Error("A platform with a different configuration has been created. Please destroy it first.");
                    return platform;
                }(marker);
            };
        }
        function getPlatform() {
            return core_platform && !core_platform.destroyed ? core_platform : null;
        }
        var PlatformRef = function() {
            function PlatformRef(_injector) {
                this._injector = _injector, this._modules = [], this._destroyListeners = [], this._destroyed = !1;
            }
            return PlatformRef.prototype.bootstrapModuleFactory = function(moduleFactory, options) {
                var ngZoneOption, _this = this, ngZone = "noop" === (ngZoneOption = options ? options.ngZone : void 0) ? new NoopNgZone() : ("zone.js" === ngZoneOption ? void 0 : ngZoneOption) || new NgZone({
                    enableLongStackTrace: isDevMode()
                }), providers = [ {
                    provide: NgZone,
                    useValue: ngZone
                } ];
                return ngZone.run(function() {
                    var ngZoneInjector = Injector.create({
                        providers: providers,
                        parent: _this.injector,
                        name: moduleFactory.moduleType.name
                    }), moduleRef = moduleFactory.create(ngZoneInjector), exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
                    if (!exceptionHandler) throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?");
                    return moduleRef.onDestroy(function() {
                        return remove(_this._modules, moduleRef);
                    }), ngZone.runOutsideAngular(function() {
                        return ngZone.onError.subscribe({
                            next: function(error) {
                                exceptionHandler.handleError(error);
                            }
                        });
                    }), function(errorHandler, ngZone, callback) {
                        try {
                            var result = ((initStatus = moduleRef.injector.get(ApplicationInitStatus)).runInitializers(), 
                            initStatus.donePromise.then(function() {
                                return _this._moduleDoBootstrap(moduleRef), moduleRef;
                            }));
                            return core_isPromise(result) ? result.catch(function(e) {
                                throw ngZone.runOutsideAngular(function() {
                                    return errorHandler.handleError(e);
                                }), e;
                            }) : result;
                        } catch (e) {
                            throw ngZone.runOutsideAngular(function() {
                                return errorHandler.handleError(e);
                            }), e;
                        }
                        var initStatus;
                    }(exceptionHandler, ngZone);
                });
            }, PlatformRef.prototype.bootstrapModule = function(moduleType, compilerOptions) {
                var _this = this;
                void 0 === compilerOptions && (compilerOptions = []);
                var options = optionsReducer({}, compilerOptions);
                return function(injector, options, moduleType) {
                    var moduleFactory = new NgModuleFactory$1(moduleType);
                    if (0 === componentResourceResolutionQueue.size) return Promise.resolve(moduleFactory);
                    var parts, result, compilerProviders = (parts = injector.get(COMPILER_OPTIONS, []).concat(options).map(function(o) {
                        return o.providers;
                    }), result = [], parts.forEach(function(part) {
                        return part && result.push.apply(result, __spread(part));
                    }), result);
                    if (0 === compilerProviders.length) return Promise.resolve(moduleFactory);
                    var compiler = function() {
                        var globalNg = _global.ng;
                        if (!globalNg || !globalNg.\u0275compilerFacade) throw new Error("Angular JIT compilation failed: '@angular/compiler' not loaded!\n  - JIT compilation is discouraged for production use-cases! Consider AOT mode instead.\n  - Did you bootstrap using '@angular/platform-browser-dynamic' or '@angular/platform-server'?\n  - Alternatively provide the compiler with 'import \"@angular/compiler\";' before bootstrapping.");
                        return globalNg.\u0275compilerFacade;
                    }(), resourceLoader = Injector.create({
                        providers: compilerProviders
                    }).get(compiler.ResourceLoader);
                    return function(resourceResolver) {
                        var componentResolved = [], urlMap = new Map();
                        function cachedResourceResolve(url) {
                            var promise = urlMap.get(url);
                            if (!promise) {
                                var resp = resourceResolver(url);
                                urlMap.set(url, promise = resp.then(unwrapResponse));
                            }
                            return promise;
                        }
                        return componentResourceResolutionQueue.forEach(function(component, type) {
                            var promises = [];
                            component.templateUrl && promises.push(cachedResourceResolve(component.templateUrl).then(function(template) {
                                component.template = template;
                            }));
                            var styleUrls = component.styleUrls, styles = component.styles || (component.styles = []), styleOffset = component.styles.length;
                            styleUrls && styleUrls.forEach(function(styleUrl, index) {
                                styles.push(""), promises.push(cachedResourceResolve(styleUrl).then(function(style) {
                                    styles[styleOffset + index] = style, styleUrls.splice(styleUrls.indexOf(styleUrl), 1), 
                                    0 == styleUrls.length && (component.styleUrls = void 0);
                                }));
                            });
                            var fullyResolved = Promise.all(promises).then(function() {
                                return function(type) {
                                    componentDefPendingResolution.delete(type);
                                }(type);
                            });
                            componentResolved.push(fullyResolved);
                        }), componentResourceResolutionQueue = new Map(), Promise.all(componentResolved).then(function() {});
                    }(function(url) {
                        return Promise.resolve(resourceLoader.get(url));
                    }).then(function() {
                        return moduleFactory;
                    });
                }(this.injector, options, moduleType).then(function(moduleFactory) {
                    return _this.bootstrapModuleFactory(moduleFactory, options);
                });
            }, PlatformRef.prototype._moduleDoBootstrap = function(moduleRef) {
                var appRef = moduleRef.injector.get(core_ApplicationRef);
                if (moduleRef._bootstrapComponents.length > 0) moduleRef._bootstrapComponents.forEach(function(f) {
                    return appRef.bootstrap(f);
                }); else {
                    if (!moduleRef.instance.ngDoBootstrap) throw new Error("The module " + stringify(moduleRef.instance.constructor) + ' was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.');
                    moduleRef.instance.ngDoBootstrap(appRef);
                }
                this._modules.push(moduleRef);
            }, PlatformRef.prototype.onDestroy = function(callback) {
                this._destroyListeners.push(callback);
            }, Object.defineProperty(PlatformRef.prototype, "injector", {
                get: function() {
                    return this._injector;
                },
                enumerable: !0,
                configurable: !0
            }), PlatformRef.prototype.destroy = function() {
                if (this._destroyed) throw new Error("The platform has already been destroyed!");
                this._modules.slice().forEach(function(module) {
                    return module.destroy();
                }), this._destroyListeners.forEach(function(listener) {
                    return listener();
                }), this._destroyed = !0;
            }, Object.defineProperty(PlatformRef.prototype, "destroyed", {
                get: function() {
                    return this._destroyed;
                },
                enumerable: !0,
                configurable: !0
            }), PlatformRef.ngInjectableDef = defineInjectable({
                token: PlatformRef,
                factory: function(t) {
                    return new (t || PlatformRef)(inject(Injector));
                },
                providedIn: null
            }), PlatformRef;
        }();
        function optionsReducer(dst, objs) {
            return Array.isArray(objs) ? objs.reduce(optionsReducer, dst) : __assign({}, dst, objs);
        }
        var core_ApplicationRef = function() {
            function ApplicationRef(_zone, _console, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus) {
                var _this = this;
                this._zone = _zone, this._console = _console, this._injector = _injector, this._exceptionHandler = _exceptionHandler, 
                this._componentFactoryResolver = _componentFactoryResolver, this._initStatus = _initStatus, 
                this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._enforceNoNewChanges = !1, 
                this._stable = !0, this.componentTypes = [], this.components = [], this._enforceNoNewChanges = isDevMode(), 
                this._zone.onMicrotaskEmpty.subscribe({
                    next: function() {
                        _this._zone.run(function() {
                            _this.tick();
                        });
                    }
                });
                var isCurrentlyStable = new Observable_Observable(function(observer) {
                    _this._stable = _this._zone.isStable && !_this._zone.hasPendingMacrotasks && !_this._zone.hasPendingMicrotasks, 
                    _this._zone.runOutsideAngular(function() {
                        observer.next(_this._stable), observer.complete();
                    });
                }), isStable = new Observable_Observable(function(observer) {
                    var stableSub;
                    _this._zone.runOutsideAngular(function() {
                        stableSub = _this._zone.onStable.subscribe(function() {
                            NgZone.assertNotInAngularZone(), scheduleMicroTask(function() {
                                _this._stable || _this._zone.hasPendingMacrotasks || _this._zone.hasPendingMicrotasks || (_this._stable = !0, 
                                observer.next(!0));
                            });
                        });
                    });
                    var unstableSub = _this._zone.onUnstable.subscribe(function() {
                        NgZone.assertInAngularZone(), _this._stable && (_this._stable = !1, _this._zone.runOutsideAngular(function() {
                            observer.next(!1);
                        }));
                    });
                    return function() {
                        stableSub.unsubscribe(), unstableSub.unsubscribe();
                    };
                });
                this.isStable = merge(isCurrentlyStable, isStable.pipe(share()));
            }
            var ApplicationRef_1;
            return ApplicationRef_1 = ApplicationRef, ApplicationRef.prototype.bootstrap = function(componentOrFactory, rootSelectorOrNode) {
                var componentFactory, _this = this;
                if (!this._initStatus.done) throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.");
                componentFactory = componentOrFactory instanceof core_ComponentFactory ? componentOrFactory : this._componentFactoryResolver.resolveComponentFactory(componentOrFactory), 
                this.componentTypes.push(componentFactory.componentType);
                var ngModule = componentFactory.isBoundToModule ? null : this._injector.get(NgModuleRef), compRef = componentFactory.create(Injector.NULL, [], rootSelectorOrNode || componentFactory.selector, ngModule);
                compRef.onDestroy(function() {
                    _this._unloadComponent(compRef);
                });
                var testability = compRef.injector.get(Testability, null);
                return testability && compRef.injector.get(core_TestabilityRegistry).registerApplication(compRef.location.nativeElement, testability), 
                this._loadComponent(compRef), isDevMode() && this._console.log("Angular is running in the development mode. Call enableProdMode() to enable the production mode."), 
                compRef;
            }, ApplicationRef.prototype.tick = function() {
                var e_1, _a, e_2, _b, _this = this;
                if (this._runningTick) throw new Error("ApplicationRef.tick is called recursively");
                var scope = ApplicationRef_1._tickScope();
                try {
                    this._runningTick = !0;
                    try {
                        for (var _c = __values(this._views), _d = _c.next(); !_d.done; _d = _c.next()) _d.value.detectChanges();
                    } catch (e_1_1) {
                        e_1 = {
                            error: e_1_1
                        };
                    } finally {
                        try {
                            _d && !_d.done && (_a = _c.return) && _a.call(_c);
                        } finally {
                            if (e_1) throw e_1.error;
                        }
                    }
                    if (this._enforceNoNewChanges) try {
                        for (var _e = __values(this._views), _f = _e.next(); !_f.done; _f = _e.next()) _f.value.checkNoChanges();
                    } catch (e_2_1) {
                        e_2 = {
                            error: e_2_1
                        };
                    } finally {
                        try {
                            _f && !_f.done && (_b = _e.return) && _b.call(_e);
                        } finally {
                            if (e_2) throw e_2.error;
                        }
                    }
                } catch (e) {
                    this._zone.runOutsideAngular(function() {
                        return _this._exceptionHandler.handleError(e);
                    });
                } finally {
                    this._runningTick = !1, wtfLeave(scope);
                }
            }, ApplicationRef.prototype.attachView = function(viewRef) {
                var view = viewRef;
                this._views.push(view), view.attachToAppRef(this);
            }, ApplicationRef.prototype.detachView = function(viewRef) {
                var view = viewRef;
                remove(this._views, view), view.detachFromAppRef();
            }, ApplicationRef.prototype._loadComponent = function(componentRef) {
                this.attachView(componentRef.hostView), this.tick(), this.components.push(componentRef), 
                this._injector.get(APP_BOOTSTRAP_LISTENER, []).concat(this._bootstrapListeners).forEach(function(listener) {
                    return listener(componentRef);
                });
            }, ApplicationRef.prototype._unloadComponent = function(componentRef) {
                this.detachView(componentRef.hostView), remove(this.components, componentRef);
            }, ApplicationRef.prototype.ngOnDestroy = function() {
                this._views.slice().forEach(function(view) {
                    return view.destroy();
                });
            }, Object.defineProperty(ApplicationRef.prototype, "viewCount", {
                get: function() {
                    return this._views.length;
                },
                enumerable: !0,
                configurable: !0
            }), ApplicationRef._tickScope = wtfCreateScope("ApplicationRef#tick()"), ApplicationRef.ngInjectableDef = defineInjectable({
                token: ApplicationRef,
                factory: function(t) {
                    return new (t || ApplicationRef)(inject(NgZone), inject(Console), inject(Injector), inject(ErrorHandler), inject(core_ComponentFactoryResolver), inject(ApplicationInitStatus));
                },
                providedIn: null
            }), ApplicationRef;
        }();
        function remove(list, el) {
            var index = list.indexOf(el);
            index > -1 && list.splice(index, 1);
        }
        var SystemJsNgModuleLoaderConfig = function() {
            return function() {};
        }(), DEFAULT_CONFIG = {
            factoryPathPrefix: "",
            factoryPathSuffix: ".ngfactory"
        }, core_SystemJsNgModuleLoader = function() {
            function SystemJsNgModuleLoader(_compiler, config) {
                this._compiler = _compiler, this._config = config || DEFAULT_CONFIG;
            }
            return SystemJsNgModuleLoader.prototype.load = function(path) {
                return this._compiler instanceof Compiler ? this.loadFactory(path) : this.loadAndCompile(path);
            }, SystemJsNgModuleLoader.prototype.loadAndCompile = function(path) {
                var _this = this, _a = __read(path.split("#"), 2), module = _a[0], exportName = _a[1];
                return void 0 === exportName && (exportName = "default"), __webpack_require__("crnd")(module).then(function(module) {
                    return module[exportName];
                }).then(function(type) {
                    return checkNotEmpty(type, module, exportName);
                }).then(function(type) {
                    return _this._compiler.compileModuleAsync(type);
                });
            }, SystemJsNgModuleLoader.prototype.loadFactory = function(path) {
                var _a = __read(path.split("#"), 2), module = _a[0], exportName = _a[1], factoryClassSuffix = "NgFactory";
                return void 0 === exportName && (exportName = "default", factoryClassSuffix = ""), 
                __webpack_require__("crnd")(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix).then(function(module) {
                    return module[exportName + factoryClassSuffix];
                }).then(function(factory) {
                    return checkNotEmpty(factory, module, exportName);
                });
            }, SystemJsNgModuleLoader.ngInjectableDef = defineInjectable({
                token: SystemJsNgModuleLoader,
                factory: function(t) {
                    return new (t || SystemJsNgModuleLoader)(inject(Compiler), inject(SystemJsNgModuleLoaderConfig, 8));
                },
                providedIn: null
            }), SystemJsNgModuleLoader;
        }();
        function checkNotEmpty(value, modulePath, exportName) {
            if (!value) throw new Error("Cannot find '" + exportName + "' in '" + modulePath + "'");
            return value;
        }
        var DebugNode__POST_R3__ = function() {
            function DebugNode__POST_R3__(nativeNode) {
                this.nativeNode = nativeNode;
            }
            return Object.defineProperty(DebugNode__POST_R3__.prototype, "parent", {
                get: function() {
                    var parent = this.nativeNode.parentNode;
                    return parent ? new core_DebugElement_POST_R3_(parent) : null;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(DebugNode__POST_R3__.prototype, "injector", {
                get: function() {
                    return context = loadLContext(this.nativeNode), new NodeInjector(context.lView[TVIEW].data[context.nodeIndex], context.lView);
                    var context;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(DebugNode__POST_R3__.prototype, "componentInstance", {
                get: function() {
                    var lView, tNode, context, nativeElement = this.nativeNode;
                    return nativeElement && (void 0 === (context = loadLContextFromNode(nativeElement)).component && (context.component = 1 & (tNode = (lView = context.lView)[TVIEW].data[context.nodeIndex]).flags ? lView[tNode.directiveStart] : null), 
                    context.component || function(element) {
                        for (var parent, lView = loadLContext(nativeElement).lView; null === lView[HOST] && (parent = getLViewParent(lView)); ) lView = parent;
                        return 512 & lView[FLAGS] ? null : lView[CONTEXT];
                    }());
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(DebugNode__POST_R3__.prototype, "context", {
                get: function() {
                    return loadLContextFromNode(this.nativeNode).lView[CONTEXT];
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(DebugNode__POST_R3__.prototype, "listeners", {
                get: function() {
                    return function(element) {
                        var lView = loadLContextFromNode(element).lView, lCleanup = lView[CLEANUP], tCleanup = lView[TVIEW].cleanup, listeners = [];
                        if (tCleanup && lCleanup) for (var i = 0; i < tCleanup.length; ) {
                            var firstParam = tCleanup[i++], secondParam = tCleanup[i++];
                            if ("string" == typeof firstParam) {
                                var name_1 = firstParam, listenerElement = unwrapRNode(lView[secondParam]), callback = lCleanup[tCleanup[i++]], useCaptureOrIndx = tCleanup[i++];
                                element == listenerElement && listeners.push({
                                    element: element,
                                    name: name_1,
                                    callback: callback,
                                    useCapture: "boolean" == typeof useCaptureOrIndx ? useCaptureOrIndx : !(useCaptureOrIndx >= 0) && null
                                });
                            }
                        }
                        return listeners.sort(sortListeners), listeners;
                    }(this.nativeNode).filter(isBrowserEvents);
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(DebugNode__POST_R3__.prototype, "references", {
                get: function() {
                    return void 0 === (context = loadLContext(this.nativeNode)).localRefs && (context.localRefs = function(lView, nodeIndex) {
                        var tNode = lView[TVIEW].data[context.nodeIndex];
                        if (tNode && tNode.localNames) {
                            for (var result = {}, localIndex = tNode.index + 1, i = 0; i < tNode.localNames.length; i += 2) result[tNode.localNames[i]] = lView[localIndex], 
                            localIndex++;
                            return result;
                        }
                        return null;
                    }(context.lView)), context.localRefs || {};
                    var context;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(DebugNode__POST_R3__.prototype, "providerTokens", {
                get: function() {
                    return function(element) {
                        var context = loadLContext(element, !1);
                        if (!context) return [];
                        for (var obj, tView = context.lView[TVIEW], tNode = tView.data[context.nodeIndex], providerTokens = [], endIndex = tNode.directiveEnd, i = 65535 & tNode.providerIndexes; i < endIndex; i++) {
                            var value = tView.data[i];
                            void 0 !== (obj = value).type && void 0 !== obj.template && void 0 !== obj.declaredInputs && (value = value.type), 
                            providerTokens.push(value);
                        }
                        return providerTokens;
                    }(this.nativeNode);
                },
                enumerable: !0,
                configurable: !0
            }), DebugNode__POST_R3__;
        }(), core_DebugElement_POST_R3_ = function(_super) {
            function DebugElement__POST_R3__(nativeNode) {
                return _super.call(this, nativeNode) || this;
            }
            return __extends(DebugElement__POST_R3__, _super), Object.defineProperty(DebugElement__POST_R3__.prototype, "nativeElement", {
                get: function() {
                    return this.nativeNode.nodeType == Node.ELEMENT_NODE ? this.nativeNode : null;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(DebugElement__POST_R3__.prototype, "name", {
                get: function() {
                    return this.nativeElement.nodeName;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(DebugElement__POST_R3__.prototype, "properties", {
                get: function() {
                    var context = loadLContext(this.nativeNode), lView = context.lView, tData = lView[TVIEW].data, tNode = tData[context.nodeIndex], properties = function(tNode, lView, tData) {
                        for (var properties = {}, bindingIndex = function(metadataIndex, tData) {
                            for (var currentBindingIndex = tNode.propertyMetadataStartIndex - 1, currentValue = tData[currentBindingIndex]; "string" == typeof currentValue && !isPropMetadataString(currentValue); ) currentValue = tData[--currentBindingIndex];
                            return currentBindingIndex + 1;
                        }(0, tData); bindingIndex < tNode.propertyMetadataEndIndex; ) {
                            for (var value = "", propMetadata = tData[bindingIndex]; !isPropMetadataString(propMetadata); ) value += renderStringify(lView[bindingIndex]) + tData[bindingIndex], 
                            propMetadata = tData[++bindingIndex];
                            value += lView[bindingIndex];
                            var metadataParts = propMetadata.split(INTERPOLATION_DELIMITER), propertyName = metadataParts[0];
                            propertyName && (properties[propertyName] = metadataParts[1] + value + metadataParts[2]), 
                            bindingIndex++;
                        }
                        return properties;
                    }(tNode, lView, tData), hostProperties = function(tNode, lView, tData) {
                        for (var properties = {}, hostPropIndex = tNode.directiveEnd, propMetadata = tData[hostPropIndex]; "string" == typeof propMetadata; ) properties[propMetadata.split(INTERPOLATION_DELIMITER)[0]] = lView[hostPropIndex], 
                        propMetadata = tData[++hostPropIndex];
                        return properties;
                    }(tNode, lView, tData), className = function(debugElement) {
                        var e_2, _a, classes = debugElement.classes, output = "";
                        try {
                            for (var _b = __values(Object.keys(classes)), _c = _b.next(); !_c.done; _c = _b.next()) {
                                var className = _c.value;
                                classes[className] && (output = output ? output + " " + className : className);
                            }
                        } catch (e_2_1) {
                            e_2 = {
                                error: e_2_1
                            };
                        } finally {
                            try {
                                _c && !_c.done && (_a = _b.return) && _a.call(_b);
                            } finally {
                                if (e_2) throw e_2.error;
                            }
                        }
                        return output;
                    }(this), output = __assign({}, properties, hostProperties);
                    return className && (output.className = output.className ? output.className + " " + className : className), 
                    output;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(DebugElement__POST_R3__.prototype, "attributes", {
                get: function() {
                    var attributes = {}, element = this.nativeElement;
                    if (element) for (var eAttrs = element.attributes, i = 0; i < eAttrs.length; i++) {
                        var attr = eAttrs[i];
                        attributes[attr.name] = attr.value;
                    }
                    return attributes;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(DebugElement__POST_R3__.prototype, "classes", {
                get: function() {
                    var classes = {}, element = this.nativeElement;
                    if (element) {
                        var lContext = loadLContextFromNode(element), stylingContext = getStylingContext(lContext.nodeIndex, lContext.lView);
                        if (stylingContext) {
                            for (var i = 9; i < stylingContext.length; i += 4) if (isClassBasedValue(stylingContext, i)) {
                                var className = getProp(stylingContext, i), value = getValue(stylingContext, i);
                                "boolean" == typeof value && (classes[className] = value);
                            }
                        } else {
                            var eClasses = element.classList;
                            for (i = 0; i < eClasses.length; i++) classes[eClasses[i]] = !0;
                        }
                    }
                    return classes;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(DebugElement__POST_R3__.prototype, "styles", {
                get: function() {
                    var styles = {}, element = this.nativeElement;
                    if (element) {
                        var lContext = loadLContextFromNode(element), stylingContext = getStylingContext(lContext.nodeIndex, lContext.lView);
                        if (stylingContext) {
                            for (var i = 9; i < stylingContext.length; i += 4) if (!isClassBasedValue(stylingContext, i)) {
                                var styleName = getProp(stylingContext, i), value = getValue(stylingContext, i);
                                null !== value && (styles[styleName] = value);
                            }
                        } else {
                            var eStyles = element.style;
                            for (i = 0; i < eStyles.length; i++) {
                                var name_1 = eStyles.item(i);
                                styles[name_1] = eStyles.getPropertyValue(name_1);
                            }
                        }
                    }
                    return styles;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(DebugElement__POST_R3__.prototype, "childNodes", {
                get: function() {
                    for (var childNodes = this.nativeNode.childNodes, children = [], i = 0; i < childNodes.length; i++) children.push(getDebugNode__POST_R3__(childNodes[i]));
                    return children;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(DebugElement__POST_R3__.prototype, "children", {
                get: function() {
                    var nativeElement = this.nativeElement;
                    if (!nativeElement) return [];
                    for (var childNodes = nativeElement.children, children = [], i = 0; i < childNodes.length; i++) children.push(getDebugNode__POST_R3__(childNodes[i]));
                    return children;
                },
                enumerable: !0,
                configurable: !0
            }), DebugElement__POST_R3__.prototype.query = function(predicate) {
                return this.queryAll(predicate)[0] || null;
            }, DebugElement__POST_R3__.prototype.queryAll = function(predicate) {
                var matches = [];
                return _queryAllR3(this, predicate, matches, !0), matches;
            }, DebugElement__POST_R3__.prototype.queryAllNodes = function(predicate) {
                var matches = [];
                return _queryAllR3(this, predicate, matches, !1), matches;
            }, DebugElement__POST_R3__.prototype.triggerEventHandler = function(eventName, eventObj) {
                this.listeners.forEach(function(listener) {
                    listener.name === eventName && listener.callback(eventObj);
                });
            }, DebugElement__POST_R3__;
        }(DebugNode__POST_R3__);
        function _queryAllR3(parentElement, predicate, matches, elementsOnly) {
            var context = loadLContext(parentElement.nativeNode);
            _queryNodeChildrenR3(context.lView[TVIEW].data[context.nodeIndex], context.lView, predicate, matches, elementsOnly, parentElement.nativeNode);
        }
        function _queryNodeChildrenR3(tNode, lView, predicate, matches, elementsOnly, rootNativeNode) {
            var e_1, _a;
            if (3 === tNode.type || 4 === tNode.type) {
                _addQueryMatchR3(getNativeByTNode(tNode, lView), predicate, matches, elementsOnly, rootNativeNode), 
                isComponent(tNode) ? (componentView = getComponentViewByIndex(tNode.index, lView)) && componentView[TVIEW].firstChild && _queryNodeChildrenR3(componentView[TVIEW].firstChild, componentView, predicate, matches, elementsOnly, rootNativeNode) : tNode.child && _queryNodeChildrenR3(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);
                var nodeOrContainer = lView[tNode.index];
                isLContainer(nodeOrContainer) && _queryNodeChildrenInContainerR3(nodeOrContainer, predicate, matches, elementsOnly, rootNativeNode);
            } else if (0 === tNode.type) {
                var lContainer = lView[tNode.index];
                _addQueryMatchR3(lContainer[NATIVE], predicate, matches, elementsOnly, rootNativeNode), 
                _queryNodeChildrenInContainerR3(lContainer, predicate, matches, elementsOnly, rootNativeNode);
            } else if (1 === tNode.type) {
                var componentView, head = (componentView = findComponentView(lView))[T_HOST].projection[tNode.projection];
                if (Array.isArray(head)) try {
                    for (var head_1 = __values(head), head_1_1 = head_1.next(); !head_1_1.done; head_1_1 = head_1.next()) _addQueryMatchR3(head_1_1.value, predicate, matches, elementsOnly, rootNativeNode);
                } catch (e_1_1) {
                    e_1 = {
                        error: e_1_1
                    };
                } finally {
                    try {
                        head_1_1 && !head_1_1.done && (_a = head_1.return) && _a.call(head_1);
                    } finally {
                        if (e_1) throw e_1.error;
                    }
                } else if (head) {
                    var nextLView = componentView[PARENT];
                    _queryNodeChildrenR3(nextLView[TVIEW].data[head.index], nextLView, predicate, matches, elementsOnly, rootNativeNode);
                }
            } else tNode.child && _queryNodeChildrenR3(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);
            var nextTNode = 2 & tNode.flags ? tNode.projectionNext : tNode.next;
            nextTNode && _queryNodeChildrenR3(nextTNode, lView, predicate, matches, elementsOnly, rootNativeNode);
        }
        function _queryNodeChildrenInContainerR3(lContainer, predicate, matches, elementsOnly, rootNativeNode) {
            for (var i = 0; i < lContainer[VIEWS].length; i++) {
                var childView = lContainer[VIEWS][i];
                _queryNodeChildrenR3(childView[TVIEW].node, childView, predicate, matches, elementsOnly, rootNativeNode);
            }
        }
        function _addQueryMatchR3(nativeNode, predicate, matches, elementsOnly, rootNativeNode) {
            if (rootNativeNode !== nativeNode) {
                var debugNode = getDebugNode(nativeNode);
                debugNode && (!elementsOnly || debugNode instanceof core_DebugElement_POST_R3_) && predicate(debugNode) && matches.push(debugNode);
            }
        }
        function getDebugNode__POST_R3__(nativeNode) {
            return nativeNode instanceof Node ? nativeNode.nodeType == Node.ELEMENT_NODE ? new core_DebugElement_POST_R3_(nativeNode) : new DebugNode__POST_R3__(nativeNode) : null;
        }
        var getDebugNode = getDebugNode__POST_R3__, platformCore = createPlatformFactory(null, "core", [ {
            provide: PLATFORM_ID,
            useValue: "unknown"
        }, {
            provide: PlatformRef,
            deps: [ Injector ]
        }, {
            provide: core_TestabilityRegistry,
            deps: []
        }, {
            provide: Console,
            deps: []
        } ]), LOCALE_ID = new InjectionToken("LocaleId"), APPLICATION_MODULE_PROVIDERS = [ {
            provide: core_ApplicationRef,
            useClass: core_ApplicationRef,
            deps: [ NgZone, Console, Injector, ErrorHandler, core_ComponentFactoryResolver, ApplicationInitStatus ]
        }, {
            provide: SCHEDULER,
            deps: [ NgZone ],
            useFactory: function(ngZone) {
                var queue = [];
                return ngZone.onStable.subscribe(function() {
                    for (;queue.length; ) queue.pop()();
                }), function(fn) {
                    queue.push(fn);
                };
            }
        }, {
            provide: ApplicationInitStatus,
            useClass: ApplicationInitStatus,
            deps: [ [ new Optional(), APP_INITIALIZER ] ]
        }, {
            provide: Compiler,
            useClass: Compiler,
            deps: []
        }, APP_ID_RANDOM_PROVIDER, {
            provide: IterableDiffers,
            useFactory: function() {
                return defaultIterableDiffers;
            },
            deps: []
        }, {
            provide: KeyValueDiffers,
            useFactory: function() {
                return defaultKeyValueDiffers;
            },
            deps: []
        }, {
            provide: LOCALE_ID,
            useFactory: function(locale) {
                return locale || "en-US";
            },
            deps: [ [ new Inject(LOCALE_ID), new Optional(), new SkipSelf() ] ]
        } ], ApplicationModule = function() {
            function ApplicationModule(appRef) {}
            return ApplicationModule.ngModuleDef = defineNgModule({
                type: ApplicationModule
            }), ApplicationModule.ngInjectorDef = defineInjector({
                factory: function(t) {
                    return new (t || ApplicationModule)(inject(core_ApplicationRef));
                },
                providers: APPLICATION_MODULE_PROVIDERS
            }), ApplicationModule;
        }(), environment = {
            gaId: "UA-8594346-15",
            production: !0,
            mode: "stable"
        }, PlatformLocation = function() {
            return function() {};
        }(), LocationStrategy = function() {
            return function() {};
        }(), APP_BASE_HREF = new InjectionToken("appBaseHref"), common_Location = function() {
            function Location(platformStrategy) {
                var _this = this;
                this._subject = new core_EventEmitter(), this._platformStrategy = platformStrategy;
                var browserBaseHref = this._platformStrategy.getBaseHref();
                this._baseHref = Location_1.stripTrailingSlash(_stripIndexHtml(browserBaseHref)), 
                this._platformStrategy.onPopState(function(ev) {
                    _this._subject.emit({
                        url: _this.path(!0),
                        pop: !0,
                        state: ev.state,
                        type: ev.type
                    });
                });
            }
            var Location_1;
            return Location_1 = Location, Location.prototype.path = function(includeHash) {
                return void 0 === includeHash && (includeHash = !1), this.normalize(this._platformStrategy.path(includeHash));
            }, Location.prototype.isCurrentPathEqualTo = function(path, query) {
                return void 0 === query && (query = ""), this.path() == this.normalize(path + Location_1.normalizeQueryParams(query));
            }, Location.prototype.normalize = function(url) {
                return Location_1.stripTrailingSlash(function(baseHref, url) {
                    return baseHref && url.startsWith(baseHref) ? url.substring(baseHref.length) : url;
                }(this._baseHref, _stripIndexHtml(url)));
            }, Location.prototype.prepareExternalUrl = function(url) {
                return url && "/" !== url[0] && (url = "/" + url), this._platformStrategy.prepareExternalUrl(url);
            }, Location.prototype.go = function(path, query, state) {
                void 0 === query && (query = ""), void 0 === state && (state = null), this._platformStrategy.pushState(state, "", path, query);
            }, Location.prototype.replaceState = function(path, query, state) {
                void 0 === query && (query = ""), void 0 === state && (state = null), this._platformStrategy.replaceState(state, "", path, query);
            }, Location.prototype.forward = function() {
                this._platformStrategy.forward();
            }, Location.prototype.back = function() {
                this._platformStrategy.back();
            }, Location.prototype.subscribe = function(onNext, onThrow, onReturn) {
                return this._subject.subscribe({
                    next: onNext,
                    error: onThrow,
                    complete: onReturn
                });
            }, Location.normalizeQueryParams = function(params) {
                return params && "?" !== params[0] ? "?" + params : params;
            }, Location.joinWithSlash = function(start, end) {
                if (0 == start.length) return end;
                if (0 == end.length) return start;
                var slashes = 0;
                return start.endsWith("/") && slashes++, end.startsWith("/") && slashes++, 2 == slashes ? start + end.substring(1) : 1 == slashes ? start + end : start + "/" + end;
            }, Location.stripTrailingSlash = function(url) {
                var match = url.match(/#|\?|$/), pathEndIdx = match && match.index || url.length;
                return url.slice(0, pathEndIdx - ("/" === url[pathEndIdx - 1] ? 1 : 0)) + url.slice(pathEndIdx);
            }, Location.ngInjectableDef = defineInjectable({
                token: Location,
                factory: function(t) {
                    return new (t || Location)(inject(LocationStrategy));
                },
                providedIn: null
            }), Location;
        }();
        function _stripIndexHtml(url) {
            return url.replace(/\/index.html$/, "");
        }
        var common_PathLocationStrategy = function(_super) {
            function PathLocationStrategy(_platformLocation, href) {
                var _this = _super.call(this) || this;
                if (_this._platformLocation = _platformLocation, null == href && (href = _this._platformLocation.getBaseHrefFromDOM()), 
                null == href) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");
                return _this._baseHref = href, _this;
            }
            return __extends(PathLocationStrategy, _super), PathLocationStrategy.prototype.onPopState = function(fn) {
                this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn);
            }, PathLocationStrategy.prototype.getBaseHref = function() {
                return this._baseHref;
            }, PathLocationStrategy.prototype.prepareExternalUrl = function(internal) {
                return common_Location.joinWithSlash(this._baseHref, internal);
            }, PathLocationStrategy.prototype.path = function(includeHash) {
                void 0 === includeHash && (includeHash = !1);
                var pathname = this._platformLocation.pathname + common_Location.normalizeQueryParams(this._platformLocation.search), hash = this._platformLocation.hash;
                return hash && includeHash ? "" + pathname + hash : pathname;
            }, PathLocationStrategy.prototype.pushState = function(state, title, url, queryParams) {
                var externalUrl = this.prepareExternalUrl(url + common_Location.normalizeQueryParams(queryParams));
                this._platformLocation.pushState(state, title, externalUrl);
            }, PathLocationStrategy.prototype.replaceState = function(state, title, url, queryParams) {
                var externalUrl = this.prepareExternalUrl(url + common_Location.normalizeQueryParams(queryParams));
                this._platformLocation.replaceState(state, title, externalUrl);
            }, PathLocationStrategy.prototype.forward = function() {
                this._platformLocation.forward();
            }, PathLocationStrategy.prototype.back = function() {
                this._platformLocation.back();
            }, PathLocationStrategy.ngInjectableDef = defineInjectable({
                token: PathLocationStrategy,
                factory: function(t) {
                    return new (t || PathLocationStrategy)(inject(PlatformLocation), inject(APP_BASE_HREF, 8));
                },
                providedIn: null
            }), PathLocationStrategy;
        }(LocationStrategy), u = void 0, localeEn = [ "en", [ [ "a", "p" ], [ "AM", "PM" ], u ], [ [ "AM", "PM" ], u, u ], [ [ "S", "M", "T", "W", "T", "F", "S" ], [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ] ], u, [ [ "J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D" ], [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ], [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ] ], u, [ [ "B", "A" ], [ "BC", "AD" ], [ "Before Christ", "Anno Domini" ] ], 0, [ 6, 0 ], [ "M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y" ], [ "h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz" ], [ "{1}, {0}", u, "{1} 'at' {0}", u ], [ ".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":" ], [ "#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0" ], "$", "US Dollar", {}, function(n) {
            var i = Math.floor(Math.abs(n)), v = n.toString().replace(/^[^.]*\.?/, "").length;
            return 1 === i && 0 === v ? 1 : 5;
        } ], LOCALE_DATA = {}, common_Plural = function(Plural) {
            return Plural[Plural.Zero = 0] = "Zero", Plural[Plural.One = 1] = "One", Plural[Plural.Two = 2] = "Two", 
            Plural[Plural.Few = 3] = "Few", Plural[Plural.Many = 4] = "Many", Plural[Plural.Other = 5] = "Other", 
            Plural;
        }({}), DEPRECATED_PLURAL_FN = new InjectionToken("UseV4Plurals"), NgLocalization = function() {
            return function() {};
        }(), common_NgLocaleLocalization = function(_super) {
            function NgLocaleLocalization(locale, deprecatedPluralFn) {
                var _this = _super.call(this) || this;
                return _this.locale = locale, _this.deprecatedPluralFn = deprecatedPluralFn, _this;
            }
            return __extends(NgLocaleLocalization, _super), NgLocaleLocalization.prototype.getPluralCategory = function(value, locale) {
                switch (this.deprecatedPluralFn ? this.deprecatedPluralFn(locale || this.locale, value) : function(locale) {
                    return function(locale) {
                        var normalizedLocale = locale.toLowerCase().replace(/_/g, "-"), match = LOCALE_DATA[normalizedLocale];
                        if (match) return match;
                        var parentLocale = normalizedLocale.split("-")[0];
                        if (match = LOCALE_DATA[parentLocale]) return match;
                        if ("en" === parentLocale) return localeEn;
                        throw new Error('Missing locale data for the locale "' + locale + '".');
                    }(locale)[18];
                }(locale || this.locale)(value)) {
                  case common_Plural.Zero:
                    return "zero";

                  case common_Plural.One:
                    return "one";

                  case common_Plural.Two:
                    return "two";

                  case common_Plural.Few:
                    return "few";

                  case common_Plural.Many:
                    return "many";

                  default:
                    return "other";
                }
            }, NgLocaleLocalization.ngInjectableDef = defineInjectable({
                token: NgLocaleLocalization,
                factory: function(t) {
                    return new (t || NgLocaleLocalization)(inject(LOCALE_ID), inject(DEPRECATED_PLURAL_FN, 8));
                },
                providedIn: null
            }), NgLocaleLocalization;
        }(NgLocalization);
        function parseCookieValue(cookieStr, name) {
            var e_1, _a;
            name = encodeURIComponent(name);
            try {
                for (var _b = __values(cookieStr.split(";")), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var cookie = _c.value, eqIndex = cookie.indexOf("="), _d = __read(-1 == eqIndex ? [ cookie, "" ] : [ cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1) ], 2), cookieValue = _d[1];
                    if (_d[0].trim() === name) return decodeURIComponent(cookieValue);
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally {
                try {
                    _c && !_c.done && (_a = _b.return) && _a.call(_b);
                } finally {
                    if (e_1) throw e_1.error;
                }
            }
            return null;
        }
        var StylingDiffer = function() {
            function StylingDiffer(_name, _options) {
                this._name = _name, this._options = _options, this.value = null, this._lastSetValue = null, 
                this._lastSetValueType = 0, this._lastSetValueIdentityChange = !1;
            }
            return StylingDiffer.prototype.setValue = function(value) {
                if (Array.isArray(value)) this._lastSetValueType = 4; else if (value instanceof Set) this._lastSetValueType = 8; else if (value && "string" == typeof value) {
                    if (!(4 & this._options)) throw new Error(this._name + " string values are not allowed");
                    this._lastSetValueType = 1;
                } else this._lastSetValueType = value ? 2 : 0;
                this._lastSetValueIdentityChange = !0, this._lastSetValue = value || null;
            }, StylingDiffer.prototype.hasValueChanged = function() {
                var valueHasChanged = this._lastSetValueIdentityChange;
                if (!(valueHasChanged || 14 & this._lastSetValueType)) return !1;
                var finalValue = null, trimValues = !!(1 & this._options), parseOutUnits = !!(8 & this._options), allowSubKeys = !!(2 & this._options);
                switch (this._lastSetValueType) {
                  case 1:
                    var tokens = this._lastSetValue.split(/\s+/g);
                    16 & this._options ? (finalValue = {}, tokens.forEach(function(token, i) {
                        return finalValue[token] = !0;
                    })) : finalValue = tokens.reduce(function(str, token, i) {
                        return str + (i ? " " : "") + token;
                    });
                    break;

                  case 2:
                    var map = this._lastSetValue, keys = Object.keys(map);
                    valueHasChanged || (valueHasChanged = !this.value || function(keys, a, b) {
                        var newKeys = keys;
                        if (!arrayEqualsArray(Object.keys(a), newKeys)) return !0;
                        for (var i = 0; i < newKeys.length; i++) {
                            var key = newKeys[i];
                            if (a[key] !== b[key]) return !0;
                        }
                        return !1;
                    }(keys, this.value, map)), valueHasChanged && (finalValue = bulidMapFromValues(this._name, trimValues, parseOutUnits, allowSubKeys, map, keys));
                    break;

                  case 4:
                  case 8:
                    var values = Array.from(this._lastSetValue);
                    valueHasChanged || (valueHasChanged = !arrayEqualsArray(Object.keys(this.value), values)), 
                    valueHasChanged && (finalValue = bulidMapFromValues(this._name, trimValues, parseOutUnits, allowSubKeys, values));
                    break;

                  default:
                    finalValue = null;
                }
                return valueHasChanged && (this.value = finalValue), valueHasChanged;
            }, StylingDiffer;
        }();
        function bulidMapFromValues(errorPrefix, trim, parseOutUnits, allowSubKeys, values, keys) {
            var map = {};
            if (keys) for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                setMapValues(map, key = trim ? key.trim() : key, value = values[key], parseOutUnits, allowSubKeys);
            } else for (i = 0; i < values.length; i++) {
                var value;
                assertValidValue(errorPrefix, value = values[i]), setMapValues(map, value = trim ? value.trim() : value, !0, !1, allowSubKeys);
            }
            return map;
        }
        function assertValidValue(errorPrefix, value) {
            if ("string" != typeof value) throw new Error(errorPrefix + " can only toggle CSS classes expressed as strings, got " + value);
        }
        function setMapValues(map, key, value, parseOutUnits, allowSubKeys) {
            if (allowSubKeys && key.indexOf(" ") > 0) for (var innerKeys = key.split(/\s+/g), j = 0; j < innerKeys.length; j++) setIndividualMapValue(map, innerKeys[j], value, parseOutUnits); else setIndividualMapValue(map, key, value, parseOutUnits);
        }
        function setIndividualMapValue(map, key, value, parseOutUnits) {
            if (parseOutUnits) {
                var values = function(key, value) {
                    var index = key.indexOf(".");
                    if (index > 0) {
                        var unit = key.substr(index + 1);
                        key = key.substring(0, index), null != value && (value += unit);
                    }
                    return {
                        key: key,
                        value: value
                    };
                }(key, value);
                value = values.value, key = values.key;
            }
            map[key] = value;
        }
        function arrayEqualsArray(a, b) {
            if (a && b) {
                if (a.length !== b.length) return !1;
                for (var i = 0; i < a.length; i++) if (-1 === b.indexOf(a[i])) return !1;
                return !0;
            }
            return !1;
        }
        var NgClassImpl = function() {
            return function() {};
        }(), NgClassImplProvider = {
            provide: NgClassImpl,
            useClass: function() {
                function NgClassR3Impl() {
                    this._value = null, this._ngClassDiffer = new StylingDiffer("NgClass", 23), this._classStringDiffer = null;
                }
                return NgClassR3Impl.prototype.getValue = function() {
                    return this._value;
                }, NgClassR3Impl.prototype.setClass = function(value) {
                    (value || this._classStringDiffer) && (this._classStringDiffer = this._classStringDiffer || new StylingDiffer("class", 20), 
                    this._classStringDiffer.setValue(value));
                }, NgClassR3Impl.prototype.setNgClass = function(value) {
                    this._ngClassDiffer.setValue(value);
                }, NgClassR3Impl.prototype.applyChanges = function() {
                    var classChanged = !!this._classStringDiffer && this._classStringDiffer.hasValueChanged(), ngClassChanged = this._ngClassDiffer.hasValueChanged();
                    if (classChanged || ngClassChanged) {
                        var value = this._ngClassDiffer.value;
                        if (this._classStringDiffer) {
                            var classValue = this._classStringDiffer.value;
                            classValue && (value = value ? __assign({}, classValue, value) : classValue);
                        }
                        this._value = value;
                    }
                }, NgClassR3Impl.ngInjectableDef = defineInjectable({
                    token: NgClassR3Impl,
                    factory: function(t) {
                        return new (t || NgClassR3Impl)();
                    },
                    providedIn: null
                }), NgClassR3Impl;
            }()
        }, ngClassDirectiveDef = defineDirective({
            type: function() {},
            selectors: null,
            factory: function() {},
            hostBindings: function(rf, ctx, elIndex) {
                1 & rf && elementHostStyling(), 2 & rf && (elementHostStylingMap(ctx.getValue()), 
                elementHostStylingApply());
            }
        }), common_NgClass = function(_super) {
            function NgClass(delegate) {
                return _super.call(this, delegate) || this;
            }
            return __extends(NgClass, _super), Object.defineProperty(NgClass.prototype, "klass", {
                set: function(value) {
                    this._delegate.setClass(value);
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(NgClass.prototype, "ngClass", {
                set: function(value) {
                    this._delegate.setNgClass(value);
                },
                enumerable: !0,
                configurable: !0
            }), NgClass.prototype.ngDoCheck = function() {
                this._delegate.applyChanges();
            }, NgClass.ngDirectiveDef = defineDirective({
                type: NgClass,
                selectors: [ [ "", "ngClass", "" ] ],
                factory: function(t) {
                    return new (t || NgClass)(directiveInject(NgClassImpl));
                },
                inputs: {
                    klass: [ "class", "klass" ],
                    ngClass: "ngClass"
                },
                features: [ ProvidersFeature([ NgClassImplProvider ]), InheritDefinitionFeature ]
            }), NgClass;
        }(function() {
            function NgClassBase(_delegate) {
                this._delegate = _delegate;
            }
            return NgClassBase.prototype.getValue = function() {
                return this._delegate.getValue();
            }, NgClassBase.ngDirectiveDef = ngClassDirectiveDef, NgClassBase;
        }()), NgForOfContext = function() {
            function NgForOfContext($implicit, ngForOf, index, count) {
                this.$implicit = $implicit, this.ngForOf = ngForOf, this.index = index, this.count = count;
            }
            return Object.defineProperty(NgForOfContext.prototype, "first", {
                get: function() {
                    return 0 === this.index;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(NgForOfContext.prototype, "last", {
                get: function() {
                    return this.index === this.count - 1;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(NgForOfContext.prototype, "even", {
                get: function() {
                    return this.index % 2 == 0;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(NgForOfContext.prototype, "odd", {
                get: function() {
                    return !this.even;
                },
                enumerable: !0,
                configurable: !0
            }), NgForOfContext;
        }(), common_NgForOf = function() {
            function NgForOf(_viewContainer, _template, _differs) {
                this._viewContainer = _viewContainer, this._template = _template, this._differs = _differs, 
                this._ngForOfDirty = !0, this._differ = null;
            }
            return Object.defineProperty(NgForOf.prototype, "ngForOf", {
                set: function(ngForOf) {
                    this._ngForOf = ngForOf, this._ngForOfDirty = !0;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(NgForOf.prototype, "ngForTrackBy", {
                get: function() {
                    return this._trackByFn;
                },
                set: function(fn) {
                    isDevMode() && null != fn && "function" != typeof fn && console && console.warn && console.warn("trackBy must be a function, but received " + JSON.stringify(fn) + ". See https://angular.io/docs/ts/latest/api/common/index/NgFor-directive.html#!#change-propagation for more information."), 
                    this._trackByFn = fn;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(NgForOf.prototype, "ngForTemplate", {
                set: function(value) {
                    value && (this._template = value);
                },
                enumerable: !0,
                configurable: !0
            }), NgForOf.prototype.ngDoCheck = function() {
                if (this._ngForOfDirty) {
                    this._ngForOfDirty = !1;
                    var value = this._ngForOf;
                    if (!this._differ && value) try {
                        this._differ = this._differs.find(value).create(this.ngForTrackBy);
                    } catch (_a) {
                        throw new Error("Cannot find a differ supporting object '" + value + "' of type '" + ((type = value).name || typeof type) + "'. NgFor only supports binding to Iterables such as Arrays.");
                    }
                }
                var type;
                if (this._differ) {
                    var changes = this._differ.diff(this._ngForOf);
                    changes && this._applyChanges(changes);
                }
            }, NgForOf.prototype._applyChanges = function(changes) {
                var _this = this, insertTuples = [];
                changes.forEachOperation(function(item, adjustedPreviousIndex, currentIndex) {
                    if (null == item.previousIndex) {
                        var view = _this._viewContainer.createEmbeddedView(_this._template, new NgForOfContext(null, _this._ngForOf, -1, -1), currentIndex), tuple = new RecordViewTuple(item, view);
                        insertTuples.push(tuple);
                    } else null == currentIndex ? _this._viewContainer.remove(adjustedPreviousIndex) : (view = _this._viewContainer.get(adjustedPreviousIndex), 
                    _this._viewContainer.move(view, currentIndex), tuple = new RecordViewTuple(item, view), 
                    insertTuples.push(tuple));
                });
                for (var i = 0; i < insertTuples.length; i++) this._perViewChange(insertTuples[i].view, insertTuples[i].record);
                i = 0;
                for (var ilen = this._viewContainer.length; i < ilen; i++) {
                    var viewRef = this._viewContainer.get(i);
                    viewRef.context.index = i, viewRef.context.count = ilen, viewRef.context.ngForOf = this._ngForOf;
                }
                changes.forEachIdentityChange(function(record) {
                    _this._viewContainer.get(record.currentIndex).context.$implicit = record.item;
                });
            }, NgForOf.prototype._perViewChange = function(view, record) {
                view.context.$implicit = record.item;
            }, NgForOf.ngTemplateContextGuard = function(dir, ctx) {
                return !0;
            }, NgForOf.ngDirectiveDef = defineDirective({
                type: NgForOf,
                selectors: [ [ "", "ngFor", "", "ngForOf", "" ] ],
                factory: function(t) {
                    return new (t || NgForOf)(directiveInject(ViewContainerRef), directiveInject(TemplateRef), directiveInject(IterableDiffers));
                },
                inputs: {
                    ngForOf: "ngForOf",
                    ngForTrackBy: "ngForTrackBy",
                    ngForTemplate: "ngForTemplate"
                }
            }), NgForOf;
        }(), RecordViewTuple = function() {
            return function(record, view) {
                this.record = record, this.view = view;
            };
        }(), common_NgIf = function() {
            function NgIf(_viewContainer, templateRef) {
                this._viewContainer = _viewContainer, this._context = new NgIfContext(), this._thenTemplateRef = null, 
                this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, 
                this._thenTemplateRef = templateRef;
            }
            return Object.defineProperty(NgIf.prototype, "ngIf", {
                set: function(condition) {
                    this._context.$implicit = this._context.ngIf = condition, this._updateView();
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(NgIf.prototype, "ngIfThen", {
                set: function(templateRef) {
                    assertTemplate("ngIfThen", templateRef), this._thenTemplateRef = templateRef, this._thenViewRef = null, 
                    this._updateView();
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(NgIf.prototype, "ngIfElse", {
                set: function(templateRef) {
                    assertTemplate("ngIfElse", templateRef), this._elseTemplateRef = templateRef, this._elseViewRef = null, 
                    this._updateView();
                },
                enumerable: !0,
                configurable: !0
            }), NgIf.prototype._updateView = function() {
                this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, 
                this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), 
                this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context)));
            }, NgIf.ngTemplateGuard_ngIf = function(dir, expr) {
                return !0;
            }, NgIf.ngDirectiveDef = defineDirective({
                type: NgIf,
                selectors: [ [ "", "ngIf", "" ] ],
                factory: function(t) {
                    return new (t || NgIf)(directiveInject(ViewContainerRef), directiveInject(TemplateRef));
                },
                inputs: {
                    ngIf: "ngIf",
                    ngIfThen: "ngIfThen",
                    ngIfElse: "ngIfElse"
                }
            }), NgIf;
        }(), NgIfContext = function() {
            return function() {
                this.$implicit = null, this.ngIf = null;
            };
        }();
        function assertTemplate(property, templateRef) {
            if (templateRef && !templateRef.createEmbeddedView) throw new Error(property + " must be a TemplateRef, but received '" + stringify(templateRef) + "'.");
        }
        var SwitchView = function() {
            function SwitchView(_viewContainerRef, _templateRef) {
                this._viewContainerRef = _viewContainerRef, this._templateRef = _templateRef, this._created = !1;
            }
            return SwitchView.prototype.create = function() {
                this._created = !0, this._viewContainerRef.createEmbeddedView(this._templateRef);
            }, SwitchView.prototype.destroy = function() {
                this._created = !1, this._viewContainerRef.clear();
            }, SwitchView.prototype.enforceState = function(created) {
                created && !this._created ? this.create() : !created && this._created && this.destroy();
            }, SwitchView;
        }(), common_NgSwitch = function() {
            function NgSwitch() {
                this._defaultUsed = !1, this._caseCount = 0, this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1;
            }
            return Object.defineProperty(NgSwitch.prototype, "ngSwitch", {
                set: function(newValue) {
                    this._ngSwitch = newValue, 0 === this._caseCount && this._updateDefaultCases(!0);
                },
                enumerable: !0,
                configurable: !0
            }), NgSwitch.prototype._addCase = function() {
                return this._caseCount++;
            }, NgSwitch.prototype._addDefault = function(view) {
                this._defaultViews || (this._defaultViews = []), this._defaultViews.push(view);
            }, NgSwitch.prototype._matchCase = function(value) {
                var matched = value == this._ngSwitch;
                return this._lastCasesMatched = this._lastCasesMatched || matched, this._lastCaseCheckIndex++, 
                this._lastCaseCheckIndex === this._caseCount && (this._updateDefaultCases(!this._lastCasesMatched), 
                this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1), matched;
            }, NgSwitch.prototype._updateDefaultCases = function(useDefault) {
                if (this._defaultViews && useDefault !== this._defaultUsed) {
                    this._defaultUsed = useDefault;
                    for (var i = 0; i < this._defaultViews.length; i++) this._defaultViews[i].enforceState(useDefault);
                }
            }, NgSwitch.ngDirectiveDef = defineDirective({
                type: NgSwitch,
                selectors: [ [ "", "ngSwitch", "" ] ],
                factory: function(t) {
                    return new (t || NgSwitch)();
                },
                inputs: {
                    ngSwitch: "ngSwitch"
                }
            }), NgSwitch;
        }(), common_NgSwitchCase = function() {
            function NgSwitchCase(viewContainer, templateRef, ngSwitch) {
                this.ngSwitch = ngSwitch, ngSwitch._addCase(), this._view = new SwitchView(viewContainer, templateRef);
            }
            return NgSwitchCase.prototype.ngDoCheck = function() {
                this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase));
            }, NgSwitchCase.ngDirectiveDef = defineDirective({
                type: NgSwitchCase,
                selectors: [ [ "", "ngSwitchCase", "" ] ],
                factory: function(t) {
                    return new (t || NgSwitchCase)(directiveInject(ViewContainerRef), directiveInject(TemplateRef), directiveInject(common_NgSwitch, 1));
                },
                inputs: {
                    ngSwitchCase: "ngSwitchCase"
                }
            }), NgSwitchCase;
        }(), common_NgSwitchDefault = function() {
            function NgSwitchDefault(viewContainer, templateRef, ngSwitch) {
                ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));
            }
            return NgSwitchDefault.ngDirectiveDef = defineDirective({
                type: NgSwitchDefault,
                selectors: [ [ "", "ngSwitchDefault", "" ] ],
                factory: function(t) {
                    return new (t || NgSwitchDefault)(directiveInject(ViewContainerRef), directiveInject(TemplateRef), directiveInject(common_NgSwitch, 1));
                }
            }), NgSwitchDefault;
        }(), NgStyleImpl = function() {
            return function() {};
        }(), NgStyleImplProvider = {
            provide: NgStyleImpl,
            useClass: function() {
                function NgStyleR3Impl() {
                    this._differ = new StylingDiffer("NgStyle", 8), this._value = null;
                }
                return NgStyleR3Impl.prototype.getValue = function() {
                    return this._value;
                }, NgStyleR3Impl.prototype.setNgStyle = function(value) {
                    this._differ.setValue(value);
                }, NgStyleR3Impl.prototype.applyChanges = function() {
                    this._differ.hasValueChanged() && (this._value = this._differ.value);
                }, NgStyleR3Impl.ngInjectableDef = defineInjectable({
                    token: NgStyleR3Impl,
                    factory: function(t) {
                        return new (t || NgStyleR3Impl)();
                    },
                    providedIn: null
                }), NgStyleR3Impl;
            }()
        }, ngStyleDirectiveDef = defineDirective({
            type: function() {},
            selectors: null,
            factory: function() {},
            hostBindings: function(rf, ctx, elIndex) {
                1 & rf && elementHostStyling(), 2 & rf && (elementHostStylingMap(null, ctx.getValue()), 
                elementHostStylingApply());
            }
        }), common_NgStyle = function(_super) {
            function NgStyle(delegate) {
                return _super.call(this, delegate) || this;
            }
            return __extends(NgStyle, _super), Object.defineProperty(NgStyle.prototype, "ngStyle", {
                set: function(value) {
                    this._delegate.setNgStyle(value);
                },
                enumerable: !0,
                configurable: !0
            }), NgStyle.prototype.ngDoCheck = function() {
                this._delegate.applyChanges();
            }, NgStyle.ngDirectiveDef = defineDirective({
                type: NgStyle,
                selectors: [ [ "", "ngStyle", "" ] ],
                factory: function(t) {
                    return new (t || NgStyle)(directiveInject(NgStyleImpl));
                },
                inputs: {
                    ngStyle: "ngStyle"
                },
                features: [ ProvidersFeature([ NgStyleImplProvider ]), InheritDefinitionFeature ]
            }), NgStyle;
        }(function() {
            function NgStyleBase(_delegate) {
                this._delegate = _delegate;
            }
            return NgStyleBase.prototype.getValue = function() {
                return this._delegate.getValue();
            }, NgStyleBase.ngDirectiveDef = ngStyleDirectiveDef, NgStyleBase;
        }()), ObservableStrategy = function() {
            function ObservableStrategy() {}
            return ObservableStrategy.prototype.createSubscription = function(async, updateLatestValue) {
                return async.subscribe({
                    next: updateLatestValue,
                    error: function(e) {
                        throw e;
                    }
                });
            }, ObservableStrategy.prototype.dispose = function(subscription) {
                subscription.unsubscribe();
            }, ObservableStrategy.prototype.onDestroy = function(subscription) {
                subscription.unsubscribe();
            }, ObservableStrategy;
        }(), _promiseStrategy = new (function() {
            function PromiseStrategy() {}
            return PromiseStrategy.prototype.createSubscription = function(async, updateLatestValue) {
                return async.then(updateLatestValue, function(e) {
                    throw e;
                });
            }, PromiseStrategy.prototype.dispose = function(subscription) {}, PromiseStrategy.prototype.onDestroy = function(subscription) {}, 
            PromiseStrategy;
        }())(), _observableStrategy = new ObservableStrategy(), common_AsyncPipe = function() {
            function AsyncPipe(_ref) {
                this._ref = _ref, this._latestValue = null, this._latestReturnedValue = null, this._subscription = null, 
                this._obj = null, this._strategy = null;
            }
            var AsyncPipe_1, pipeDef;
            return AsyncPipe_1 = AsyncPipe, AsyncPipe.prototype.ngOnDestroy = function() {
                this._subscription && this._dispose();
            }, AsyncPipe.prototype.transform = function(obj) {
                return this._obj ? obj !== this._obj ? (this._dispose(), this.transform(obj)) : this._latestValue === this._latestReturnedValue ? this._latestReturnedValue : (this._latestReturnedValue = this._latestValue, 
                WrappedValue.wrap(this._latestValue)) : (obj && this._subscribe(obj), this._latestReturnedValue = this._latestValue, 
                this._latestValue);
            }, AsyncPipe.prototype._subscribe = function(obj) {
                var _this = this;
                this._obj = obj, this._strategy = this._selectStrategy(obj), this._subscription = this._strategy.createSubscription(obj, function(value) {
                    return _this._updateLatestValue(obj, value);
                });
            }, AsyncPipe.prototype._selectStrategy = function(obj) {
                if (core_isPromise(obj)) return _promiseStrategy;
                if (function(obj) {
                    return !!obj && "function" == typeof obj.subscribe;
                }(obj)) return _observableStrategy;
                throw Error("InvalidPipeArgument: '" + obj + "' for pipe '" + stringify(AsyncPipe_1) + "'");
            }, AsyncPipe.prototype._dispose = function() {
                this._strategy.dispose(this._subscription), this._latestValue = null, this._latestReturnedValue = null, 
                this._subscription = null, this._obj = null;
            }, AsyncPipe.prototype._updateLatestValue = function(async, value) {
                async === this._obj && (this._latestValue = value, this._ref.markForCheck());
            }, AsyncPipe.ngPipeDef = {
                name: (pipeDef = {
                    name: "async",
                    type: AsyncPipe,
                    factory: function(t) {
                        return new (t || AsyncPipe)(directiveInject(ChangeDetectorRef));
                    },
                    pure: !1
                }).name,
                factory: pipeDef.factory,
                pure: !1 !== pipeDef.pure,
                onDestroy: pipeDef.type.prototype.ngOnDestroy || null
            }, AsyncPipe;
        }(), common_CommonModule = function() {
            function CommonModule() {}
            return CommonModule.ngModuleDef = defineNgModule({
                type: CommonModule
            }), CommonModule.ngInjectorDef = defineInjector({
                factory: function(t) {
                    return new (t || CommonModule)();
                },
                providers: [ {
                    provide: NgLocalization,
                    useClass: common_NgLocaleLocalization
                } ]
            }), CommonModule;
        }(), DOCUMENT = new InjectionToken("DocumentToken"), PLATFORM_BROWSER_ID = "browser", PLATFORM_SERVER_ID = "server";
        function isPlatformBrowser(platformId) {
            return platformId === PLATFORM_BROWSER_ID;
        }
        var common_ViewportScroller = function() {
            function ViewportScroller() {}
            return ViewportScroller.ngInjectableDef = defineInjectable({
                providedIn: "root",
                factory: function() {
                    return new BrowserViewportScroller(inject(DOCUMENT), window, inject(ErrorHandler));
                }
            }), ViewportScroller;
        }(), BrowserViewportScroller = function() {
            function BrowserViewportScroller(document, window, errorHandler) {
                this.document = document, this.window = window, this.errorHandler = errorHandler, 
                this.offset = function() {
                    return [ 0, 0 ];
                };
            }
            return BrowserViewportScroller.prototype.setOffset = function(offset) {
                this.offset = Array.isArray(offset) ? function() {
                    return offset;
                } : offset;
            }, BrowserViewportScroller.prototype.getScrollPosition = function() {
                return this.supportScrollRestoration() ? [ this.window.scrollX, this.window.scrollY ] : [ 0, 0 ];
            }, BrowserViewportScroller.prototype.scrollToPosition = function(position) {
                this.supportScrollRestoration() && this.window.scrollTo(position[0], position[1]);
            }, BrowserViewportScroller.prototype.scrollToAnchor = function(anchor) {
                if (this.supportScrollRestoration()) {
                    anchor = this.window.CSS && this.window.CSS.escape ? this.window.CSS.escape(anchor) : anchor.replace(/(\"|\'\ |:|\.|\[|\]|,|=)/g, "\\$1");
                    try {
                        var elSelectedById = this.document.querySelector("#" + anchor);
                        if (elSelectedById) return void this.scrollToElement(elSelectedById);
                        var elSelectedByName = this.document.querySelector("[name='" + anchor + "']");
                        if (elSelectedByName) return void this.scrollToElement(elSelectedByName);
                    } catch (e) {
                        this.errorHandler.handleError(e);
                    }
                }
            }, BrowserViewportScroller.prototype.setHistoryScrollRestoration = function(scrollRestoration) {
                if (this.supportScrollRestoration()) {
                    var history_1 = this.window.history;
                    history_1 && history_1.scrollRestoration && (history_1.scrollRestoration = scrollRestoration);
                }
            }, BrowserViewportScroller.prototype.scrollToElement = function(el) {
                var rect = el.getBoundingClientRect(), left = rect.left + this.window.pageXOffset, top = rect.top + this.window.pageYOffset, offset = this.offset();
                this.window.scrollTo(left - offset[0], top - offset[1]);
            }, BrowserViewportScroller.prototype.supportScrollRestoration = function() {
                try {
                    return !!this.window && !!this.window.scrollTo;
                } catch (_a) {
                    return !1;
                }
            }, BrowserViewportScroller;
        }(), _DOM = null;
        function getDOM() {
            return _DOM;
        }
        var nodeContains, _attrToPropMap = {
            class: "className",
            innerHtml: "innerHTML",
            readonly: "readOnly",
            tabindex: "tabIndex"
        }, _keyMap = {
            "\b": "Backspace",
            "\t": "Tab",
            "\x7f": "Delete",
            "\x1b": "Escape",
            Del: "Delete",
            Esc: "Escape",
            Left: "ArrowLeft",
            Right: "ArrowRight",
            Up: "ArrowUp",
            Down: "ArrowDown",
            Menu: "ContextMenu",
            Scroll: "ScrollLock",
            Win: "OS"
        }, _chromeNumKeyPadMap = {
            A: "1",
            B: "2",
            C: "3",
            D: "4",
            E: "5",
            F: "6",
            G: "7",
            H: "8",
            I: "9",
            J: "*",
            K: "+",
            M: "-",
            N: ".",
            O: "/",
            "`": "0",
            "\x90": "NumLock"
        };
        _global.Node && (nodeContains = _global.Node.prototype.contains || function(node) {
            return !!(16 & this.compareDocumentPosition(node));
        });
        var urlParsingNode, platform_browser_BrowserDomAdapter = function(_super) {
            function BrowserDomAdapter() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return __extends(BrowserDomAdapter, _super), BrowserDomAdapter.prototype.parse = function(templateHtml) {
                throw new Error("parse not implemented");
            }, BrowserDomAdapter.makeCurrent = function() {
                var adapter;
                adapter = new BrowserDomAdapter(), _DOM || (_DOM = adapter);
            }, BrowserDomAdapter.prototype.hasProperty = function(element, name) {
                return name in element;
            }, BrowserDomAdapter.prototype.setProperty = function(el, name, value) {
                el[name] = value;
            }, BrowserDomAdapter.prototype.getProperty = function(el, name) {
                return el[name];
            }, BrowserDomAdapter.prototype.invoke = function(el, methodName, args) {
                var _a;
                (_a = el)[methodName].apply(_a, __spread(args));
            }, BrowserDomAdapter.prototype.logError = function(error) {
                window.console && (console.error ? console.error(error) : console.log(error));
            }, BrowserDomAdapter.prototype.log = function(error) {
                window.console && window.console.log && window.console.log(error);
            }, BrowserDomAdapter.prototype.logGroup = function(error) {
                window.console && window.console.group && window.console.group(error);
            }, BrowserDomAdapter.prototype.logGroupEnd = function() {
                window.console && window.console.groupEnd && window.console.groupEnd();
            }, Object.defineProperty(BrowserDomAdapter.prototype, "attrToPropMap", {
                get: function() {
                    return _attrToPropMap;
                },
                enumerable: !0,
                configurable: !0
            }), BrowserDomAdapter.prototype.contains = function(nodeA, nodeB) {
                return nodeContains.call(nodeA, nodeB);
            }, BrowserDomAdapter.prototype.querySelector = function(el, selector) {
                return el.querySelector(selector);
            }, BrowserDomAdapter.prototype.querySelectorAll = function(el, selector) {
                return el.querySelectorAll(selector);
            }, BrowserDomAdapter.prototype.on = function(el, evt, listener) {
                el.addEventListener(evt, listener, !1);
            }, BrowserDomAdapter.prototype.onAndCancel = function(el, evt, listener) {
                return el.addEventListener(evt, listener, !1), function() {
                    el.removeEventListener(evt, listener, !1);
                };
            }, BrowserDomAdapter.prototype.dispatchEvent = function(el, evt) {
                el.dispatchEvent(evt);
            }, BrowserDomAdapter.prototype.createMouseEvent = function(eventType) {
                var evt = this.getDefaultDocument().createEvent("MouseEvent");
                return evt.initEvent(eventType, !0, !0), evt;
            }, BrowserDomAdapter.prototype.createEvent = function(eventType) {
                var evt = this.getDefaultDocument().createEvent("Event");
                return evt.initEvent(eventType, !0, !0), evt;
            }, BrowserDomAdapter.prototype.preventDefault = function(evt) {
                evt.preventDefault(), evt.returnValue = !1;
            }, BrowserDomAdapter.prototype.isPrevented = function(evt) {
                return evt.defaultPrevented || null != evt.returnValue && !evt.returnValue;
            }, BrowserDomAdapter.prototype.getInnerHTML = function(el) {
                return el.innerHTML;
            }, BrowserDomAdapter.prototype.getTemplateContent = function(el) {
                return "content" in el && this.isTemplateElement(el) ? el.content : null;
            }, BrowserDomAdapter.prototype.getOuterHTML = function(el) {
                return el.outerHTML;
            }, BrowserDomAdapter.prototype.nodeName = function(node) {
                return node.nodeName;
            }, BrowserDomAdapter.prototype.nodeValue = function(node) {
                return node.nodeValue;
            }, BrowserDomAdapter.prototype.type = function(node) {
                return node.type;
            }, BrowserDomAdapter.prototype.content = function(node) {
                return this.hasProperty(node, "content") ? node.content : node;
            }, BrowserDomAdapter.prototype.firstChild = function(el) {
                return el.firstChild;
            }, BrowserDomAdapter.prototype.nextSibling = function(el) {
                return el.nextSibling;
            }, BrowserDomAdapter.prototype.parentElement = function(el) {
                return el.parentNode;
            }, BrowserDomAdapter.prototype.childNodes = function(el) {
                return el.childNodes;
            }, BrowserDomAdapter.prototype.childNodesAsList = function(el) {
                for (var childNodes = el.childNodes, res = new Array(childNodes.length), i = 0; i < childNodes.length; i++) res[i] = childNodes[i];
                return res;
            }, BrowserDomAdapter.prototype.clearNodes = function(el) {
                for (;el.firstChild; ) el.removeChild(el.firstChild);
            }, BrowserDomAdapter.prototype.appendChild = function(el, node) {
                el.appendChild(node);
            }, BrowserDomAdapter.prototype.removeChild = function(el, node) {
                el.removeChild(node);
            }, BrowserDomAdapter.prototype.replaceChild = function(el, newChild, oldChild) {
                el.replaceChild(newChild, oldChild);
            }, BrowserDomAdapter.prototype.remove = function(node) {
                return node.parentNode && node.parentNode.removeChild(node), node;
            }, BrowserDomAdapter.prototype.insertBefore = function(parent, ref, node) {
                parent.insertBefore(node, ref);
            }, BrowserDomAdapter.prototype.insertAllBefore = function(parent, ref, nodes) {
                nodes.forEach(function(n) {
                    return parent.insertBefore(n, ref);
                });
            }, BrowserDomAdapter.prototype.insertAfter = function(parent, ref, node) {
                parent.insertBefore(node, ref.nextSibling);
            }, BrowserDomAdapter.prototype.setInnerHTML = function(el, value) {
                el.innerHTML = value;
            }, BrowserDomAdapter.prototype.getText = function(el) {
                return el.textContent;
            }, BrowserDomAdapter.prototype.setText = function(el, value) {
                el.textContent = value;
            }, BrowserDomAdapter.prototype.getValue = function(el) {
                return el.value;
            }, BrowserDomAdapter.prototype.setValue = function(el, value) {
                el.value = value;
            }, BrowserDomAdapter.prototype.getChecked = function(el) {
                return el.checked;
            }, BrowserDomAdapter.prototype.setChecked = function(el, value) {
                el.checked = value;
            }, BrowserDomAdapter.prototype.createComment = function(text) {
                return this.getDefaultDocument().createComment(text);
            }, BrowserDomAdapter.prototype.createTemplate = function(html) {
                var t = this.getDefaultDocument().createElement("template");
                return t.innerHTML = html, t;
            }, BrowserDomAdapter.prototype.createElement = function(tagName, doc) {
                return (doc = doc || this.getDefaultDocument()).createElement(tagName);
            }, BrowserDomAdapter.prototype.createElementNS = function(ns, tagName, doc) {
                return (doc = doc || this.getDefaultDocument()).createElementNS(ns, tagName);
            }, BrowserDomAdapter.prototype.createTextNode = function(text, doc) {
                return (doc = doc || this.getDefaultDocument()).createTextNode(text);
            }, BrowserDomAdapter.prototype.createScriptTag = function(attrName, attrValue, doc) {
                var el = (doc = doc || this.getDefaultDocument()).createElement("SCRIPT");
                return el.setAttribute(attrName, attrValue), el;
            }, BrowserDomAdapter.prototype.createStyleElement = function(css, doc) {
                var style = (doc = doc || this.getDefaultDocument()).createElement("style");
                return this.appendChild(style, this.createTextNode(css, doc)), style;
            }, BrowserDomAdapter.prototype.createShadowRoot = function(el) {
                return el.createShadowRoot();
            }, BrowserDomAdapter.prototype.getShadowRoot = function(el) {
                return el.shadowRoot;
            }, BrowserDomAdapter.prototype.getHost = function(el) {
                return el.host;
            }, BrowserDomAdapter.prototype.clone = function(node) {
                return node.cloneNode(!0);
            }, BrowserDomAdapter.prototype.getElementsByClassName = function(element, name) {
                return element.getElementsByClassName(name);
            }, BrowserDomAdapter.prototype.getElementsByTagName = function(element, name) {
                return element.getElementsByTagName(name);
            }, BrowserDomAdapter.prototype.classList = function(element) {
                return Array.prototype.slice.call(element.classList, 0);
            }, BrowserDomAdapter.prototype.addClass = function(element, className) {
                element.classList.add(className);
            }, BrowserDomAdapter.prototype.removeClass = function(element, className) {
                element.classList.remove(className);
            }, BrowserDomAdapter.prototype.hasClass = function(element, className) {
                return element.classList.contains(className);
            }, BrowserDomAdapter.prototype.setStyle = function(element, styleName, styleValue) {
                element.style[styleName] = styleValue;
            }, BrowserDomAdapter.prototype.removeStyle = function(element, stylename) {
                element.style[stylename] = "";
            }, BrowserDomAdapter.prototype.getStyle = function(element, stylename) {
                return element.style[stylename];
            }, BrowserDomAdapter.prototype.hasStyle = function(element, styleName, styleValue) {
                var value = this.getStyle(element, styleName) || "";
                return styleValue ? value == styleValue : value.length > 0;
            }, BrowserDomAdapter.prototype.tagName = function(element) {
                return element.tagName;
            }, BrowserDomAdapter.prototype.attributeMap = function(element) {
                for (var res = new Map(), elAttrs = element.attributes, i = 0; i < elAttrs.length; i++) {
                    var attrib = elAttrs.item(i);
                    res.set(attrib.name, attrib.value);
                }
                return res;
            }, BrowserDomAdapter.prototype.hasAttribute = function(element, attribute) {
                return element.hasAttribute(attribute);
            }, BrowserDomAdapter.prototype.hasAttributeNS = function(element, ns, attribute) {
                return element.hasAttributeNS(ns, attribute);
            }, BrowserDomAdapter.prototype.getAttribute = function(element, attribute) {
                return element.getAttribute(attribute);
            }, BrowserDomAdapter.prototype.getAttributeNS = function(element, ns, name) {
                return element.getAttributeNS(ns, name);
            }, BrowserDomAdapter.prototype.setAttribute = function(element, name, value) {
                element.setAttribute(name, value);
            }, BrowserDomAdapter.prototype.setAttributeNS = function(element, ns, name, value) {
                element.setAttributeNS(ns, name, value);
            }, BrowserDomAdapter.prototype.removeAttribute = function(element, attribute) {
                element.removeAttribute(attribute);
            }, BrowserDomAdapter.prototype.removeAttributeNS = function(element, ns, name) {
                element.removeAttributeNS(ns, name);
            }, BrowserDomAdapter.prototype.templateAwareRoot = function(el) {
                return this.isTemplateElement(el) ? this.content(el) : el;
            }, BrowserDomAdapter.prototype.createHtmlDocument = function() {
                return document.implementation.createHTMLDocument("fakeTitle");
            }, BrowserDomAdapter.prototype.getDefaultDocument = function() {
                return document;
            }, BrowserDomAdapter.prototype.getBoundingClientRect = function(el) {
                try {
                    return el.getBoundingClientRect();
                } catch (_a) {
                    return {
                        top: 0,
                        bottom: 0,
                        left: 0,
                        right: 0,
                        width: 0,
                        height: 0
                    };
                }
            }, BrowserDomAdapter.prototype.getTitle = function(doc) {
                return doc.title;
            }, BrowserDomAdapter.prototype.setTitle = function(doc, newTitle) {
                doc.title = newTitle || "";
            }, BrowserDomAdapter.prototype.elementMatches = function(n, selector) {
                return !!this.isElementNode(n) && (n.matches && n.matches(selector) || n.msMatchesSelector && n.msMatchesSelector(selector) || n.webkitMatchesSelector && n.webkitMatchesSelector(selector));
            }, BrowserDomAdapter.prototype.isTemplateElement = function(el) {
                return this.isElementNode(el) && "TEMPLATE" === el.nodeName;
            }, BrowserDomAdapter.prototype.isTextNode = function(node) {
                return node.nodeType === Node.TEXT_NODE;
            }, BrowserDomAdapter.prototype.isCommentNode = function(node) {
                return node.nodeType === Node.COMMENT_NODE;
            }, BrowserDomAdapter.prototype.isElementNode = function(node) {
                return node.nodeType === Node.ELEMENT_NODE;
            }, BrowserDomAdapter.prototype.hasShadowRoot = function(node) {
                return null != node.shadowRoot && node instanceof HTMLElement;
            }, BrowserDomAdapter.prototype.isShadowRoot = function(node) {
                return node instanceof DocumentFragment;
            }, BrowserDomAdapter.prototype.importIntoDoc = function(node) {
                return document.importNode(this.templateAwareRoot(node), !0);
            }, BrowserDomAdapter.prototype.adoptNode = function(node) {
                return document.adoptNode(node);
            }, BrowserDomAdapter.prototype.getHref = function(el) {
                return el.getAttribute("href");
            }, BrowserDomAdapter.prototype.getEventKey = function(event) {
                var key = event.key;
                if (null == key) {
                    if (null == (key = event.keyIdentifier)) return "Unidentified";
                    key.startsWith("U+") && (key = String.fromCharCode(parseInt(key.substring(2), 16)), 
                    3 === event.location && _chromeNumKeyPadMap.hasOwnProperty(key) && (key = _chromeNumKeyPadMap[key]));
                }
                return _keyMap[key] || key;
            }, BrowserDomAdapter.prototype.getGlobalEventTarget = function(doc, target) {
                return "window" === target ? window : "document" === target ? doc : "body" === target ? doc.body : null;
            }, BrowserDomAdapter.prototype.getHistory = function() {
                return window.history;
            }, BrowserDomAdapter.prototype.getLocation = function() {
                return window.location;
            }, BrowserDomAdapter.prototype.getBaseHref = function(doc) {
                var url, href = baseElement || (baseElement = document.querySelector("base")) ? baseElement.getAttribute("href") : null;
                return null == href ? null : (url = href, urlParsingNode || (urlParsingNode = document.createElement("a")), 
                urlParsingNode.setAttribute("href", url), "/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : "/" + urlParsingNode.pathname);
            }, BrowserDomAdapter.prototype.resetBaseElement = function() {
                baseElement = null;
            }, BrowserDomAdapter.prototype.getUserAgent = function() {
                return window.navigator.userAgent;
            }, BrowserDomAdapter.prototype.setData = function(element, name, value) {
                this.setAttribute(element, "data-" + name, value);
            }, BrowserDomAdapter.prototype.getData = function(element, name) {
                return this.getAttribute(element, "data-" + name);
            }, BrowserDomAdapter.prototype.getComputedStyle = function(element) {
                return getComputedStyle(element);
            }, BrowserDomAdapter.prototype.supportsWebAnimation = function() {
                return "function" == typeof Element.prototype.animate;
            }, BrowserDomAdapter.prototype.performanceNow = function() {
                return window.performance && window.performance.now ? window.performance.now() : new Date().getTime();
            }, BrowserDomAdapter.prototype.supportsCookies = function() {
                return !0;
            }, BrowserDomAdapter.prototype.getCookie = function(name) {
                return parseCookieValue(document.cookie, name);
            }, BrowserDomAdapter.prototype.setCookie = function(name, value) {
                document.cookie = encodeURIComponent(name) + "=" + encodeURIComponent(value);
            }, BrowserDomAdapter;
        }(function(_super) {
            function GenericBrowserDomAdapter() {
                var _this = _super.call(this) || this;
                _this._animationPrefix = null, _this._transitionEnd = null;
                try {
                    var element_1 = _this.createElement("div", document);
                    if (null != _this.getStyle(element_1, "animationName")) _this._animationPrefix = ""; else for (var domPrefixes = [ "Webkit", "Moz", "O", "ms" ], i = 0; i < domPrefixes.length; i++) if (null != _this.getStyle(element_1, domPrefixes[i] + "AnimationName")) {
                        _this._animationPrefix = "-" + domPrefixes[i].toLowerCase() + "-";
                        break;
                    }
                    var transEndEventNames_1 = {
                        WebkitTransition: "webkitTransitionEnd",
                        MozTransition: "transitionend",
                        OTransition: "oTransitionEnd otransitionend",
                        transition: "transitionend"
                    };
                    Object.keys(transEndEventNames_1).forEach(function(key) {
                        null != _this.getStyle(element_1, key) && (_this._transitionEnd = transEndEventNames_1[key]);
                    });
                } catch (_a) {
                    _this._animationPrefix = null, _this._transitionEnd = null;
                }
                return _this;
            }
            return __extends(GenericBrowserDomAdapter, _super), GenericBrowserDomAdapter.prototype.getDistributedNodes = function(el) {
                return el.getDistributedNodes();
            }, GenericBrowserDomAdapter.prototype.resolveAndSetHref = function(el, baseUrl, href) {
                el.href = null == href ? baseUrl : baseUrl + "/../" + href;
            }, GenericBrowserDomAdapter.prototype.supportsDOMEvents = function() {
                return !0;
            }, GenericBrowserDomAdapter.prototype.supportsNativeShadowDOM = function() {
                return "function" == typeof document.body.createShadowRoot;
            }, GenericBrowserDomAdapter.prototype.getAnimationPrefix = function() {
                return this._animationPrefix ? this._animationPrefix : "";
            }, GenericBrowserDomAdapter.prototype.getTransitionEnd = function() {
                return this._transitionEnd ? this._transitionEnd : "";
            }, GenericBrowserDomAdapter.prototype.supportsAnimation = function() {
                return null != this._animationPrefix && null != this._transitionEnd;
            }, GenericBrowserDomAdapter;
        }(function() {
            function DomAdapter() {
                this.resourceLoaderType = null;
            }
            return Object.defineProperty(DomAdapter.prototype, "attrToPropMap", {
                get: function() {
                    return this._attrToPropMap;
                },
                set: function(value) {
                    this._attrToPropMap = value;
                },
                enumerable: !0,
                configurable: !0
            }), DomAdapter;
        }())), baseElement = null;
        function supportsState() {
            return !!window.history.pushState;
        }
        var platform_browser_BrowserPlatformLocation = function(_super) {
            function BrowserPlatformLocation(_doc) {
                var _this = _super.call(this) || this;
                return _this._doc = _doc, _this._init(), _this;
            }
            var decorator;
            return __extends(BrowserPlatformLocation, _super), BrowserPlatformLocation.prototype._init = function() {
                this.location = getDOM().getLocation(), this._history = getDOM().getHistory();
            }, BrowserPlatformLocation.prototype.getBaseHrefFromDOM = function() {
                return getDOM().getBaseHref(this._doc);
            }, BrowserPlatformLocation.prototype.onPopState = function(fn) {
                getDOM().getGlobalEventTarget(this._doc, "window").addEventListener("popstate", fn, !1);
            }, BrowserPlatformLocation.prototype.onHashChange = function(fn) {
                getDOM().getGlobalEventTarget(this._doc, "window").addEventListener("hashchange", fn, !1);
            }, Object.defineProperty(BrowserPlatformLocation.prototype, "pathname", {
                get: function() {
                    return this.location.pathname;
                },
                set: function(newPath) {
                    this.location.pathname = newPath;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(BrowserPlatformLocation.prototype, "search", {
                get: function() {
                    return this.location.search;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(BrowserPlatformLocation.prototype, "hash", {
                get: function() {
                    return this.location.hash;
                },
                enumerable: !0,
                configurable: !0
            }), BrowserPlatformLocation.prototype.pushState = function(state, title, url) {
                supportsState() ? this._history.pushState(state, title, url) : this.location.hash = url;
            }, BrowserPlatformLocation.prototype.replaceState = function(state, title, url) {
                supportsState() ? this._history.replaceState(state, title, url) : this.location.hash = url;
            }, BrowserPlatformLocation.prototype.forward = function() {
                this._history.forward();
            }, BrowserPlatformLocation.prototype.back = function() {
                this._history.back();
            }, (BrowserPlatformLocation = __decorate([ (decorator = Inject(DOCUMENT), function(target, key) {
                decorator(target, key, 0);
            }), __metadata("design:paramtypes", [ Object ]) ], BrowserPlatformLocation)).ngInjectableDef = defineInjectable({
                token: BrowserPlatformLocation,
                factory: function(t) {
                    return new (t || BrowserPlatformLocation)(inject(DOCUMENT));
                },
                providedIn: null
            }), BrowserPlatformLocation;
        }(PlatformLocation), TRANSITION_ID = new InjectionToken("TRANSITION_ID"), SERVER_TRANSITION_PROVIDERS = [ {
            provide: APP_INITIALIZER,
            useFactory: function(transitionId, document, injector) {
                return function() {
                    injector.get(ApplicationInitStatus).donePromise.then(function() {
                        var dom = getDOM();
                        Array.prototype.slice.apply(dom.querySelectorAll(document, "style[ng-transition]")).filter(function(el) {
                            return dom.getAttribute(el, "ng-transition") === transitionId;
                        }).forEach(function(el) {
                            return dom.remove(el);
                        });
                    });
                };
            },
            deps: [ TRANSITION_ID, DOCUMENT, Injector ],
            multi: !0
        } ], platform_browser_BrowserGetTestability = function() {
            function BrowserGetTestability() {}
            return BrowserGetTestability.init = function() {
                var getter;
                getter = new BrowserGetTestability(), _testabilityGetter = getter;
            }, BrowserGetTestability.prototype.addToWindow = function(registry) {
                _global.getAngularTestability = function(elem, findInAncestors) {
                    void 0 === findInAncestors && (findInAncestors = !0);
                    var testability = registry.findTestabilityInTree(elem, findInAncestors);
                    if (null == testability) throw new Error("Could not find testability for element.");
                    return testability;
                }, _global.getAllAngularTestabilities = function() {
                    return registry.getAllTestabilities();
                }, _global.getAllAngularRootElements = function() {
                    return registry.getAllRootElements();
                }, _global.frameworkStabilizers || (_global.frameworkStabilizers = []), _global.frameworkStabilizers.push(function(callback) {
                    var testabilities = _global.getAllAngularTestabilities(), count = testabilities.length, didWork = !1, decrement = function(didWork_) {
                        didWork = didWork || didWork_, 0 == --count && callback(didWork);
                    };
                    testabilities.forEach(function(testability) {
                        testability.whenStable(decrement);
                    });
                });
            }, BrowserGetTestability.prototype.findTestabilityInTree = function(registry, elem, findInAncestors) {
                if (null == elem) return null;
                var t = registry.getTestability(elem);
                return null != t ? t : findInAncestors ? getDOM().isShadowRoot(elem) ? this.findTestabilityInTree(registry, getDOM().getHost(elem), !0) : this.findTestabilityInTree(registry, getDOM().parentElement(elem), !0) : null;
            }, BrowserGetTestability;
        }();
        function exportNgVar(name, value) {
            "undefined" != typeof COMPILED && COMPILED || ((_global.ng = _global.ng || {})[name] = value);
        }
        var CORE_TOKENS = {
            ApplicationRef: core_ApplicationRef,
            NgZone: NgZone
        };
        function inspectNativeElement(element) {
            return getDebugNode(element);
        }
        var ELEMENT_PROBE_PROVIDERS = [ {
            provide: APP_INITIALIZER,
            useFactory: function(coreTokens) {
                return exportNgVar("probe", inspectNativeElement), exportNgVar("coreTokens", __assign({}, CORE_TOKENS, (coreTokens || []).reduce(function(prev, t) {
                    return prev[t.name] = t.token, prev;
                }, {}))), function() {
                    return inspectNativeElement;
                };
            },
            deps: [ [ NgProbeToken, new Optional() ] ],
            multi: !0
        } ], EVENT_MANAGER_PLUGINS = new InjectionToken("EventManagerPlugins"), platform_browser_EventManager = function() {
            function EventManager(plugins, _zone) {
                var _this = this;
                this._zone = _zone, this._eventNameToPlugin = new Map(), plugins.forEach(function(p) {
                    return p.manager = _this;
                }), this._plugins = plugins.slice().reverse();
            }
            return EventManager.prototype.addEventListener = function(element, eventName, handler) {
                return this._findPluginFor(eventName).addEventListener(element, eventName, handler);
            }, EventManager.prototype.addGlobalEventListener = function(target, eventName, handler) {
                return this._findPluginFor(eventName).addGlobalEventListener(target, eventName, handler);
            }, EventManager.prototype.getZone = function() {
                return this._zone;
            }, EventManager.prototype._findPluginFor = function(eventName) {
                var plugin = this._eventNameToPlugin.get(eventName);
                if (plugin) return plugin;
                for (var plugins = this._plugins, i = 0; i < plugins.length; i++) {
                    var plugin_1 = plugins[i];
                    if (plugin_1.supports(eventName)) return this._eventNameToPlugin.set(eventName, plugin_1), 
                    plugin_1;
                }
                throw new Error("No event manager plugin found for event " + eventName);
            }, EventManager.ngInjectableDef = defineInjectable({
                token: EventManager,
                factory: function(t) {
                    return new (t || EventManager)(inject(EVENT_MANAGER_PLUGINS), inject(NgZone));
                },
                providedIn: null
            }), EventManager;
        }(), EventManagerPlugin = function() {
            function EventManagerPlugin(_doc) {
                this._doc = _doc;
            }
            return EventManagerPlugin.prototype.addGlobalEventListener = function(element, eventName, handler) {
                var target = getDOM().getGlobalEventTarget(this._doc, element);
                if (!target) throw new Error("Unsupported event target " + target + " for event " + eventName);
                return this.addEventListener(target, eventName, handler);
            }, EventManagerPlugin;
        }(), platform_browser_SharedStylesHost = function() {
            function SharedStylesHost() {
                this._stylesSet = new Set();
            }
            return SharedStylesHost.prototype.addStyles = function(styles) {
                var _this = this, additions = new Set();
                styles.forEach(function(style) {
                    _this._stylesSet.has(style) || (_this._stylesSet.add(style), additions.add(style));
                }), this.onStylesAdded(additions);
            }, SharedStylesHost.prototype.onStylesAdded = function(additions) {}, SharedStylesHost.prototype.getAllStyles = function() {
                return Array.from(this._stylesSet);
            }, SharedStylesHost.ngInjectableDef = defineInjectable({
                token: SharedStylesHost,
                factory: function(t) {
                    return new (t || SharedStylesHost)();
                },
                providedIn: null
            }), SharedStylesHost;
        }(), platform_browser_DomSharedStylesHost = function(_super) {
            function DomSharedStylesHost(_doc) {
                var _this = _super.call(this) || this;
                return _this._doc = _doc, _this._hostNodes = new Set(), _this._styleNodes = new Set(), 
                _this._hostNodes.add(_doc.head), _this;
            }
            return __extends(DomSharedStylesHost, _super), DomSharedStylesHost.prototype._addStylesToHost = function(styles, host) {
                var _this = this;
                styles.forEach(function(style) {
                    var styleEl = _this._doc.createElement("style");
                    styleEl.textContent = style, _this._styleNodes.add(host.appendChild(styleEl));
                });
            }, DomSharedStylesHost.prototype.addHost = function(hostNode) {
                this._addStylesToHost(this._stylesSet, hostNode), this._hostNodes.add(hostNode);
            }, DomSharedStylesHost.prototype.removeHost = function(hostNode) {
                this._hostNodes.delete(hostNode);
            }, DomSharedStylesHost.prototype.onStylesAdded = function(additions) {
                var _this = this;
                this._hostNodes.forEach(function(hostNode) {
                    return _this._addStylesToHost(additions, hostNode);
                });
            }, DomSharedStylesHost.prototype.ngOnDestroy = function() {
                this._styleNodes.forEach(function(styleNode) {
                    return getDOM().remove(styleNode);
                });
            }, DomSharedStylesHost.ngInjectableDef = defineInjectable({
                token: DomSharedStylesHost,
                factory: function(t) {
                    return new (t || DomSharedStylesHost)(inject(DOCUMENT));
                },
                providedIn: null
            }), DomSharedStylesHost;
        }(platform_browser_SharedStylesHost), NAMESPACE_URIS = {
            svg: "http://www.w3.org/2000/svg",
            xhtml: "http://www.w3.org/1999/xhtml",
            xlink: "http://www.w3.org/1999/xlink",
            xml: "http://www.w3.org/XML/1998/namespace",
            xmlns: "http://www.w3.org/2000/xmlns/"
        }, COMPONENT_REGEX = /%COMP%/g, HOST_ATTR = "_nghost-%COMP%", CONTENT_ATTR = "_ngcontent-%COMP%";
        function flattenStyles(compId, styles, target) {
            for (var i = 0; i < styles.length; i++) {
                var style = styles[i];
                Array.isArray(style) ? flattenStyles(compId, style, target) : (style = style.replace(COMPONENT_REGEX, compId), 
                target.push(style));
            }
            return target;
        }
        function decoratePreventDefault(eventHandler) {
            return function(event) {
                !1 === eventHandler(event) && (event.preventDefault(), event.returnValue = !1);
            };
        }
        var platform_browser_DomRendererFactory2 = function() {
            function DomRendererFactory2(eventManager, sharedStylesHost) {
                this.eventManager = eventManager, this.sharedStylesHost = sharedStylesHost, this.rendererByCompId = new Map(), 
                this.defaultRenderer = new platform_browser_DefaultDomRenderer2(eventManager);
            }
            return DomRendererFactory2.prototype.createRenderer = function(element, type) {
                if (!element || !type) return this.defaultRenderer;
                switch (type.encapsulation) {
                  case ViewEncapsulation.Emulated:
                    var renderer = this.rendererByCompId.get(type.id);
                    return renderer || (renderer = new platform_browser_EmulatedEncapsulationDomRenderer2(this.eventManager, this.sharedStylesHost, type), 
                    this.rendererByCompId.set(type.id, renderer)), renderer.applyToHost(element), renderer;

                  case ViewEncapsulation.Native:
                  case ViewEncapsulation.ShadowDom:
                    return new platform_browser_ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);

                  default:
                    if (!this.rendererByCompId.has(type.id)) {
                        var styles = flattenStyles(type.id, type.styles, []);
                        this.sharedStylesHost.addStyles(styles), this.rendererByCompId.set(type.id, this.defaultRenderer);
                    }
                    return this.defaultRenderer;
                }
            }, DomRendererFactory2.prototype.begin = function() {}, DomRendererFactory2.prototype.end = function() {}, 
            DomRendererFactory2.ngInjectableDef = defineInjectable({
                token: DomRendererFactory2,
                factory: function(t) {
                    return new (t || DomRendererFactory2)(inject(platform_browser_EventManager), inject(platform_browser_DomSharedStylesHost));
                },
                providedIn: null
            }), DomRendererFactory2;
        }(), platform_browser_DefaultDomRenderer2 = function() {
            function DefaultDomRenderer2(eventManager) {
                this.eventManager = eventManager, this.data = Object.create(null);
            }
            return DefaultDomRenderer2.prototype.destroy = function() {}, DefaultDomRenderer2.prototype.createElement = function(name, namespace) {
                return namespace ? document.createElementNS(NAMESPACE_URIS[namespace] || namespace, name) : document.createElement(name);
            }, DefaultDomRenderer2.prototype.createComment = function(value) {
                return document.createComment(value);
            }, DefaultDomRenderer2.prototype.createText = function(value) {
                return document.createTextNode(value);
            }, DefaultDomRenderer2.prototype.appendChild = function(parent, newChild) {
                parent.appendChild(newChild);
            }, DefaultDomRenderer2.prototype.insertBefore = function(parent, newChild, refChild) {
                parent && parent.insertBefore(newChild, refChild);
            }, DefaultDomRenderer2.prototype.removeChild = function(parent, oldChild) {
                parent && parent.removeChild(oldChild);
            }, DefaultDomRenderer2.prototype.selectRootElement = function(selectorOrNode, preserveContent) {
                var el = "string" == typeof selectorOrNode ? document.querySelector(selectorOrNode) : selectorOrNode;
                if (!el) throw new Error('The selector "' + selectorOrNode + '" did not match any elements');
                return preserveContent || (el.textContent = ""), el;
            }, DefaultDomRenderer2.prototype.parentNode = function(node) {
                return node.parentNode;
            }, DefaultDomRenderer2.prototype.nextSibling = function(node) {
                return node.nextSibling;
            }, DefaultDomRenderer2.prototype.setAttribute = function(el, name, value, namespace) {
                if (namespace) {
                    name = namespace + ":" + name;
                    var namespaceUri = NAMESPACE_URIS[namespace];
                    namespaceUri ? el.setAttributeNS(namespaceUri, name, value) : el.setAttribute(name, value);
                } else el.setAttribute(name, value);
            }, DefaultDomRenderer2.prototype.removeAttribute = function(el, name, namespace) {
                if (namespace) {
                    var namespaceUri = NAMESPACE_URIS[namespace];
                    namespaceUri ? el.removeAttributeNS(namespaceUri, name) : el.removeAttribute(namespace + ":" + name);
                } else el.removeAttribute(name);
            }, DefaultDomRenderer2.prototype.addClass = function(el, name) {
                el.classList.add(name);
            }, DefaultDomRenderer2.prototype.removeClass = function(el, name) {
                el.classList.remove(name);
            }, DefaultDomRenderer2.prototype.setStyle = function(el, style, value, flags) {
                flags & RendererStyleFlags2.DashCase ? el.style.setProperty(style, value, flags & RendererStyleFlags2.Important ? "important" : "") : el.style[style] = value;
            }, DefaultDomRenderer2.prototype.removeStyle = function(el, style, flags) {
                flags & RendererStyleFlags2.DashCase ? el.style.removeProperty(style) : el.style[style] = "";
            }, DefaultDomRenderer2.prototype.setProperty = function(el, name, value) {
                checkNoSyntheticProp(name, "property"), el[name] = value;
            }, DefaultDomRenderer2.prototype.setValue = function(node, value) {
                node.nodeValue = value;
            }, DefaultDomRenderer2.prototype.listen = function(target, event, callback) {
                return checkNoSyntheticProp(event, "listener"), "string" == typeof target ? this.eventManager.addGlobalEventListener(target, event, decoratePreventDefault(callback)) : this.eventManager.addEventListener(target, event, decoratePreventDefault(callback));
            }, DefaultDomRenderer2;
        }(), AT_CHARCODE = "@".charCodeAt(0);
        function checkNoSyntheticProp(name, nameKind) {
            if (name.charCodeAt(0) === AT_CHARCODE) throw new Error("Found the synthetic " + nameKind + " " + name + '. Please include either "BrowserAnimationsModule" or "NoopAnimationsModule" in your application.');
        }
        var blackListedMap, platform_browser_EmulatedEncapsulationDomRenderer2 = function(_super) {
            function EmulatedEncapsulationDomRenderer2(eventManager, sharedStylesHost, component) {
                var _this = _super.call(this, eventManager) || this;
                _this.component = component;
                var styles = flattenStyles(component.id, component.styles, []);
                return sharedStylesHost.addStyles(styles), _this.contentAttr = CONTENT_ATTR.replace(COMPONENT_REGEX, component.id), 
                _this.hostAttr = HOST_ATTR.replace(COMPONENT_REGEX, component.id), _this;
            }
            return __extends(EmulatedEncapsulationDomRenderer2, _super), EmulatedEncapsulationDomRenderer2.prototype.applyToHost = function(element) {
                _super.prototype.setAttribute.call(this, element, this.hostAttr, "");
            }, EmulatedEncapsulationDomRenderer2.prototype.createElement = function(parent, name) {
                var el = _super.prototype.createElement.call(this, parent, name);
                return _super.prototype.setAttribute.call(this, el, this.contentAttr, ""), el;
            }, EmulatedEncapsulationDomRenderer2;
        }(platform_browser_DefaultDomRenderer2), platform_browser_ShadowDomRenderer = function(_super) {
            function ShadowDomRenderer(eventManager, sharedStylesHost, hostEl, component) {
                var _this = _super.call(this, eventManager) || this;
                _this.sharedStylesHost = sharedStylesHost, _this.hostEl = hostEl, _this.component = component, 
                _this.shadowRoot = component.encapsulation === ViewEncapsulation.ShadowDom ? hostEl.attachShadow({
                    mode: "open"
                }) : hostEl.createShadowRoot(), _this.sharedStylesHost.addHost(_this.shadowRoot);
                for (var styles = flattenStyles(component.id, component.styles, []), i = 0; i < styles.length; i++) {
                    var styleEl = document.createElement("style");
                    styleEl.textContent = styles[i], _this.shadowRoot.appendChild(styleEl);
                }
                return _this;
            }
            return __extends(ShadowDomRenderer, _super), ShadowDomRenderer.prototype.nodeOrShadowRoot = function(node) {
                return node === this.hostEl ? this.shadowRoot : node;
            }, ShadowDomRenderer.prototype.destroy = function() {
                this.sharedStylesHost.removeHost(this.shadowRoot);
            }, ShadowDomRenderer.prototype.appendChild = function(parent, newChild) {
                return _super.prototype.appendChild.call(this, this.nodeOrShadowRoot(parent), newChild);
            }, ShadowDomRenderer.prototype.insertBefore = function(parent, newChild, refChild) {
                return _super.prototype.insertBefore.call(this, this.nodeOrShadowRoot(parent), newChild, refChild);
            }, ShadowDomRenderer.prototype.removeChild = function(parent, oldChild) {
                return _super.prototype.removeChild.call(this, this.nodeOrShadowRoot(parent), oldChild);
            }, ShadowDomRenderer.prototype.parentNode = function(node) {
                return this.nodeOrShadowRoot(_super.prototype.parentNode.call(this, this.nodeOrShadowRoot(node)));
            }, ShadowDomRenderer;
        }(platform_browser_DefaultDomRenderer2), __symbol__ = "undefined" != typeof Zone && Zone.__symbol__ || function(v) {
            return "__zone_symbol__" + v;
        }, ADD_EVENT_LISTENER = __symbol__("addEventListener"), REMOVE_EVENT_LISTENER = __symbol__("removeEventListener"), symbolNames = {}, stopSymbol = "__zone_symbol__propagationStopped";
        "undefined" != typeof Zone && Zone[__symbol__("BLACK_LISTED_EVENTS")] && (blackListedMap = {});
        var isBlackListedEvent = function(eventName) {
            return !!blackListedMap && blackListedMap.hasOwnProperty(eventName);
        }, globalListener = function(event) {
            var symbolName = symbolNames[event.type];
            if (symbolName) {
                var taskDatas = this[symbolName];
                if (taskDatas) {
                    var args = [ event ];
                    if (1 === taskDatas.length) return (taskData = taskDatas[0]).zone !== Zone.current ? taskData.zone.run(taskData.handler, this, args) : taskData.handler.apply(this, args);
                    for (var copiedTasks = taskDatas.slice(), i = 0; i < copiedTasks.length && !0 !== event[stopSymbol]; i++) {
                        var taskData;
                        (taskData = copiedTasks[i]).zone !== Zone.current ? taskData.zone.run(taskData.handler, this, args) : taskData.handler.apply(this, args);
                    }
                }
            }
        }, platform_browser_DomEventsPlugin = function(_super) {
            function DomEventsPlugin(doc, ngZone, platformId) {
                var _this = _super.call(this, doc) || this;
                return _this.ngZone = ngZone, platformId && function(platformId) {
                    return platformId === PLATFORM_SERVER_ID;
                }(platformId) || _this.patchEvent(), _this;
            }
            return __extends(DomEventsPlugin, _super), DomEventsPlugin.prototype.patchEvent = function() {
                if ("undefined" != typeof Event && Event && Event.prototype && !Event.prototype.__zone_symbol__stopImmediatePropagation) {
                    var delegate = Event.prototype.__zone_symbol__stopImmediatePropagation = Event.prototype.stopImmediatePropagation;
                    Event.prototype.stopImmediatePropagation = function() {
                        this && (this[stopSymbol] = !0), delegate && delegate.apply(this, arguments);
                    };
                }
            }, DomEventsPlugin.prototype.supports = function(eventName) {
                return !0;
            }, DomEventsPlugin.prototype.addEventListener = function(element, eventName, handler) {
                var _this = this, callback = handler;
                if (!element[ADD_EVENT_LISTENER] || NgZone.isInAngularZone() && !isBlackListedEvent(eventName)) element.addEventListener(eventName, callback, !1); else {
                    var symbolName = symbolNames[eventName];
                    symbolName || (symbolName = symbolNames[eventName] = __symbol__("ANGULAR" + eventName + "FALSE"));
                    var taskDatas = element[symbolName], globalListenerRegistered = taskDatas && taskDatas.length > 0;
                    taskDatas || (taskDatas = element[symbolName] = []);
                    var zone = isBlackListedEvent(eventName) ? Zone.root : Zone.current;
                    if (0 === taskDatas.length) taskDatas.push({
                        zone: zone,
                        handler: callback
                    }); else {
                        for (var callbackRegistered = !1, i = 0; i < taskDatas.length; i++) if (taskDatas[i].handler === callback) {
                            callbackRegistered = !0;
                            break;
                        }
                        callbackRegistered || taskDatas.push({
                            zone: zone,
                            handler: callback
                        });
                    }
                    globalListenerRegistered || element[ADD_EVENT_LISTENER](eventName, globalListener, !1);
                }
                return function() {
                    return _this.removeEventListener(element, eventName, callback);
                };
            }, DomEventsPlugin.prototype.removeEventListener = function(target, eventName, callback) {
                var underlyingRemove = target[REMOVE_EVENT_LISTENER];
                if (!underlyingRemove) return target.removeEventListener.apply(target, [ eventName, callback, !1 ]);
                var symbolName = symbolNames[eventName], taskDatas = symbolName && target[symbolName];
                if (!taskDatas) return target.removeEventListener.apply(target, [ eventName, callback, !1 ]);
                for (var found = !1, i = 0; i < taskDatas.length; i++) if (taskDatas[i].handler === callback) {
                    found = !0, taskDatas.splice(i, 1);
                    break;
                }
                found ? 0 === taskDatas.length && underlyingRemove.apply(target, [ eventName, globalListener, !1 ]) : target.removeEventListener.apply(target, [ eventName, callback, !1 ]);
            }, DomEventsPlugin.ngInjectableDef = defineInjectable({
                token: DomEventsPlugin,
                factory: function(t) {
                    return new (t || DomEventsPlugin)(inject(DOCUMENT), inject(NgZone), inject(PLATFORM_ID, 8));
                },
                providedIn: null
            }), DomEventsPlugin;
        }(EventManagerPlugin), EVENT_NAMES = {
            pan: !0,
            panstart: !0,
            panmove: !0,
            panend: !0,
            pancancel: !0,
            panleft: !0,
            panright: !0,
            panup: !0,
            pandown: !0,
            pinch: !0,
            pinchstart: !0,
            pinchmove: !0,
            pinchend: !0,
            pinchcancel: !0,
            pinchin: !0,
            pinchout: !0,
            press: !0,
            pressup: !0,
            rotate: !0,
            rotatestart: !0,
            rotatemove: !0,
            rotateend: !0,
            rotatecancel: !0,
            swipe: !0,
            swipeleft: !0,
            swiperight: !0,
            swipeup: !0,
            swipedown: !0,
            tap: !0
        }, HAMMER_GESTURE_CONFIG = new InjectionToken("HammerGestureConfig"), HAMMER_LOADER = new InjectionToken("HammerLoader"), platform_browser_HammerGestureConfig = function() {
            function HammerGestureConfig() {
                this.events = [], this.overrides = {};
            }
            return HammerGestureConfig.prototype.buildHammer = function(element) {
                var mc = new Hammer(element, this.options);
                for (var eventName in mc.get("pinch").set({
                    enable: !0
                }), mc.get("rotate").set({
                    enable: !0
                }), this.overrides) mc.get(eventName).set(this.overrides[eventName]);
                return mc;
            }, HammerGestureConfig.ngInjectableDef = defineInjectable({
                token: HammerGestureConfig,
                factory: function(t) {
                    return new (t || HammerGestureConfig)();
                },
                providedIn: null
            }), HammerGestureConfig;
        }(), platform_browser_HammerGesturesPlugin = function(_super) {
            function HammerGesturesPlugin(doc, _config, console, loader) {
                var _this = _super.call(this, doc) || this;
                return _this._config = _config, _this.console = console, _this.loader = loader, 
                _this;
            }
            return __extends(HammerGesturesPlugin, _super), HammerGesturesPlugin.prototype.supports = function(eventName) {
                return !(!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName) || !window.Hammer && !this.loader && (this.console.warn('The "' + eventName + '" event cannot be bound because Hammer.JS is not loaded and no custom loader has been specified.'), 
                1));
            }, HammerGesturesPlugin.prototype.addEventListener = function(element, eventName, handler) {
                var _this = this, zone = this.manager.getZone();
                if (eventName = eventName.toLowerCase(), !window.Hammer && this.loader) {
                    var cancelRegistration_1 = !1, deregister_1 = function() {
                        cancelRegistration_1 = !0;
                    };
                    return this.loader().then(function() {
                        if (!window.Hammer) return _this.console.warn("The custom HAMMER_LOADER completed, but Hammer.JS is not present."), 
                        void (deregister_1 = function() {});
                        cancelRegistration_1 || (deregister_1 = _this.addEventListener(element, eventName, handler));
                    }).catch(function() {
                        _this.console.warn('The "' + eventName + '" event cannot be bound because the custom Hammer.JS loader failed.'), 
                        deregister_1 = function() {};
                    }), function() {
                        deregister_1();
                    };
                }
                return zone.runOutsideAngular(function() {
                    var mc = _this._config.buildHammer(element), callback = function(eventObj) {
                        zone.runGuarded(function() {
                            handler(eventObj);
                        });
                    };
                    return mc.on(eventName, callback), function() {
                        mc.off(eventName, callback), "function" == typeof mc.destroy && mc.destroy();
                    };
                });
            }, HammerGesturesPlugin.prototype.isCustomEvent = function(eventName) {
                return this._config.events.indexOf(eventName) > -1;
            }, HammerGesturesPlugin.ngInjectableDef = defineInjectable({
                token: HammerGesturesPlugin,
                factory: function(t) {
                    return new (t || HammerGesturesPlugin)(inject(DOCUMENT), inject(HAMMER_GESTURE_CONFIG), inject(Console), inject(HAMMER_LOADER, 8));
                },
                providedIn: null
            }), HammerGesturesPlugin;
        }(EventManagerPlugin), MODIFIER_KEYS = [ "alt", "control", "meta", "shift" ], MODIFIER_KEY_GETTERS = {
            alt: function(event) {
                return event.altKey;
            },
            control: function(event) {
                return event.ctrlKey;
            },
            meta: function(event) {
                return event.metaKey;
            },
            shift: function(event) {
                return event.shiftKey;
            }
        }, platform_browser_KeyEventsPlugin = function(_super) {
            function KeyEventsPlugin(doc) {
                return _super.call(this, doc) || this;
            }
            var KeyEventsPlugin_1;
            return __extends(KeyEventsPlugin, _super), KeyEventsPlugin_1 = KeyEventsPlugin, 
            KeyEventsPlugin.prototype.supports = function(eventName) {
                return null != KeyEventsPlugin_1.parseEventName(eventName);
            }, KeyEventsPlugin.prototype.addEventListener = function(element, eventName, handler) {
                var parsedEvent = KeyEventsPlugin_1.parseEventName(eventName), outsideHandler = KeyEventsPlugin_1.eventCallback(parsedEvent.fullKey, handler, this.manager.getZone());
                return this.manager.getZone().runOutsideAngular(function() {
                    return getDOM().onAndCancel(element, parsedEvent.domEventName, outsideHandler);
                });
            }, KeyEventsPlugin.parseEventName = function(eventName) {
                var parts = eventName.toLowerCase().split("."), domEventName = parts.shift();
                if (0 === parts.length || "keydown" !== domEventName && "keyup" !== domEventName) return null;
                var key = KeyEventsPlugin_1._normalizeKey(parts.pop()), fullKey = "";
                if (MODIFIER_KEYS.forEach(function(modifierName) {
                    var index = parts.indexOf(modifierName);
                    index > -1 && (parts.splice(index, 1), fullKey += modifierName + ".");
                }), fullKey += key, 0 != parts.length || 0 === key.length) return null;
                var result = {};
                return result.domEventName = domEventName, result.fullKey = fullKey, result;
            }, KeyEventsPlugin.getEventFullKey = function(event) {
                var fullKey = "", key = getDOM().getEventKey(event);
                return " " === (key = key.toLowerCase()) ? key = "space" : "." === key && (key = "dot"), 
                MODIFIER_KEYS.forEach(function(modifierName) {
                    modifierName != key && (0, MODIFIER_KEY_GETTERS[modifierName])(event) && (fullKey += modifierName + ".");
                }), fullKey += key;
            }, KeyEventsPlugin.eventCallback = function(fullKey, handler, zone) {
                return function(event) {
                    KeyEventsPlugin_1.getEventFullKey(event) === fullKey && zone.runGuarded(function() {
                        return handler(event);
                    });
                };
            }, KeyEventsPlugin._normalizeKey = function(keyName) {
                switch (keyName) {
                  case "esc":
                    return "escape";

                  default:
                    return keyName;
                }
            }, KeyEventsPlugin.ngInjectableDef = defineInjectable({
                token: KeyEventsPlugin,
                factory: function(t) {
                    return new (t || KeyEventsPlugin)(inject(DOCUMENT));
                },
                providedIn: null
            }), KeyEventsPlugin;
        }(EventManagerPlugin), DomSanitizer = function() {
            return function() {};
        }(), platform_browser_DomSanitizerImpl = function(_super) {
            function DomSanitizerImpl(_doc) {
                var _this = _super.call(this) || this;
                return _this._doc = _doc, _this;
            }
            return __extends(DomSanitizerImpl, _super), DomSanitizerImpl.prototype.sanitize = function(ctx, value) {
                if (null == value) return null;
                switch (ctx) {
                  case SecurityContext.NONE:
                    return value;

                  case SecurityContext.HTML:
                    return value instanceof platform_browser_SafeHtmlImpl ? value.changingThisBreaksApplicationSecurity : (this.checkNotSafeValue(value, "HTML"), 
                    function(defaultDoc, unsafeHtmlInput) {
                        var inertBodyElement = null;
                        try {
                            inertBodyHelper = inertBodyHelper || new InertBodyHelper(defaultDoc);
                            var unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : "";
                            inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
                            var mXSSAttempts = 5, parsedHtml = unsafeHtml;
                            do {
                                if (0 === mXSSAttempts) throw new Error("Failed to sanitize html because the input is unstable");
                                mXSSAttempts--, unsafeHtml = parsedHtml, parsedHtml = inertBodyElement.innerHTML, 
                                inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
                            } while (unsafeHtml !== parsedHtml);
                            var sanitizer = new SanitizingHtmlSerializer(), safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);
                            return isDevMode() && sanitizer.sanitizedSomething && console.warn("WARNING: sanitizing HTML stripped some content, see http://g.co/ng/security#xss"), 
                            safeHtml;
                        } finally {
                            if (inertBodyElement) for (var parent_1 = getTemplateContent(inertBodyElement) || inertBodyElement; parent_1.firstChild; ) parent_1.removeChild(parent_1.firstChild);
                        }
                    }(this._doc, String(value)));

                  case SecurityContext.STYLE:
                    return value instanceof platform_browser_SafeStyleImpl ? value.changingThisBreaksApplicationSecurity : (this.checkNotSafeValue(value, "Style"), 
                    function(value) {
                        if (!(value = String(value).trim())) return "";
                        var urlMatch = value.match(URL_RE);
                        return urlMatch && _sanitizeUrl(urlMatch[1]) === urlMatch[1] || value.match(SAFE_STYLE_VALUE) && function(value) {
                            for (var outsideSingle = !0, outsideDouble = !0, i = 0; i < value.length; i++) {
                                var c = value.charAt(i);
                                "'" === c && outsideDouble ? outsideSingle = !outsideSingle : '"' === c && outsideSingle && (outsideDouble = !outsideDouble);
                            }
                            return outsideSingle && outsideDouble;
                        }(value) ? value : (isDevMode() && console.warn("WARNING: sanitizing unsafe style value " + value + " (see http://g.co/ng/security#xss)."), 
                        "unsafe");
                    }(value));

                  case SecurityContext.SCRIPT:
                    if (value instanceof platform_browser_SafeScriptImpl) return value.changingThisBreaksApplicationSecurity;
                    throw this.checkNotSafeValue(value, "Script"), new Error("unsafe value used in a script context");

                  case SecurityContext.URL:
                    return value instanceof platform_browser_SafeResourceUrlImpl || value instanceof platform_browser_SafeUrlImpl ? value.changingThisBreaksApplicationSecurity : (this.checkNotSafeValue(value, "URL"), 
                    _sanitizeUrl(String(value)));

                  case SecurityContext.RESOURCE_URL:
                    if (value instanceof platform_browser_SafeResourceUrlImpl) return value.changingThisBreaksApplicationSecurity;
                    throw this.checkNotSafeValue(value, "ResourceURL"), new Error("unsafe value used in a resource URL context (see http://g.co/ng/security#xss)");

                  default:
                    throw new Error("Unexpected SecurityContext " + ctx + " (see http://g.co/ng/security#xss)");
                }
            }, DomSanitizerImpl.prototype.checkNotSafeValue = function(value, expectedType) {
                if (value instanceof SafeValueImpl) throw new Error("Required a safe " + expectedType + ", got a " + value.getTypeName() + " (see http://g.co/ng/security#xss)");
            }, DomSanitizerImpl.prototype.bypassSecurityTrustHtml = function(value) {
                return new platform_browser_SafeHtmlImpl(value);
            }, DomSanitizerImpl.prototype.bypassSecurityTrustStyle = function(value) {
                return new platform_browser_SafeStyleImpl(value);
            }, DomSanitizerImpl.prototype.bypassSecurityTrustScript = function(value) {
                return new platform_browser_SafeScriptImpl(value);
            }, DomSanitizerImpl.prototype.bypassSecurityTrustUrl = function(value) {
                return new platform_browser_SafeUrlImpl(value);
            }, DomSanitizerImpl.prototype.bypassSecurityTrustResourceUrl = function(value) {
                return new platform_browser_SafeResourceUrlImpl(value);
            }, DomSanitizerImpl.ngInjectableDef = defineInjectable({
                token: DomSanitizerImpl,
                factory: function(t) {
                    return new (t || DomSanitizerImpl)(inject(DOCUMENT));
                },
                providedIn: null
            }), DomSanitizerImpl;
        }(DomSanitizer), SafeValueImpl = function() {
            function SafeValueImpl(changingThisBreaksApplicationSecurity) {
                this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
            }
            return SafeValueImpl.prototype.toString = function() {
                return "SafeValue must use [property]=binding: " + this.changingThisBreaksApplicationSecurity + " (see http://g.co/ng/security#xss)";
            }, SafeValueImpl;
        }(), platform_browser_SafeHtmlImpl = function(_super) {
            function SafeHtmlImpl() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return __extends(SafeHtmlImpl, _super), SafeHtmlImpl.prototype.getTypeName = function() {
                return "HTML";
            }, SafeHtmlImpl;
        }(SafeValueImpl), platform_browser_SafeStyleImpl = function(_super) {
            function SafeStyleImpl() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return __extends(SafeStyleImpl, _super), SafeStyleImpl.prototype.getTypeName = function() {
                return "Style";
            }, SafeStyleImpl;
        }(SafeValueImpl), platform_browser_SafeScriptImpl = function(_super) {
            function SafeScriptImpl() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return __extends(SafeScriptImpl, _super), SafeScriptImpl.prototype.getTypeName = function() {
                return "Script";
            }, SafeScriptImpl;
        }(SafeValueImpl), platform_browser_SafeUrlImpl = function(_super) {
            function SafeUrlImpl() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return __extends(SafeUrlImpl, _super), SafeUrlImpl.prototype.getTypeName = function() {
                return "URL";
            }, SafeUrlImpl;
        }(SafeValueImpl), platform_browser_SafeResourceUrlImpl = function(_super) {
            function SafeResourceUrlImpl() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return __extends(SafeResourceUrlImpl, _super), SafeResourceUrlImpl.prototype.getTypeName = function() {
                return "ResourceURL";
            }, SafeResourceUrlImpl;
        }(SafeValueImpl), BROWSER_SANITIZATION_PROVIDERS = [ {
            provide: Sanitizer,
            useExisting: DomSanitizer
        }, {
            provide: DomSanitizer,
            useClass: platform_browser_DomSanitizerImpl,
            deps: [ DOCUMENT ]
        } ], platformBrowser = createPlatformFactory(platformCore, "browser", [ {
            provide: PLATFORM_ID,
            useValue: PLATFORM_BROWSER_ID
        }, {
            provide: PLATFORM_INITIALIZER,
            useValue: function() {
                platform_browser_BrowserDomAdapter.makeCurrent(), platform_browser_BrowserGetTestability.init();
            },
            multi: !0
        }, {
            provide: PlatformLocation,
            useClass: platform_browser_BrowserPlatformLocation,
            deps: [ DOCUMENT ]
        }, {
            provide: DOCUMENT,
            useFactory: function() {
                return document;
            },
            deps: []
        } ]), BROWSER_MODULE_PROVIDERS = [ BROWSER_SANITIZATION_PROVIDERS, {
            provide: APP_ROOT,
            useValue: !0
        }, {
            provide: ErrorHandler,
            useFactory: function() {
                return new ErrorHandler();
            },
            deps: []
        }, {
            provide: EVENT_MANAGER_PLUGINS,
            useClass: platform_browser_DomEventsPlugin,
            multi: !0,
            deps: [ DOCUMENT, NgZone, PLATFORM_ID ]
        }, {
            provide: EVENT_MANAGER_PLUGINS,
            useClass: platform_browser_KeyEventsPlugin,
            multi: !0,
            deps: [ DOCUMENT ]
        }, {
            provide: EVENT_MANAGER_PLUGINS,
            useClass: platform_browser_HammerGesturesPlugin,
            multi: !0,
            deps: [ DOCUMENT, HAMMER_GESTURE_CONFIG, Console, [ new Optional(), HAMMER_LOADER ] ]
        }, {
            provide: HAMMER_GESTURE_CONFIG,
            useClass: platform_browser_HammerGestureConfig,
            deps: []
        }, {
            provide: platform_browser_DomRendererFactory2,
            useClass: platform_browser_DomRendererFactory2,
            deps: [ platform_browser_EventManager, platform_browser_DomSharedStylesHost ]
        }, {
            provide: RendererFactory2,
            useExisting: platform_browser_DomRendererFactory2
        }, {
            provide: platform_browser_SharedStylesHost,
            useExisting: platform_browser_DomSharedStylesHost
        }, {
            provide: platform_browser_DomSharedStylesHost,
            useClass: platform_browser_DomSharedStylesHost,
            deps: [ DOCUMENT ]
        }, {
            provide: Testability,
            useClass: Testability,
            deps: [ NgZone ]
        }, {
            provide: platform_browser_EventManager,
            useClass: platform_browser_EventManager,
            deps: [ EVENT_MANAGER_PLUGINS, NgZone ]
        }, ELEMENT_PROBE_PROVIDERS ], platform_browser_BrowserModule = function() {
            function BrowserModule(parentModule) {
                if (parentModule) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.");
            }
            var BrowserModule_1;
            return BrowserModule_1 = BrowserModule, BrowserModule.withServerTransition = function(params) {
                return {
                    ngModule: BrowserModule_1,
                    providers: [ {
                        provide: APP_ID,
                        useValue: params.appId
                    }, {
                        provide: TRANSITION_ID,
                        useExisting: APP_ID
                    }, SERVER_TRANSITION_PROVIDERS ]
                };
            }, BrowserModule.ngModuleDef = defineNgModule({
                type: BrowserModule
            }), BrowserModule.ngInjectorDef = defineInjector({
                factory: function(t) {
                    return new (t || BrowserModule)(inject(BrowserModule_1, 12));
                },
                providers: BROWSER_MODULE_PROVIDERS,
                imports: [ common_CommonModule, ApplicationModule ]
            }), BrowserModule;
        }();
        function createMeta() {
            return new platform_browser_Meta(inject(DOCUMENT));
        }
        var platform_browser_Meta = function() {
            function Meta(_doc) {
                this._doc = _doc, this._dom = getDOM();
            }
            return Meta.prototype.addTag = function(tag, forceCreation) {
                return void 0 === forceCreation && (forceCreation = !1), tag ? this._getOrCreateElement(tag, forceCreation) : null;
            }, Meta.prototype.addTags = function(tags, forceCreation) {
                var _this = this;
                return void 0 === forceCreation && (forceCreation = !1), tags ? tags.reduce(function(result, tag) {
                    return tag && result.push(_this._getOrCreateElement(tag, forceCreation)), result;
                }, []) : [];
            }, Meta.prototype.getTag = function(attrSelector) {
                return attrSelector && this._dom.querySelector(this._doc, "meta[" + attrSelector + "]") || null;
            }, Meta.prototype.getTags = function(attrSelector) {
                if (!attrSelector) return [];
                var list = this._dom.querySelectorAll(this._doc, "meta[" + attrSelector + "]");
                return list ? [].slice.call(list) : [];
            }, Meta.prototype.updateTag = function(tag, selector) {
                if (!tag) return null;
                selector = selector || this._parseSelector(tag);
                var meta = this.getTag(selector);
                return meta ? this._setMetaElementAttributes(tag, meta) : this._getOrCreateElement(tag, !0);
            }, Meta.prototype.removeTag = function(attrSelector) {
                this.removeTagElement(this.getTag(attrSelector));
            }, Meta.prototype.removeTagElement = function(meta) {
                meta && this._dom.remove(meta);
            }, Meta.prototype._getOrCreateElement = function(meta, forceCreation) {
                if (void 0 === forceCreation && (forceCreation = !1), !forceCreation) {
                    var selector = this._parseSelector(meta), elem = this.getTag(selector);
                    if (elem && this._containsAttributes(meta, elem)) return elem;
                }
                var element = this._dom.createElement("meta");
                this._setMetaElementAttributes(meta, element);
                var head = this._dom.getElementsByTagName(this._doc, "head")[0];
                return this._dom.appendChild(head, element), element;
            }, Meta.prototype._setMetaElementAttributes = function(tag, el) {
                var _this = this;
                return Object.keys(tag).forEach(function(prop) {
                    return _this._dom.setAttribute(el, prop, tag[prop]);
                }), el;
            }, Meta.prototype._parseSelector = function(tag) {
                var attr = tag.name ? "name" : "property";
                return attr + '="' + tag[attr] + '"';
            }, Meta.prototype._containsAttributes = function(tag, elem) {
                var _this = this;
                return Object.keys(tag).every(function(key) {
                    return _this._dom.getAttribute(elem, key) === tag[key];
                });
            }, Meta.ngInjectableDef = defineInjectable({
                factory: createMeta,
                token: Meta,
                providedIn: "root"
            }), Meta.ngInjectableDef = defineInjectable({
                token: Meta,
                factory: function(t) {
                    return t ? new t(inject(DOCUMENT)) : createMeta();
                },
                providedIn: "root"
            }), Meta;
        }();
        function createTitle() {
            return new platform_browser_Title(inject(DOCUMENT));
        }
        var platform_browser_Title = function() {
            function Title(_doc) {
                this._doc = _doc;
            }
            return Title.prototype.getTitle = function() {
                return getDOM().getTitle(this._doc);
            }, Title.prototype.setTitle = function(newTitle) {
                getDOM().setTitle(this._doc, newTitle);
            }, Title.ngInjectableDef = defineInjectable({
                factory: createTitle,
                token: Title,
                providedIn: "root"
            }), Title.ngInjectableDef = defineInjectable({
                token: Title,
                factory: function(t) {
                    return t ? new t(inject(DOCUMENT)) : createTitle();
                },
                providedIn: "root"
            }), Title;
        }();
        "undefined" != typeof window && window;
        var empty_EMPTY = new Observable_Observable(function(subscriber) {
            return subscriber.complete();
        });
        function empty_empty(scheduler) {
            return scheduler ? function(scheduler) {
                return new Observable_Observable(function(subscriber) {
                    return scheduler.schedule(function() {
                        return subscriber.complete();
                    });
                });
            }(scheduler) : empty_EMPTY;
        }
        function scalar(value) {
            var result = new Observable_Observable(function(subscriber) {
                subscriber.next(value), subscriber.complete();
            });
            return result._isScalar = !0, result.value = value, result;
        }
        function of() {
            for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
            var scheduler = args[args.length - 1];
            switch (isScheduler(scheduler) ? args.pop() : scheduler = void 0, args.length) {
              case 0:
                return empty_empty(scheduler);

              case 1:
                return scheduler ? fromArray(args, scheduler) : scalar(args[0]);

              default:
                return fromArray(args, scheduler);
            }
        }
        function concatMap(project, resultSelector) {
            return mergeMap(project, resultSelector, 1);
        }
        function filter(predicate, thisArg) {
            return function(source) {
                return source.lift(new FilterOperator(predicate, thisArg));
            };
        }
        var FilterOperator = function() {
            function FilterOperator(predicate, thisArg) {
                this.predicate = predicate, this.thisArg = thisArg;
            }
            return FilterOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new filter_FilterSubscriber(subscriber, this.predicate, this.thisArg));
            }, FilterOperator;
        }(), filter_FilterSubscriber = function(_super) {
            function FilterSubscriber(destination, predicate, thisArg) {
                var _this = _super.call(this, destination) || this;
                return _this.predicate = predicate, _this.thisArg = thisArg, _this.count = 0, _this;
            }
            return __extends(FilterSubscriber, _super), FilterSubscriber.prototype._next = function(value) {
                var result;
                try {
                    result = this.predicate.call(this.thisArg, value, this.count++);
                } catch (err) {
                    return void this.destination.error(err);
                }
                result && this.destination.next(value);
            }, FilterSubscriber;
        }(Subscriber_Subscriber), HttpHandler = function() {
            return function() {};
        }(), HttpBackend = function() {
            return function() {};
        }(), http_HttpHeaders = function() {
            function HttpHeaders(headers) {
                var _this = this;
                this.normalizedNames = new Map(), this.lazyUpdate = null, headers ? this.lazyInit = "string" == typeof headers ? function() {
                    _this.headers = new Map(), headers.split("\n").forEach(function(line) {
                        var index = line.indexOf(":");
                        if (index > 0) {
                            var name_1 = line.slice(0, index), key = name_1.toLowerCase(), value = line.slice(index + 1).trim();
                            _this.maybeSetNormalizedName(name_1, key), _this.headers.has(key) ? _this.headers.get(key).push(value) : _this.headers.set(key, [ value ]);
                        }
                    });
                } : function() {
                    _this.headers = new Map(), Object.keys(headers).forEach(function(name) {
                        var values = headers[name], key = name.toLowerCase();
                        "string" == typeof values && (values = [ values ]), values.length > 0 && (_this.headers.set(key, values), 
                        _this.maybeSetNormalizedName(name, key));
                    });
                } : this.headers = new Map();
            }
            return HttpHeaders.prototype.has = function(name) {
                return this.init(), this.headers.has(name.toLowerCase());
            }, HttpHeaders.prototype.get = function(name) {
                this.init();
                var values = this.headers.get(name.toLowerCase());
                return values && values.length > 0 ? values[0] : null;
            }, HttpHeaders.prototype.keys = function() {
                return this.init(), Array.from(this.normalizedNames.values());
            }, HttpHeaders.prototype.getAll = function(name) {
                return this.init(), this.headers.get(name.toLowerCase()) || null;
            }, HttpHeaders.prototype.append = function(name, value) {
                return this.clone({
                    name: name,
                    value: value,
                    op: "a"
                });
            }, HttpHeaders.prototype.set = function(name, value) {
                return this.clone({
                    name: name,
                    value: value,
                    op: "s"
                });
            }, HttpHeaders.prototype.delete = function(name, value) {
                return this.clone({
                    name: name,
                    value: value,
                    op: "d"
                });
            }, HttpHeaders.prototype.maybeSetNormalizedName = function(name, lcName) {
                this.normalizedNames.has(lcName) || this.normalizedNames.set(lcName, name);
            }, HttpHeaders.prototype.init = function() {
                var _this = this;
                this.lazyInit && (this.lazyInit instanceof HttpHeaders ? this.copyFrom(this.lazyInit) : this.lazyInit(), 
                this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(function(update) {
                    return _this.applyUpdate(update);
                }), this.lazyUpdate = null));
            }, HttpHeaders.prototype.copyFrom = function(other) {
                var _this = this;
                other.init(), Array.from(other.headers.keys()).forEach(function(key) {
                    _this.headers.set(key, other.headers.get(key)), _this.normalizedNames.set(key, other.normalizedNames.get(key));
                });
            }, HttpHeaders.prototype.clone = function(update) {
                var clone = new HttpHeaders();
                return clone.lazyInit = this.lazyInit && this.lazyInit instanceof HttpHeaders ? this.lazyInit : this, 
                clone.lazyUpdate = (this.lazyUpdate || []).concat([ update ]), clone;
            }, HttpHeaders.prototype.applyUpdate = function(update) {
                var key = update.name.toLowerCase();
                switch (update.op) {
                  case "a":
                  case "s":
                    var value = update.value;
                    if ("string" == typeof value && (value = [ value ]), 0 === value.length) return;
                    this.maybeSetNormalizedName(update.name, key);
                    var base = ("a" === update.op ? this.headers.get(key) : void 0) || [];
                    base.push.apply(base, __spread(value)), this.headers.set(key, base);
                    break;

                  case "d":
                    var toDelete_1 = update.value;
                    if (toDelete_1) {
                        var existing = this.headers.get(key);
                        if (!existing) return;
                        0 === (existing = existing.filter(function(value) {
                            return -1 === toDelete_1.indexOf(value);
                        })).length ? (this.headers.delete(key), this.normalizedNames.delete(key)) : this.headers.set(key, existing);
                    } else this.headers.delete(key), this.normalizedNames.delete(key);
                }
            }, HttpHeaders.prototype.forEach = function(fn) {
                var _this = this;
                this.init(), Array.from(this.normalizedNames.keys()).forEach(function(key) {
                    return fn(_this.normalizedNames.get(key), _this.headers.get(key));
                });
            }, HttpHeaders;
        }(), HttpUrlEncodingCodec = function() {
            function HttpUrlEncodingCodec() {}
            return HttpUrlEncodingCodec.prototype.encodeKey = function(key) {
                return standardEncoding(key);
            }, HttpUrlEncodingCodec.prototype.encodeValue = function(value) {
                return standardEncoding(value);
            }, HttpUrlEncodingCodec.prototype.decodeKey = function(key) {
                return decodeURIComponent(key);
            }, HttpUrlEncodingCodec.prototype.decodeValue = function(value) {
                return decodeURIComponent(value);
            }, HttpUrlEncodingCodec;
        }();
        function standardEncoding(v) {
            return encodeURIComponent(v).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/gi, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%2B/gi, "+").replace(/%3D/gi, "=").replace(/%3F/gi, "?").replace(/%2F/gi, "/");
        }
        var HttpParams = function() {
            function HttpParams(options) {
                void 0 === options && (options = {});
                var rawParams, codec, map, _this = this;
                if (this.updates = null, this.cloneFrom = null, this.encoder = options.encoder || new HttpUrlEncodingCodec(), 
                options.fromString) {
                    if (options.fromObject) throw new Error("Cannot specify both fromString and fromObject.");
                    this.map = (rawParams = options.fromString, codec = this.encoder, map = new Map(), 
                    rawParams.length > 0 && rawParams.split("&").forEach(function(param) {
                        var eqIdx = param.indexOf("="), _a = __read(-1 == eqIdx ? [ codec.decodeKey(param), "" ] : [ codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1)) ], 2), key = _a[0], val = _a[1], list = map.get(key) || [];
                        list.push(val), map.set(key, list);
                    }), map);
                } else options.fromObject ? (this.map = new Map(), Object.keys(options.fromObject).forEach(function(key) {
                    var value = options.fromObject[key];
                    _this.map.set(key, Array.isArray(value) ? value : [ value ]);
                })) : this.map = null;
            }
            return HttpParams.prototype.has = function(param) {
                return this.init(), this.map.has(param);
            }, HttpParams.prototype.get = function(param) {
                this.init();
                var res = this.map.get(param);
                return res ? res[0] : null;
            }, HttpParams.prototype.getAll = function(param) {
                return this.init(), this.map.get(param) || null;
            }, HttpParams.prototype.keys = function() {
                return this.init(), Array.from(this.map.keys());
            }, HttpParams.prototype.append = function(param, value) {
                return this.clone({
                    param: param,
                    value: value,
                    op: "a"
                });
            }, HttpParams.prototype.set = function(param, value) {
                return this.clone({
                    param: param,
                    value: value,
                    op: "s"
                });
            }, HttpParams.prototype.delete = function(param, value) {
                return this.clone({
                    param: param,
                    value: value,
                    op: "d"
                });
            }, HttpParams.prototype.toString = function() {
                var _this = this;
                return this.init(), this.keys().map(function(key) {
                    var eKey = _this.encoder.encodeKey(key);
                    return _this.map.get(key).map(function(value) {
                        return eKey + "=" + _this.encoder.encodeValue(value);
                    }).join("&");
                }).join("&");
            }, HttpParams.prototype.clone = function(update) {
                var clone = new HttpParams({
                    encoder: this.encoder
                });
                return clone.cloneFrom = this.cloneFrom || this, clone.updates = (this.updates || []).concat([ update ]), 
                clone;
            }, HttpParams.prototype.init = function() {
                var _this = this;
                null === this.map && (this.map = new Map()), null !== this.cloneFrom && (this.cloneFrom.init(), 
                this.cloneFrom.keys().forEach(function(key) {
                    return _this.map.set(key, _this.cloneFrom.map.get(key));
                }), this.updates.forEach(function(update) {
                    switch (update.op) {
                      case "a":
                      case "s":
                        var base = ("a" === update.op ? _this.map.get(update.param) : void 0) || [];
                        base.push(update.value), _this.map.set(update.param, base);
                        break;

                      case "d":
                        if (void 0 === update.value) {
                            _this.map.delete(update.param);
                            break;
                        }
                        var base_1 = _this.map.get(update.param) || [], idx = base_1.indexOf(update.value);
                        -1 !== idx && base_1.splice(idx, 1), base_1.length > 0 ? _this.map.set(update.param, base_1) : _this.map.delete(update.param);
                    }
                }), this.cloneFrom = null);
            }, HttpParams;
        }();
        function isArrayBuffer(value) {
            return "undefined" != typeof ArrayBuffer && value instanceof ArrayBuffer;
        }
        function isBlob(value) {
            return "undefined" != typeof Blob && value instanceof Blob;
        }
        function isFormData(value) {
            return "undefined" != typeof FormData && value instanceof FormData;
        }
        var HttpRequest = function() {
            function HttpRequest(method, url, third, fourth) {
                var options;
                if (this.url = url, this.body = null, this.reportProgress = !1, this.withCredentials = !1, 
                this.responseType = "json", this.method = method.toUpperCase(), function(method) {
                    switch (method) {
                      case "DELETE":
                      case "GET":
                      case "HEAD":
                      case "OPTIONS":
                      case "JSONP":
                        return !1;

                      default:
                        return !0;
                    }
                }(this.method) || fourth ? (this.body = void 0 !== third ? third : null, options = fourth) : options = third, 
                options && (this.reportProgress = !!options.reportProgress, this.withCredentials = !!options.withCredentials, 
                options.responseType && (this.responseType = options.responseType), options.headers && (this.headers = options.headers), 
                options.params && (this.params = options.params)), this.headers || (this.headers = new http_HttpHeaders()), 
                this.params) {
                    var params = this.params.toString();
                    if (0 === params.length) this.urlWithParams = url; else {
                        var qIdx = url.indexOf("?");
                        this.urlWithParams = url + (-1 === qIdx ? "?" : qIdx < url.length - 1 ? "&" : "") + params;
                    }
                } else this.params = new HttpParams(), this.urlWithParams = url;
            }
            return HttpRequest.prototype.serializeBody = function() {
                return null === this.body ? null : isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) || "string" == typeof this.body ? this.body : this.body instanceof HttpParams ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString();
            }, HttpRequest.prototype.detectContentTypeHeader = function() {
                return null === this.body ? null : isFormData(this.body) ? null : isBlob(this.body) ? this.body.type || null : isArrayBuffer(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof HttpParams ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || Array.isArray(this.body) ? "application/json" : null;
            }, HttpRequest.prototype.clone = function(update) {
                void 0 === update && (update = {});
                var method = update.method || this.method, url = update.url || this.url, responseType = update.responseType || this.responseType, body = void 0 !== update.body ? update.body : this.body, withCredentials = void 0 !== update.withCredentials ? update.withCredentials : this.withCredentials, reportProgress = void 0 !== update.reportProgress ? update.reportProgress : this.reportProgress, headers = update.headers || this.headers, params = update.params || this.params;
                return void 0 !== update.setHeaders && (headers = Object.keys(update.setHeaders).reduce(function(headers, name) {
                    return headers.set(name, update.setHeaders[name]);
                }, headers)), update.setParams && (params = Object.keys(update.setParams).reduce(function(params, param) {
                    return params.set(param, update.setParams[param]);
                }, params)), new HttpRequest(method, url, body, {
                    params: params,
                    headers: headers,
                    reportProgress: reportProgress,
                    responseType: responseType,
                    withCredentials: withCredentials
                });
            }, HttpRequest;
        }(), HttpEventType = function(HttpEventType) {
            return HttpEventType[HttpEventType.Sent = 0] = "Sent", HttpEventType[HttpEventType.UploadProgress = 1] = "UploadProgress", 
            HttpEventType[HttpEventType.ResponseHeader = 2] = "ResponseHeader", HttpEventType[HttpEventType.DownloadProgress = 3] = "DownloadProgress", 
            HttpEventType[HttpEventType.Response = 4] = "Response", HttpEventType[HttpEventType.User = 5] = "User", 
            HttpEventType;
        }({}), HttpResponseBase = function() {
            return function(init, defaultStatus, defaultStatusText) {
                void 0 === defaultStatus && (defaultStatus = 200), void 0 === defaultStatusText && (defaultStatusText = "OK"), 
                this.headers = init.headers || new http_HttpHeaders(), this.status = void 0 !== init.status ? init.status : defaultStatus, 
                this.statusText = init.statusText || defaultStatusText, this.url = init.url || null, 
                this.ok = this.status >= 200 && this.status < 300;
            };
        }(), http_HttpHeaderResponse = function(_super) {
            function HttpHeaderResponse(init) {
                void 0 === init && (init = {});
                var _this = _super.call(this, init) || this;
                return _this.type = HttpEventType.ResponseHeader, _this;
            }
            return __extends(HttpHeaderResponse, _super), HttpHeaderResponse.prototype.clone = function(update) {
                return void 0 === update && (update = {}), new HttpHeaderResponse({
                    headers: update.headers || this.headers,
                    status: void 0 !== update.status ? update.status : this.status,
                    statusText: update.statusText || this.statusText,
                    url: update.url || this.url || void 0
                });
            }, HttpHeaderResponse;
        }(HttpResponseBase), http_HttpResponse = function(_super) {
            function HttpResponse(init) {
                void 0 === init && (init = {});
                var _this = _super.call(this, init) || this;
                return _this.type = HttpEventType.Response, _this.body = void 0 !== init.body ? init.body : null, 
                _this;
            }
            return __extends(HttpResponse, _super), HttpResponse.prototype.clone = function(update) {
                return void 0 === update && (update = {}), new HttpResponse({
                    body: void 0 !== update.body ? update.body : this.body,
                    headers: update.headers || this.headers,
                    status: void 0 !== update.status ? update.status : this.status,
                    statusText: update.statusText || this.statusText,
                    url: update.url || this.url || void 0
                });
            }, HttpResponse;
        }(HttpResponseBase), http_HttpErrorResponse = function(_super) {
            function HttpErrorResponse(init) {
                var _this = _super.call(this, init, 0, "Unknown Error") || this;
                return _this.name = "HttpErrorResponse", _this.ok = !1, _this.message = _this.status >= 200 && _this.status < 300 ? "Http failure during parsing for " + (init.url || "(unknown url)") : "Http failure response for " + (init.url || "(unknown url)") + ": " + init.status + " " + init.statusText, 
                _this.error = init.error || null, _this;
            }
            return __extends(HttpErrorResponse, _super), HttpErrorResponse;
        }(HttpResponseBase);
        function addBody(options, body) {
            return {
                body: body,
                headers: options.headers,
                observe: options.observe,
                params: options.params,
                reportProgress: options.reportProgress,
                responseType: options.responseType,
                withCredentials: options.withCredentials
            };
        }
        var http_HttpClient = function() {
            function HttpClient(handler) {
                this.handler = handler;
            }
            return HttpClient.prototype.request = function(first, url, options) {
                var req, _this = this;
                if (void 0 === options && (options = {}), first instanceof HttpRequest) req = first; else {
                    var headers;
                    headers = options.headers instanceof http_HttpHeaders ? options.headers : new http_HttpHeaders(options.headers);
                    var params = void 0;
                    options.params && (params = options.params instanceof HttpParams ? options.params : new HttpParams({
                        fromObject: options.params
                    })), req = new HttpRequest(first, url, void 0 !== options.body ? options.body : null, {
                        headers: headers,
                        params: params,
                        reportProgress: options.reportProgress,
                        responseType: options.responseType || "json",
                        withCredentials: options.withCredentials
                    });
                }
                var events$ = of(req).pipe(concatMap(function(req) {
                    return _this.handler.handle(req);
                }));
                if (first instanceof HttpRequest || "events" === options.observe) return events$;
                var res$ = events$.pipe(filter(function(event) {
                    return event instanceof http_HttpResponse;
                }));
                switch (options.observe || "body") {
                  case "body":
                    switch (req.responseType) {
                      case "arraybuffer":
                        return res$.pipe(map_map(function(res) {
                            if (null !== res.body && !(res.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer.");
                            return res.body;
                        }));

                      case "blob":
                        return res$.pipe(map_map(function(res) {
                            if (null !== res.body && !(res.body instanceof Blob)) throw new Error("Response is not a Blob.");
                            return res.body;
                        }));

                      case "text":
                        return res$.pipe(map_map(function(res) {
                            if (null !== res.body && "string" != typeof res.body) throw new Error("Response is not a string.");
                            return res.body;
                        }));

                      case "json":
                      default:
                        return res$.pipe(map_map(function(res) {
                            return res.body;
                        }));
                    }

                  case "response":
                    return res$;

                  default:
                    throw new Error("Unreachable: unhandled observe type " + options.observe + "}");
                }
            }, HttpClient.prototype.delete = function(url, options) {
                return void 0 === options && (options = {}), this.request("DELETE", url, options);
            }, HttpClient.prototype.get = function(url, options) {
                return void 0 === options && (options = {}), this.request("GET", url, options);
            }, HttpClient.prototype.head = function(url, options) {
                return void 0 === options && (options = {}), this.request("HEAD", url, options);
            }, HttpClient.prototype.jsonp = function(url, callbackParam) {
                return this.request("JSONP", url, {
                    params: new HttpParams().append(callbackParam, "JSONP_CALLBACK"),
                    observe: "body",
                    responseType: "json"
                });
            }, HttpClient.prototype.options = function(url, options) {
                return void 0 === options && (options = {}), this.request("OPTIONS", url, options);
            }, HttpClient.prototype.patch = function(url, body, options) {
                return void 0 === options && (options = {}), this.request("PATCH", url, addBody(options, body));
            }, HttpClient.prototype.post = function(url, body, options) {
                return void 0 === options && (options = {}), this.request("POST", url, addBody(options, body));
            }, HttpClient.prototype.put = function(url, body, options) {
                return void 0 === options && (options = {}), this.request("PUT", url, addBody(options, body));
            }, HttpClient.ngInjectableDef = defineInjectable({
                token: HttpClient,
                factory: function(t) {
                    return new (t || HttpClient)(inject(HttpHandler));
                },
                providedIn: null
            }), HttpClient;
        }(), HttpInterceptorHandler = function() {
            function HttpInterceptorHandler(next, interceptor) {
                this.next = next, this.interceptor = interceptor;
            }
            return HttpInterceptorHandler.prototype.handle = function(req) {
                return this.interceptor.intercept(req, this.next);
            }, HttpInterceptorHandler;
        }(), HTTP_INTERCEPTORS = new InjectionToken("HTTP_INTERCEPTORS"), http_NoopInterceptor = function() {
            function NoopInterceptor() {}
            return NoopInterceptor.prototype.intercept = function(req, next) {
                return next.handle(req);
            }, NoopInterceptor.ngInjectableDef = defineInjectable({
                token: NoopInterceptor,
                factory: function(t) {
                    return new (t || NoopInterceptor)();
                },
                providedIn: null
            }), NoopInterceptor;
        }(), XSSI_PREFIX = /^\)\]\}',?\n/, XhrFactory = function() {
            return function() {};
        }(), http_BrowserXhr = function() {
            function BrowserXhr() {}
            return BrowserXhr.prototype.build = function() {
                return new XMLHttpRequest();
            }, BrowserXhr.ngInjectableDef = defineInjectable({
                token: BrowserXhr,
                factory: function(t) {
                    return new (t || BrowserXhr)();
                },
                providedIn: null
            }), BrowserXhr;
        }(), http_HttpXhrBackend = function() {
            function HttpXhrBackend(xhrFactory) {
                this.xhrFactory = xhrFactory;
            }
            return HttpXhrBackend.prototype.handle = function(req) {
                var _this = this;
                if ("JSONP" === req.method) throw new Error("Attempted to construct Jsonp request without JsonpClientModule installed.");
                return new Observable_Observable(function(observer) {
                    var xhr = _this.xhrFactory.build();
                    if (xhr.open(req.method, req.urlWithParams), req.withCredentials && (xhr.withCredentials = !0), 
                    req.headers.forEach(function(name, values) {
                        return xhr.setRequestHeader(name, values.join(","));
                    }), req.headers.has("Accept") || xhr.setRequestHeader("Accept", "application/json, text/plain, */*"), 
                    !req.headers.has("Content-Type")) {
                        var detectedType = req.detectContentTypeHeader();
                        null !== detectedType && xhr.setRequestHeader("Content-Type", detectedType);
                    }
                    if (req.responseType) {
                        var responseType = req.responseType.toLowerCase();
                        xhr.responseType = "json" !== responseType ? responseType : "text";
                    }
                    var reqBody = req.serializeBody(), headerResponse = null, partialFromXhr = function() {
                        if (null !== headerResponse) return headerResponse;
                        var status = 1223 === xhr.status ? 204 : xhr.status, statusText = xhr.statusText || "OK", headers = new http_HttpHeaders(xhr.getAllResponseHeaders()), url = function(xhr) {
                            return "responseURL" in xhr && xhr.responseURL ? xhr.responseURL : /^X-Request-URL:/m.test(xhr.getAllResponseHeaders()) ? xhr.getResponseHeader("X-Request-URL") : null;
                        }(xhr) || req.url;
                        return headerResponse = new http_HttpHeaderResponse({
                            headers: headers,
                            status: status,
                            statusText: statusText,
                            url: url
                        });
                    }, onLoad = function() {
                        var _a = partialFromXhr(), headers = _a.headers, status = _a.status, statusText = _a.statusText, url = _a.url, body = null;
                        204 !== status && (body = void 0 === xhr.response ? xhr.responseText : xhr.response), 
                        0 === status && (status = body ? 200 : 0);
                        var ok = status >= 200 && status < 300;
                        if ("json" === req.responseType && "string" == typeof body) {
                            var originalBody = body;
                            body = body.replace(XSSI_PREFIX, "");
                            try {
                                body = "" !== body ? JSON.parse(body) : null;
                            } catch (error) {
                                body = originalBody, ok && (ok = !1, body = {
                                    error: error,
                                    text: body
                                });
                            }
                        }
                        ok ? (observer.next(new http_HttpResponse({
                            body: body,
                            headers: headers,
                            status: status,
                            statusText: statusText,
                            url: url || void 0
                        })), observer.complete()) : observer.error(new http_HttpErrorResponse({
                            error: body,
                            headers: headers,
                            status: status,
                            statusText: statusText,
                            url: url || void 0
                        }));
                    }, onError = function(error) {
                        var url = partialFromXhr().url, res = new http_HttpErrorResponse({
                            error: error,
                            status: xhr.status || 0,
                            statusText: xhr.statusText || "Unknown Error",
                            url: url || void 0
                        });
                        observer.error(res);
                    }, sentHeaders = !1, onDownProgress = function(event) {
                        sentHeaders || (observer.next(partialFromXhr()), sentHeaders = !0);
                        var progressEvent = {
                            type: HttpEventType.DownloadProgress,
                            loaded: event.loaded
                        };
                        event.lengthComputable && (progressEvent.total = event.total), "text" === req.responseType && xhr.responseText && (progressEvent.partialText = xhr.responseText), 
                        observer.next(progressEvent);
                    }, onUpProgress = function(event) {
                        var progress = {
                            type: HttpEventType.UploadProgress,
                            loaded: event.loaded
                        };
                        event.lengthComputable && (progress.total = event.total), observer.next(progress);
                    };
                    return xhr.addEventListener("load", onLoad), xhr.addEventListener("error", onError), 
                    req.reportProgress && (xhr.addEventListener("progress", onDownProgress), null !== reqBody && xhr.upload && xhr.upload.addEventListener("progress", onUpProgress)), 
                    xhr.send(reqBody), observer.next({
                        type: HttpEventType.Sent
                    }), function() {
                        xhr.removeEventListener("error", onError), xhr.removeEventListener("load", onLoad), 
                        req.reportProgress && (xhr.removeEventListener("progress", onDownProgress), null !== reqBody && xhr.upload && xhr.upload.removeEventListener("progress", onUpProgress)), 
                        xhr.abort();
                    };
                });
            }, HttpXhrBackend.ngInjectableDef = defineInjectable({
                token: HttpXhrBackend,
                factory: function(t) {
                    return new (t || HttpXhrBackend)(inject(XhrFactory));
                },
                providedIn: null
            }), HttpXhrBackend;
        }(), XSRF_COOKIE_NAME = new InjectionToken("XSRF_COOKIE_NAME"), XSRF_HEADER_NAME = new InjectionToken("XSRF_HEADER_NAME"), HttpXsrfTokenExtractor = function() {
            return function() {};
        }(), http_HttpXsrfCookieExtractor = function() {
            function HttpXsrfCookieExtractor(doc, platform, cookieName) {
                this.doc = doc, this.platform = platform, this.cookieName = cookieName, this.lastCookieString = "", 
                this.lastToken = null, this.parseCount = 0;
            }
            return HttpXsrfCookieExtractor.prototype.getToken = function() {
                if ("server" === this.platform) return null;
                var cookieString = this.doc.cookie || "";
                return cookieString !== this.lastCookieString && (this.parseCount++, this.lastToken = parseCookieValue(cookieString, this.cookieName), 
                this.lastCookieString = cookieString), this.lastToken;
            }, HttpXsrfCookieExtractor.ngInjectableDef = defineInjectable({
                token: HttpXsrfCookieExtractor,
                factory: function(t) {
                    return new (t || HttpXsrfCookieExtractor)(inject(DOCUMENT), inject(PLATFORM_ID), inject(XSRF_COOKIE_NAME));
                },
                providedIn: null
            }), HttpXsrfCookieExtractor;
        }(), http_HttpXsrfInterceptor = function() {
            function HttpXsrfInterceptor(tokenService, headerName) {
                this.tokenService = tokenService, this.headerName = headerName;
            }
            return HttpXsrfInterceptor.prototype.intercept = function(req, next) {
                var lcUrl = req.url.toLowerCase();
                if ("GET" === req.method || "HEAD" === req.method || lcUrl.startsWith("http://") || lcUrl.startsWith("https://")) return next.handle(req);
                var token = this.tokenService.getToken();
                return null === token || req.headers.has(this.headerName) || (req = req.clone({
                    headers: req.headers.set(this.headerName, token)
                })), next.handle(req);
            }, HttpXsrfInterceptor.ngInjectableDef = defineInjectable({
                token: HttpXsrfInterceptor,
                factory: function(t) {
                    return new (t || HttpXsrfInterceptor)(inject(HttpXsrfTokenExtractor), inject(XSRF_HEADER_NAME));
                },
                providedIn: null
            }), HttpXsrfInterceptor;
        }(), http_HttpInterceptingHandler = function() {
            function HttpInterceptingHandler(backend, injector) {
                this.backend = backend, this.injector = injector, this.chain = null;
            }
            return HttpInterceptingHandler.prototype.handle = function(req) {
                if (null === this.chain) {
                    var interceptors = this.injector.get(HTTP_INTERCEPTORS, []);
                    this.chain = interceptors.reduceRight(function(next, interceptor) {
                        return new HttpInterceptorHandler(next, interceptor);
                    }, this.backend);
                }
                return this.chain.handle(req);
            }, HttpInterceptingHandler.ngInjectableDef = defineInjectable({
                token: HttpInterceptingHandler,
                factory: function(t) {
                    return new (t || HttpInterceptingHandler)(inject(HttpBackend), inject(Injector));
                },
                providedIn: null
            }), HttpInterceptingHandler;
        }(), http_HttpClientXsrfModule = function() {
            function HttpClientXsrfModule() {}
            var HttpClientXsrfModule_1;
            return HttpClientXsrfModule_1 = HttpClientXsrfModule, HttpClientXsrfModule.disable = function() {
                return {
                    ngModule: HttpClientXsrfModule_1,
                    providers: [ {
                        provide: http_HttpXsrfInterceptor,
                        useClass: http_NoopInterceptor
                    } ]
                };
            }, HttpClientXsrfModule.withOptions = function(options) {
                return void 0 === options && (options = {}), {
                    ngModule: HttpClientXsrfModule_1,
                    providers: [ options.cookieName ? {
                        provide: XSRF_COOKIE_NAME,
                        useValue: options.cookieName
                    } : [], options.headerName ? {
                        provide: XSRF_HEADER_NAME,
                        useValue: options.headerName
                    } : [] ]
                };
            }, HttpClientXsrfModule.ngModuleDef = defineNgModule({
                type: HttpClientXsrfModule
            }), HttpClientXsrfModule.ngInjectorDef = defineInjector({
                factory: function(t) {
                    return new (t || HttpClientXsrfModule)();
                },
                providers: [ http_HttpXsrfInterceptor, {
                    provide: HTTP_INTERCEPTORS,
                    useExisting: http_HttpXsrfInterceptor,
                    multi: !0
                }, {
                    provide: HttpXsrfTokenExtractor,
                    useClass: http_HttpXsrfCookieExtractor
                }, {
                    provide: XSRF_COOKIE_NAME,
                    useValue: "XSRF-TOKEN"
                }, {
                    provide: XSRF_HEADER_NAME,
                    useValue: "X-XSRF-TOKEN"
                } ]
            }), HttpClientXsrfModule;
        }(), http_HttpClientModule = function() {
            function HttpClientModule() {}
            return HttpClientModule.ngModuleDef = defineNgModule({
                type: HttpClientModule
            }), http_HttpClientXsrfModule.withOptions({
                cookieName: "XSRF-TOKEN",
                headerName: "X-XSRF-TOKEN"
            }), HttpClientModule.ngInjectorDef = defineInjector({
                factory: function(t) {
                    return new (t || HttpClientModule)();
                },
                providers: [ http_HttpClient, {
                    provide: HttpHandler,
                    useClass: http_HttpInterceptingHandler
                }, http_HttpXhrBackend, {
                    provide: HttpBackend,
                    useExisting: http_HttpXhrBackend
                }, http_BrowserXhr, {
                    provide: XhrFactory,
                    useExisting: http_BrowserXhr
                } ],
                imports: [ [ http_HttpClientXsrfModule.withOptions({
                    cookieName: "XSRF-TOKEN",
                    headerName: "X-XSRF-TOKEN"
                }) ] ]
            }), HttpClientModule;
        }(), AnimationBuilder = function() {
            return function() {};
        }(), AnimationFactory = function() {
            return function() {};
        }(), AUTO_STYLE = "*";
        function trigger(name, definitions) {
            return {
                type: 7,
                name: name,
                definitions: definitions,
                options: {}
            };
        }
        function animate(timings, styles) {
            return void 0 === styles && (styles = null), {
                type: 4,
                styles: styles,
                timings: timings
            };
        }
        function sequence(steps, options) {
            return void 0 === options && (options = null), {
                type: 2,
                steps: steps,
                options: options
            };
        }
        function animations_style(tokens) {
            return {
                type: 6,
                styles: tokens,
                offset: null
            };
        }
        function state(name, styles, options) {
            return {
                type: 0,
                name: name,
                styles: styles,
                options: options
            };
        }
        function transition(stateChangeExpr, steps, options) {
            return void 0 === options && (options = null), {
                type: 1,
                expr: stateChangeExpr,
                animation: steps,
                options: options
            };
        }
        function animations_scheduleMicroTask(cb) {
            Promise.resolve(null).then(cb);
        }
        var NoopAnimationPlayer = function() {
            function NoopAnimationPlayer(duration, delay) {
                void 0 === duration && (duration = 0), void 0 === delay && (delay = 0), this._onDoneFns = [], 
                this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this._destroyed = !1, 
                this._finished = !1, this.parentPlayer = null, this.totalTime = duration + delay;
            }
            return NoopAnimationPlayer.prototype._onFinish = function() {
                this._finished || (this._finished = !0, this._onDoneFns.forEach(function(fn) {
                    return fn();
                }), this._onDoneFns = []);
            }, NoopAnimationPlayer.prototype.onStart = function(fn) {
                this._onStartFns.push(fn);
            }, NoopAnimationPlayer.prototype.onDone = function(fn) {
                this._onDoneFns.push(fn);
            }, NoopAnimationPlayer.prototype.onDestroy = function(fn) {
                this._onDestroyFns.push(fn);
            }, NoopAnimationPlayer.prototype.hasStarted = function() {
                return this._started;
            }, NoopAnimationPlayer.prototype.init = function() {}, NoopAnimationPlayer.prototype.play = function() {
                this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0;
            }, NoopAnimationPlayer.prototype.triggerMicrotask = function() {
                var _this = this;
                animations_scheduleMicroTask(function() {
                    return _this._onFinish();
                });
            }, NoopAnimationPlayer.prototype._onStart = function() {
                this._onStartFns.forEach(function(fn) {
                    return fn();
                }), this._onStartFns = [];
            }, NoopAnimationPlayer.prototype.pause = function() {}, NoopAnimationPlayer.prototype.restart = function() {}, 
            NoopAnimationPlayer.prototype.finish = function() {
                this._onFinish();
            }, NoopAnimationPlayer.prototype.destroy = function() {
                this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), 
                this.finish(), this._onDestroyFns.forEach(function(fn) {
                    return fn();
                }), this._onDestroyFns = []);
            }, NoopAnimationPlayer.prototype.reset = function() {}, NoopAnimationPlayer.prototype.setPosition = function(position) {}, 
            NoopAnimationPlayer.prototype.getPosition = function() {
                return 0;
            }, NoopAnimationPlayer.prototype.triggerCallback = function(phaseName) {
                var methods = "start" == phaseName ? this._onStartFns : this._onDoneFns;
                methods.forEach(function(fn) {
                    return fn();
                }), methods.length = 0;
            }, NoopAnimationPlayer;
        }(), AnimationGroupPlayer = function() {
            function AnimationGroupPlayer(_players) {
                var _this = this;
                this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, 
                this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, 
                this.players = _players;
                var doneCount = 0, destroyCount = 0, startCount = 0, total = this.players.length;
                0 == total ? animations_scheduleMicroTask(function() {
                    return _this._onFinish();
                }) : this.players.forEach(function(player) {
                    player.onDone(function() {
                        ++doneCount == total && _this._onFinish();
                    }), player.onDestroy(function() {
                        ++destroyCount == total && _this._onDestroy();
                    }), player.onStart(function() {
                        ++startCount == total && _this._onStart();
                    });
                }), this.totalTime = this.players.reduce(function(time, player) {
                    return Math.max(time, player.totalTime);
                }, 0);
            }
            return AnimationGroupPlayer.prototype._onFinish = function() {
                this._finished || (this._finished = !0, this._onDoneFns.forEach(function(fn) {
                    return fn();
                }), this._onDoneFns = []);
            }, AnimationGroupPlayer.prototype.init = function() {
                this.players.forEach(function(player) {
                    return player.init();
                });
            }, AnimationGroupPlayer.prototype.onStart = function(fn) {
                this._onStartFns.push(fn);
            }, AnimationGroupPlayer.prototype._onStart = function() {
                this.hasStarted() || (this._started = !0, this._onStartFns.forEach(function(fn) {
                    return fn();
                }), this._onStartFns = []);
            }, AnimationGroupPlayer.prototype.onDone = function(fn) {
                this._onDoneFns.push(fn);
            }, AnimationGroupPlayer.prototype.onDestroy = function(fn) {
                this._onDestroyFns.push(fn);
            }, AnimationGroupPlayer.prototype.hasStarted = function() {
                return this._started;
            }, AnimationGroupPlayer.prototype.play = function() {
                this.parentPlayer || this.init(), this._onStart(), this.players.forEach(function(player) {
                    return player.play();
                });
            }, AnimationGroupPlayer.prototype.pause = function() {
                this.players.forEach(function(player) {
                    return player.pause();
                });
            }, AnimationGroupPlayer.prototype.restart = function() {
                this.players.forEach(function(player) {
                    return player.restart();
                });
            }, AnimationGroupPlayer.prototype.finish = function() {
                this._onFinish(), this.players.forEach(function(player) {
                    return player.finish();
                });
            }, AnimationGroupPlayer.prototype.destroy = function() {
                this._onDestroy();
            }, AnimationGroupPlayer.prototype._onDestroy = function() {
                this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(function(player) {
                    return player.destroy();
                }), this._onDestroyFns.forEach(function(fn) {
                    return fn();
                }), this._onDestroyFns = []);
            }, AnimationGroupPlayer.prototype.reset = function() {
                this.players.forEach(function(player) {
                    return player.reset();
                }), this._destroyed = !1, this._finished = !1, this._started = !1;
            }, AnimationGroupPlayer.prototype.setPosition = function(p) {
                var timeAtPosition = p * this.totalTime;
                this.players.forEach(function(player) {
                    var position = player.totalTime ? Math.min(1, timeAtPosition / player.totalTime) : 1;
                    player.setPosition(position);
                });
            }, AnimationGroupPlayer.prototype.getPosition = function() {
                var min = 0;
                return this.players.forEach(function(player) {
                    var p = player.getPosition();
                    min = Math.min(p, min);
                }), min;
            }, AnimationGroupPlayer.prototype.beforeDestroy = function() {
                this.players.forEach(function(player) {
                    player.beforeDestroy && player.beforeDestroy();
                });
            }, AnimationGroupPlayer.prototype.triggerCallback = function(phaseName) {
                var methods = "start" == phaseName ? this._onStartFns : this._onDoneFns;
                methods.forEach(function(fn) {
                    return fn();
                }), methods.length = 0;
            }, AnimationGroupPlayer;
        }(), \u0275PRE_STYLE = "!";
        function isNode() {
            return "undefined" != typeof process;
        }
        function optimizeGroupPlayer(players) {
            switch (players.length) {
              case 0:
                return new NoopAnimationPlayer();

              case 1:
                return players[0];

              default:
                return new AnimationGroupPlayer(players);
            }
        }
        function normalizeKeyframes(driver, normalizer, element, keyframes, preStyles, postStyles) {
            void 0 === preStyles && (preStyles = {}), void 0 === postStyles && (postStyles = {});
            var errors = [], normalizedKeyframes = [], previousOffset = -1, previousKeyframe = null;
            if (keyframes.forEach(function(kf) {
                var offset = kf.offset, isSameOffset = offset == previousOffset, normalizedKeyframe = isSameOffset && previousKeyframe || {};
                Object.keys(kf).forEach(function(prop) {
                    var normalizedProp = prop, normalizedValue = kf[prop];
                    if ("offset" !== prop) switch (normalizedProp = normalizer.normalizePropertyName(normalizedProp, errors), 
                    normalizedValue) {
                      case \u0275PRE_STYLE:
                        normalizedValue = preStyles[prop];
                        break;

                      case AUTO_STYLE:
                        normalizedValue = postStyles[prop];
                        break;

                      default:
                        normalizedValue = normalizer.normalizeStyleValue(prop, normalizedProp, normalizedValue, errors);
                    }
                    normalizedKeyframe[normalizedProp] = normalizedValue;
                }), isSameOffset || normalizedKeyframes.push(normalizedKeyframe), previousKeyframe = normalizedKeyframe, 
                previousOffset = offset;
            }), errors.length) throw new Error("Unable to animate due to the following errors:\n - " + errors.join("\n - "));
            return normalizedKeyframes;
        }
        function listenOnPlayer(player, eventName, event, callback) {
            switch (eventName) {
              case "start":
                player.onStart(function() {
                    return callback(event && copyAnimationEvent(event, "start", player));
                });
                break;

              case "done":
                player.onDone(function() {
                    return callback(event && copyAnimationEvent(event, "done", player));
                });
                break;

              case "destroy":
                player.onDestroy(function() {
                    return callback(event && copyAnimationEvent(event, "destroy", player));
                });
            }
        }
        function copyAnimationEvent(e, phaseName, player) {
            var totalTime = player.totalTime, event = makeAnimationEvent(e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName, null == totalTime ? e.totalTime : totalTime, !!player.disabled), data = e._data;
            return null != data && (event._data = data), event;
        }
        function makeAnimationEvent(element, triggerName, fromState, toState, phaseName, totalTime, disabled) {
            return void 0 === phaseName && (phaseName = ""), void 0 === totalTime && (totalTime = 0), 
            {
                element: element,
                triggerName: triggerName,
                fromState: fromState,
                toState: toState,
                phaseName: phaseName,
                totalTime: totalTime,
                disabled: !!disabled
            };
        }
        function getOrSetAsInMap(map, key, defaultValue) {
            var value;
            return map instanceof Map ? (value = map.get(key)) || map.set(key, value = defaultValue) : (value = map[key]) || (value = map[key] = defaultValue), 
            value;
        }
        function parseTimelineCommand(command) {
            var separatorPos = command.indexOf(":");
            return [ command.substring(1, separatorPos), command.substr(separatorPos + 1) ];
        }
        var _contains = function(elm1, elm2) {
            return !1;
        }, _matches = function(element, selector) {
            return !1;
        }, _query = function(element, selector, multi) {
            return [];
        }, _isNode = isNode();
        if (_isNode || "undefined" != typeof Element) {
            if (_contains = function(elm1, elm2) {
                return elm1.contains(elm2);
            }, _isNode || Element.prototype.matches) _matches = function(element, selector) {
                return element.matches(selector);
            }; else {
                var proto = Element.prototype, fn_1 = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
                fn_1 && (_matches = function(element, selector) {
                    return fn_1.apply(element, [ selector ]);
                });
            }
            _query = function(element, selector, multi) {
                var results = [];
                if (multi) results.push.apply(results, __spread(element.querySelectorAll(selector))); else {
                    var elm = element.querySelector(selector);
                    elm && results.push(elm);
                }
                return results;
            };
        }
        var _CACHED_BODY = null, _IS_WEBKIT = !1;
        function validateStyleProperty(prop) {
            _CACHED_BODY || (_CACHED_BODY = ("undefined" != typeof document ? document.body : null) || {}, 
            _IS_WEBKIT = !!_CACHED_BODY.style && "WebkitAppearance" in _CACHED_BODY.style);
            var result = !0;
            return _CACHED_BODY.style && !function(prop) {
                return "ebkit" == prop.substring(1, 6);
            }(prop) && !(result = prop in _CACHED_BODY.style) && _IS_WEBKIT && (result = "Webkit" + prop.charAt(0).toUpperCase() + prop.substr(1) in _CACHED_BODY.style), 
            result;
        }
        var matchesElement = _matches, containsElement = _contains, invokeQuery = _query;
        function hypenatePropsObject(object) {
            var newObj = {};
            return Object.keys(object).forEach(function(prop) {
                var newProp = prop.replace(/([a-z])([A-Z])/g, "$1-$2");
                newObj[newProp] = object[prop];
            }), newObj;
        }
        var browser_NoopAnimationDriver = function() {
            function NoopAnimationDriver() {}
            return NoopAnimationDriver.prototype.validateStyleProperty = function(prop) {
                return validateStyleProperty(prop);
            }, NoopAnimationDriver.prototype.matchesElement = function(element, selector) {
                return matchesElement(element, selector);
            }, NoopAnimationDriver.prototype.containsElement = function(elm1, elm2) {
                return containsElement(elm1, elm2);
            }, NoopAnimationDriver.prototype.query = function(element, selector, multi) {
                return invokeQuery(element, selector, multi);
            }, NoopAnimationDriver.prototype.computeStyle = function(element, prop, defaultValue) {
                return defaultValue || "";
            }, NoopAnimationDriver.prototype.animate = function(element, keyframes, duration, delay, easing, previousPlayers, scrubberAccessRequested) {
                return void 0 === previousPlayers && (previousPlayers = []), new NoopAnimationPlayer(duration, delay);
            }, NoopAnimationDriver.ngInjectableDef = defineInjectable({
                token: NoopAnimationDriver,
                factory: function(t) {
                    return new (t || NoopAnimationDriver)();
                },
                providedIn: null
            }), NoopAnimationDriver;
        }(), AnimationDriver = function() {
            function AnimationDriver() {}
            return AnimationDriver.NOOP = new browser_NoopAnimationDriver(), AnimationDriver;
        }(), ONE_SECOND = 1e3;
        function resolveTimingValue(value) {
            if ("number" == typeof value) return value;
            var matches = value.match(/^(-?[\.\d]+)(m?s)/);
            return !matches || matches.length < 2 ? 0 : _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
        }
        function _convertTimeValueToMS(value, unit) {
            switch (unit) {
              case "s":
                return value * ONE_SECOND;

              default:
                return value;
            }
        }
        function resolveTiming(timings, errors, allowNegativeValues) {
            return timings.hasOwnProperty("duration") ? timings : function(exp, errors, allowNegativeValues) {
                var duration, delay = 0, easing = "";
                if ("string" == typeof exp) {
                    var matches = exp.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);
                    if (null === matches) return errors.push('The provided timing value "' + exp + '" is invalid.'), 
                    {
                        duration: 0,
                        delay: 0,
                        easing: ""
                    };
                    duration = _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
                    var delayMatch = matches[3];
                    null != delayMatch && (delay = _convertTimeValueToMS(parseFloat(delayMatch), matches[4]));
                    var easingVal = matches[5];
                    easingVal && (easing = easingVal);
                } else duration = exp;
                if (!allowNegativeValues) {
                    var containsErrors = !1, startIndex = errors.length;
                    duration < 0 && (errors.push("Duration values below 0 are not allowed for this animation step."), 
                    containsErrors = !0), delay < 0 && (errors.push("Delay values below 0 are not allowed for this animation step."), 
                    containsErrors = !0), containsErrors && errors.splice(startIndex, 0, 'The provided timing value "' + exp + '" is invalid.');
                }
                return {
                    duration: duration,
                    delay: delay,
                    easing: easing
                };
            }(timings, errors, allowNegativeValues);
        }
        function copyObj(obj, destination) {
            return void 0 === destination && (destination = {}), Object.keys(obj).forEach(function(prop) {
                destination[prop] = obj[prop];
            }), destination;
        }
        function copyStyles(styles, readPrototype, destination) {
            if (void 0 === destination && (destination = {}), readPrototype) for (var prop in styles) destination[prop] = styles[prop]; else copyObj(styles, destination);
            return destination;
        }
        function getStyleAttributeString(element, key, value) {
            return value ? key + ":" + value + ";" : "";
        }
        function writeStyleAttribute(element) {
            for (var styleAttrValue = "", i = 0; i < element.style.length; i++) styleAttrValue += getStyleAttributeString(0, key = element.style.item(i), element.style.getPropertyValue(key));
            for (var key in element.style) element.style.hasOwnProperty(key) && !key.startsWith("_") && (styleAttrValue += getStyleAttributeString(0, key.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), element.style[key]));
            element.setAttribute("style", styleAttrValue);
        }
        function setStyles(element, styles, formerStyles) {
            element.style && (Object.keys(styles).forEach(function(prop) {
                var camelProp = dashCaseToCamelCase(prop);
                formerStyles && !formerStyles.hasOwnProperty(prop) && (formerStyles[prop] = element.style[camelProp]), 
                element.style[camelProp] = styles[prop];
            }), isNode() && writeStyleAttribute(element));
        }
        function eraseStyles(element, styles) {
            element.style && (Object.keys(styles).forEach(function(prop) {
                var camelProp = dashCaseToCamelCase(prop);
                element.style[camelProp] = "";
            }), isNode() && writeStyleAttribute(element));
        }
        function normalizeAnimationEntry(steps) {
            return Array.isArray(steps) ? 1 == steps.length ? steps[0] : sequence(steps) : steps;
        }
        var PARAM_REGEX = new RegExp("{{\\s*(.+?)\\s*}}", "g");
        function extractStyleParams(value) {
            var params = [];
            if ("string" == typeof value) {
                for (var val = value.toString(), match = void 0; match = PARAM_REGEX.exec(val); ) params.push(match[1]);
                PARAM_REGEX.lastIndex = 0;
            }
            return params;
        }
        function interpolateParams(value, params, errors) {
            var original = value.toString(), str = original.replace(PARAM_REGEX, function(_, varName) {
                var localVal = params[varName];
                return params.hasOwnProperty(varName) || (errors.push("Please provide a value for the animation param " + varName), 
                localVal = ""), localVal.toString();
            });
            return str == original ? value : str;
        }
        function iteratorToArray(iterator) {
            for (var arr = [], item = iterator.next(); !item.done; ) arr.push(item.value), item = iterator.next();
            return arr;
        }
        var DASH_CASE_REGEXP = /-+([a-z0-9])/g;
        function dashCaseToCamelCase(input) {
            return input.replace(DASH_CASE_REGEXP, function() {
                for (var m = [], _i = 0; _i < arguments.length; _i++) m[_i] = arguments[_i];
                return m[1].toUpperCase();
            });
        }
        function allowPreviousPlayerStylesMerge(duration, delay) {
            return 0 === duration || 0 === delay;
        }
        function balancePreviousStylesIntoKeyframes(element, keyframes, previousStyles) {
            var previousStyleProps = Object.keys(previousStyles);
            if (previousStyleProps.length && keyframes.length) {
                var startingKeyframe_1 = keyframes[0], missingStyleProps_1 = [];
                if (previousStyleProps.forEach(function(prop) {
                    startingKeyframe_1.hasOwnProperty(prop) || missingStyleProps_1.push(prop), startingKeyframe_1[prop] = previousStyles[prop];
                }), missingStyleProps_1.length) for (var _loop_1 = function() {
                    var kf = keyframes[i];
                    missingStyleProps_1.forEach(function(prop) {
                        kf[prop] = computeStyle(element, prop);
                    });
                }, i = 1; i < keyframes.length; i++) _loop_1();
            }
            return keyframes;
        }
        function visitDslNode(visitor, node, context) {
            switch (node.type) {
              case 7:
                return visitor.visitTrigger(node, context);

              case 0:
                return visitor.visitState(node, context);

              case 1:
                return visitor.visitTransition(node, context);

              case 2:
                return visitor.visitSequence(node, context);

              case 3:
                return visitor.visitGroup(node, context);

              case 4:
                return visitor.visitAnimate(node, context);

              case 5:
                return visitor.visitKeyframes(node, context);

              case 6:
                return visitor.visitStyle(node, context);

              case 8:
                return visitor.visitReference(node, context);

              case 9:
                return visitor.visitAnimateChild(node, context);

              case 10:
                return visitor.visitAnimateRef(node, context);

              case 11:
                return visitor.visitQuery(node, context);

              case 12:
                return visitor.visitStagger(node, context);

              default:
                throw new Error("Unable to resolve animation metadata node #" + node.type);
            }
        }
        function computeStyle(element, prop) {
            return window.getComputedStyle(element)[prop];
        }
        var ANY_STATE = "*", TRUE_BOOLEAN_VALUES = new Set([ "true", "1" ]), FALSE_BOOLEAN_VALUES = new Set([ "false", "0" ]);
        function makeLambdaFromStates(lhs, rhs) {
            var LHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(lhs) || FALSE_BOOLEAN_VALUES.has(lhs), RHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(rhs) || FALSE_BOOLEAN_VALUES.has(rhs);
            return function(fromState, toState) {
                var lhsMatch = lhs == ANY_STATE || lhs == fromState, rhsMatch = rhs == ANY_STATE || rhs == toState;
                return !lhsMatch && LHS_MATCH_BOOLEAN && "boolean" == typeof fromState && (lhsMatch = fromState ? TRUE_BOOLEAN_VALUES.has(lhs) : FALSE_BOOLEAN_VALUES.has(lhs)), 
                !rhsMatch && RHS_MATCH_BOOLEAN && "boolean" == typeof toState && (rhsMatch = toState ? TRUE_BOOLEAN_VALUES.has(rhs) : FALSE_BOOLEAN_VALUES.has(rhs)), 
                lhsMatch && rhsMatch;
            };
        }
        var SELF_TOKEN_REGEX = new RegExp("s*:selfs*,?", "g");
        function buildAnimationAst(driver, metadata, errors) {
            return new browser_AnimationAstBuilderVisitor(driver).build(metadata, errors);
        }
        var browser_AnimationAstBuilderVisitor = function() {
            function AnimationAstBuilderVisitor(_driver) {
                this._driver = _driver;
            }
            return AnimationAstBuilderVisitor.prototype.build = function(metadata, errors) {
                var context = new AnimationAstBuilderContext(errors);
                return this._resetContextStyleTimingState(context), visitDslNode(this, normalizeAnimationEntry(metadata), context);
            }, AnimationAstBuilderVisitor.prototype._resetContextStyleTimingState = function(context) {
                context.currentQuerySelector = "", context.collectedStyles = {}, context.collectedStyles[""] = {}, 
                context.currentTime = 0;
            }, AnimationAstBuilderVisitor.prototype.visitTrigger = function(metadata, context) {
                var _this = this, queryCount = context.queryCount = 0, depCount = context.depCount = 0, states = [], transitions = [];
                return "@" == metadata.name.charAt(0) && context.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"), 
                metadata.definitions.forEach(function(def) {
                    if (_this._resetContextStyleTimingState(context), 0 == def.type) {
                        var stateDef_1 = def, name_1 = stateDef_1.name;
                        name_1.toString().split(/\s*,\s*/).forEach(function(n) {
                            stateDef_1.name = n, states.push(_this.visitState(stateDef_1, context));
                        }), stateDef_1.name = name_1;
                    } else if (1 == def.type) {
                        var transition = _this.visitTransition(def, context);
                        queryCount += transition.queryCount, depCount += transition.depCount, transitions.push(transition);
                    } else context.errors.push("only state() and transition() definitions can sit inside of a trigger()");
                }), {
                    type: 7,
                    name: metadata.name,
                    states: states,
                    transitions: transitions,
                    queryCount: queryCount,
                    depCount: depCount,
                    options: null
                };
            }, AnimationAstBuilderVisitor.prototype.visitState = function(metadata, context) {
                var styleAst = this.visitStyle(metadata.styles, context), astParams = metadata.options && metadata.options.params || null;
                if (styleAst.containsDynamicStyles) {
                    var missingSubs_1 = new Set(), params_1 = astParams || {};
                    if (styleAst.styles.forEach(function(value) {
                        if (browser_isObject(value)) {
                            var stylesObj_1 = value;
                            Object.keys(stylesObj_1).forEach(function(prop) {
                                extractStyleParams(stylesObj_1[prop]).forEach(function(sub) {
                                    params_1.hasOwnProperty(sub) || missingSubs_1.add(sub);
                                });
                            });
                        }
                    }), missingSubs_1.size) {
                        var missingSubsArr = iteratorToArray(missingSubs_1.values());
                        context.errors.push('state("' + metadata.name + '", ...) must define default values for all the following style substitutions: ' + missingSubsArr.join(", "));
                    }
                }
                return {
                    type: 0,
                    name: metadata.name,
                    style: styleAst,
                    options: astParams ? {
                        params: astParams
                    } : null
                };
            }, AnimationAstBuilderVisitor.prototype.visitTransition = function(metadata, context) {
                context.queryCount = 0, context.depCount = 0;
                var transitionValue, errors, expressions, animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);
                return {
                    type: 1,
                    matchers: (transitionValue = metadata.expr, errors = context.errors, expressions = [], 
                    "string" == typeof transitionValue ? transitionValue.split(/\s*,\s*/).forEach(function(str) {
                        return function(eventStr, expressions, errors) {
                            if (":" == eventStr[0]) {
                                var result = function(alias, errors) {
                                    switch (alias) {
                                      case ":enter":
                                        return "void => *";

                                      case ":leave":
                                        return "* => void";

                                      case ":increment":
                                        return function(fromState, toState) {
                                            return parseFloat(toState) > parseFloat(fromState);
                                        };

                                      case ":decrement":
                                        return function(fromState, toState) {
                                            return parseFloat(toState) < parseFloat(fromState);
                                        };

                                      default:
                                        return errors.push('The transition alias value "' + alias + '" is not supported'), 
                                        "* => *";
                                    }
                                }(eventStr, errors);
                                if ("function" == typeof result) return void expressions.push(result);
                                eventStr = result;
                            }
                            var match = eventStr.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
                            if (null == match || match.length < 4) return errors.push('The provided transition expression "' + eventStr + '" is not supported'), 
                            expressions;
                            var fromState = match[1], separator = match[2], toState = match[3];
                            expressions.push(makeLambdaFromStates(fromState, toState)), "<" != separator[0] || fromState == ANY_STATE && toState == ANY_STATE || expressions.push(makeLambdaFromStates(toState, fromState));
                        }(str, expressions, errors);
                    }) : expressions.push(transitionValue), expressions),
                    animation: animation,
                    queryCount: context.queryCount,
                    depCount: context.depCount,
                    options: normalizeAnimationOptions(metadata.options)
                };
            }, AnimationAstBuilderVisitor.prototype.visitSequence = function(metadata, context) {
                var _this = this;
                return {
                    type: 2,
                    steps: metadata.steps.map(function(s) {
                        return visitDslNode(_this, s, context);
                    }),
                    options: normalizeAnimationOptions(metadata.options)
                };
            }, AnimationAstBuilderVisitor.prototype.visitGroup = function(metadata, context) {
                var _this = this, currentTime = context.currentTime, furthestTime = 0, steps = metadata.steps.map(function(step) {
                    context.currentTime = currentTime;
                    var innerAst = visitDslNode(_this, step, context);
                    return furthestTime = Math.max(furthestTime, context.currentTime), innerAst;
                });
                return context.currentTime = furthestTime, {
                    type: 3,
                    steps: steps,
                    options: normalizeAnimationOptions(metadata.options)
                };
            }, AnimationAstBuilderVisitor.prototype.visitAnimate = function(metadata, context) {
                var styleAst, timingAst = function(value, errors) {
                    var timings = null;
                    if (value.hasOwnProperty("duration")) timings = value; else if ("number" == typeof value) return makeTimingAst(resolveTiming(value, errors).duration, 0, "");
                    var strValue = value;
                    if (strValue.split(/\s+/).some(function(v) {
                        return "{" == v.charAt(0) && "{" == v.charAt(1);
                    })) {
                        var ast = makeTimingAst(0, 0, "");
                        return ast.dynamic = !0, ast.strValue = strValue, ast;
                    }
                    return makeTimingAst((timings = timings || resolveTiming(strValue, errors)).duration, timings.delay, timings.easing);
                }(metadata.timings, context.errors);
                context.currentAnimateTimings = timingAst;
                var styleMetadata = metadata.styles ? metadata.styles : animations_style({});
                if (5 == styleMetadata.type) styleAst = this.visitKeyframes(styleMetadata, context); else {
                    var styleMetadata_1 = metadata.styles, isEmpty = !1;
                    if (!styleMetadata_1) {
                        isEmpty = !0;
                        var newStyleData = {};
                        timingAst.easing && (newStyleData.easing = timingAst.easing), styleMetadata_1 = animations_style(newStyleData);
                    }
                    context.currentTime += timingAst.duration + timingAst.delay;
                    var _styleAst = this.visitStyle(styleMetadata_1, context);
                    _styleAst.isEmptyStep = isEmpty, styleAst = _styleAst;
                }
                return context.currentAnimateTimings = null, {
                    type: 4,
                    timings: timingAst,
                    style: styleAst,
                    options: null
                };
            }, AnimationAstBuilderVisitor.prototype.visitStyle = function(metadata, context) {
                var ast = this._makeStyleAst(metadata, context);
                return this._validateStyleAst(ast, context), ast;
            }, AnimationAstBuilderVisitor.prototype._makeStyleAst = function(metadata, context) {
                var styles = [];
                Array.isArray(metadata.styles) ? metadata.styles.forEach(function(styleTuple) {
                    "string" == typeof styleTuple ? styleTuple == AUTO_STYLE ? styles.push(styleTuple) : context.errors.push("The provided style string value " + styleTuple + " is not allowed.") : styles.push(styleTuple);
                }) : styles.push(metadata.styles);
                var containsDynamicStyles = !1, collectedEasing = null;
                return styles.forEach(function(styleData) {
                    if (browser_isObject(styleData)) {
                        var styleMap = styleData, easing = styleMap.easing;
                        if (easing && (collectedEasing = easing, delete styleMap.easing), !containsDynamicStyles) for (var prop in styleMap) if (styleMap[prop].toString().indexOf("{{") >= 0) {
                            containsDynamicStyles = !0;
                            break;
                        }
                    }
                }), {
                    type: 6,
                    styles: styles,
                    easing: collectedEasing,
                    offset: metadata.offset,
                    containsDynamicStyles: containsDynamicStyles,
                    options: null
                };
            }, AnimationAstBuilderVisitor.prototype._validateStyleAst = function(ast, context) {
                var _this = this, timings = context.currentAnimateTimings, endTime = context.currentTime, startTime = context.currentTime;
                timings && startTime > 0 && (startTime -= timings.duration + timings.delay), ast.styles.forEach(function(tuple) {
                    "string" != typeof tuple && Object.keys(tuple).forEach(function(prop) {
                        if (_this._driver.validateStyleProperty(prop)) {
                            var errors, params, matches, collectedStyles = context.collectedStyles[context.currentQuerySelector], collectedEntry = collectedStyles[prop], updateCollectedStyle = !0;
                            collectedEntry && (startTime != endTime && startTime >= collectedEntry.startTime && endTime <= collectedEntry.endTime && (context.errors.push('The CSS property "' + prop + '" that exists between the times of "' + collectedEntry.startTime + 'ms" and "' + collectedEntry.endTime + 'ms" is also being animated in a parallel animation between the times of "' + startTime + 'ms" and "' + endTime + 'ms"'), 
                            updateCollectedStyle = !1), startTime = collectedEntry.startTime), updateCollectedStyle && (collectedStyles[prop] = {
                                startTime: startTime,
                                endTime: endTime
                            }), context.options && (errors = context.errors, params = context.options.params || {}, 
                            (matches = extractStyleParams(tuple[prop])).length && matches.forEach(function(varName) {
                                params.hasOwnProperty(varName) || errors.push("Unable to resolve the local animation param " + varName + " in the given list of values");
                            }));
                        } else context.errors.push('The provided animation property "' + prop + '" is not a supported CSS property for animations');
                    });
                });
            }, AnimationAstBuilderVisitor.prototype.visitKeyframes = function(metadata, context) {
                var _this = this, ast = {
                    type: 5,
                    styles: [],
                    options: null
                };
                if (!context.currentAnimateTimings) return context.errors.push("keyframes() must be placed inside of a call to animate()"), 
                ast;
                var totalKeyframesWithOffsets = 0, offsets = [], offsetsOutOfOrder = !1, keyframesOutOfRange = !1, previousOffset = 0, keyframes = metadata.steps.map(function(styles) {
                    var style = _this._makeStyleAst(styles, context), offsetVal = null != style.offset ? style.offset : function(styles) {
                        if ("string" == typeof styles) return null;
                        var offset = null;
                        if (Array.isArray(styles)) styles.forEach(function(styleTuple) {
                            if (browser_isObject(styleTuple) && styleTuple.hasOwnProperty("offset")) {
                                var obj = styleTuple;
                                offset = parseFloat(obj.offset), delete obj.offset;
                            }
                        }); else if (browser_isObject(styles) && styles.hasOwnProperty("offset")) {
                            var obj = styles;
                            offset = parseFloat(obj.offset), delete obj.offset;
                        }
                        return offset;
                    }(style.styles), offset = 0;
                    return null != offsetVal && (totalKeyframesWithOffsets++, offset = style.offset = offsetVal), 
                    keyframesOutOfRange = keyframesOutOfRange || offset < 0 || offset > 1, offsetsOutOfOrder = offsetsOutOfOrder || offset < previousOffset, 
                    previousOffset = offset, offsets.push(offset), style;
                });
                keyframesOutOfRange && context.errors.push("Please ensure that all keyframe offsets are between 0 and 1"), 
                offsetsOutOfOrder && context.errors.push("Please ensure that all keyframe offsets are in order");
                var length = metadata.steps.length, generatedOffset = 0;
                totalKeyframesWithOffsets > 0 && totalKeyframesWithOffsets < length ? context.errors.push("Not all style() steps within the declared keyframes() contain offsets") : 0 == totalKeyframesWithOffsets && (generatedOffset = 1 / (length - 1));
                var limit = length - 1, currentTime = context.currentTime, currentAnimateTimings = context.currentAnimateTimings, animateDuration = currentAnimateTimings.duration;
                return keyframes.forEach(function(kf, i) {
                    var offset = generatedOffset > 0 ? i == limit ? 1 : generatedOffset * i : offsets[i], durationUpToThisFrame = offset * animateDuration;
                    context.currentTime = currentTime + currentAnimateTimings.delay + durationUpToThisFrame, 
                    currentAnimateTimings.duration = durationUpToThisFrame, _this._validateStyleAst(kf, context), 
                    kf.offset = offset, ast.styles.push(kf);
                }), ast;
            }, AnimationAstBuilderVisitor.prototype.visitReference = function(metadata, context) {
                return {
                    type: 8,
                    animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),
                    options: normalizeAnimationOptions(metadata.options)
                };
            }, AnimationAstBuilderVisitor.prototype.visitAnimateChild = function(metadata, context) {
                return context.depCount++, {
                    type: 9,
                    options: normalizeAnimationOptions(metadata.options)
                };
            }, AnimationAstBuilderVisitor.prototype.visitAnimateRef = function(metadata, context) {
                return {
                    type: 10,
                    animation: this.visitReference(metadata.animation, context),
                    options: normalizeAnimationOptions(metadata.options)
                };
            }, AnimationAstBuilderVisitor.prototype.visitQuery = function(metadata, context) {
                var parentSelector = context.currentQuerySelector, options = metadata.options || {};
                context.queryCount++, context.currentQuery = metadata;
                var _a = __read(function(selector) {
                    var hasAmpersand = !!selector.split(/\s*,\s*/).find(function(token) {
                        return ":self" == token;
                    });
                    return hasAmpersand && (selector = selector.replace(SELF_TOKEN_REGEX, "")), [ selector = selector.replace(/@\*/g, ".ng-trigger").replace(/@\w+/g, function(match) {
                        return ".ng-trigger-" + match.substr(1);
                    }).replace(/:animating/g, ".ng-animating"), hasAmpersand ];
                }(metadata.selector), 2), selector = _a[0], includeSelf = _a[1];
                context.currentQuerySelector = parentSelector.length ? parentSelector + " " + selector : selector, 
                getOrSetAsInMap(context.collectedStyles, context.currentQuerySelector, {});
                var animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);
                return context.currentQuery = null, context.currentQuerySelector = parentSelector, 
                {
                    type: 11,
                    selector: selector,
                    limit: options.limit || 0,
                    optional: !!options.optional,
                    includeSelf: includeSelf,
                    animation: animation,
                    originalSelector: metadata.selector,
                    options: normalizeAnimationOptions(metadata.options)
                };
            }, AnimationAstBuilderVisitor.prototype.visitStagger = function(metadata, context) {
                context.currentQuery || context.errors.push("stagger() can only be used inside of query()");
                var timings = "full" === metadata.timings ? {
                    duration: 0,
                    delay: 0,
                    easing: "full"
                } : resolveTiming(metadata.timings, context.errors, !0);
                return {
                    type: 12,
                    animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),
                    timings: timings,
                    options: null
                };
            }, AnimationAstBuilderVisitor;
        }(), AnimationAstBuilderContext = function() {
            return function(errors) {
                this.errors = errors, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, 
                this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, 
                this.currentTime = 0, this.collectedStyles = {}, this.options = null;
            };
        }();
        function browser_isObject(value) {
            return !Array.isArray(value) && "object" == typeof value;
        }
        function normalizeAnimationOptions(options) {
            var obj;
            return options ? (options = copyObj(options)).params && (options.params = (obj = options.params) ? copyObj(obj) : null) : options = {}, 
            options;
        }
        function makeTimingAst(duration, delay, easing) {
            return {
                duration: duration,
                delay: delay,
                easing: easing
            };
        }
        function createTimelineInstruction(element, keyframes, preStyleProps, postStyleProps, duration, delay, easing, subTimeline) {
            return void 0 === easing && (easing = null), void 0 === subTimeline && (subTimeline = !1), 
            {
                type: 1,
                element: element,
                keyframes: keyframes,
                preStyleProps: preStyleProps,
                postStyleProps: postStyleProps,
                duration: duration,
                delay: delay,
                totalTime: duration + delay,
                easing: easing,
                subTimeline: subTimeline
            };
        }
        var browser_ElementInstructionMap = function() {
            function ElementInstructionMap() {
                this._map = new Map();
            }
            return ElementInstructionMap.prototype.consume = function(element) {
                var instructions = this._map.get(element);
                return instructions ? this._map.delete(element) : instructions = [], instructions;
            }, ElementInstructionMap.prototype.append = function(element, instructions) {
                var existingInstructions = this._map.get(element);
                existingInstructions || this._map.set(element, existingInstructions = []), existingInstructions.push.apply(existingInstructions, __spread(instructions));
            }, ElementInstructionMap.prototype.has = function(element) {
                return this._map.has(element);
            }, ElementInstructionMap.prototype.clear = function() {
                this._map.clear();
            }, ElementInstructionMap;
        }(), ENTER_TOKEN_REGEX = new RegExp(":enter", "g"), LEAVE_TOKEN_REGEX = new RegExp(":leave", "g");
        function buildAnimationTimelines(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors) {
            return void 0 === startingStyles && (startingStyles = {}), void 0 === finalStyles && (finalStyles = {}), 
            void 0 === errors && (errors = []), new AnimationTimelineBuilderVisitor().buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors);
        }
        var AnimationTimelineBuilderVisitor = function() {
            function AnimationTimelineBuilderVisitor() {}
            return AnimationTimelineBuilderVisitor.prototype.buildKeyframes = function(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors) {
                void 0 === errors && (errors = []), subInstructions = subInstructions || new browser_ElementInstructionMap();
                var context = new browser_AnimationTimelineContext(driver, rootElement, subInstructions, enterClassName, leaveClassName, errors, []);
                context.options = options, context.currentTimeline.setStyles([ startingStyles ], null, context.errors, options), 
                visitDslNode(this, ast, context);
                var timelines = context.timelines.filter(function(timeline) {
                    return timeline.containsAnimation();
                });
                if (timelines.length && Object.keys(finalStyles).length) {
                    var tl = timelines[timelines.length - 1];
                    tl.allowOnlyTimelineStyles() || tl.setStyles([ finalStyles ], null, context.errors, options);
                }
                return timelines.length ? timelines.map(function(timeline) {
                    return timeline.buildKeyframes();
                }) : [ createTimelineInstruction(rootElement, [], [], [], 0, 0, "", !1) ];
            }, AnimationTimelineBuilderVisitor.prototype.visitTrigger = function(ast, context) {}, 
            AnimationTimelineBuilderVisitor.prototype.visitState = function(ast, context) {}, 
            AnimationTimelineBuilderVisitor.prototype.visitTransition = function(ast, context) {}, 
            AnimationTimelineBuilderVisitor.prototype.visitAnimateChild = function(ast, context) {
                var elementInstructions = context.subInstructions.consume(context.element);
                if (elementInstructions) {
                    var innerContext = context.createSubContext(ast.options), startTime = context.currentTimeline.currentTime, endTime = this._visitSubInstructions(elementInstructions, innerContext, innerContext.options);
                    startTime != endTime && context.transformIntoNewTimeline(endTime);
                }
                context.previousNode = ast;
            }, AnimationTimelineBuilderVisitor.prototype.visitAnimateRef = function(ast, context) {
                var innerContext = context.createSubContext(ast.options);
                innerContext.transformIntoNewTimeline(), this.visitReference(ast.animation, innerContext), 
                context.transformIntoNewTimeline(innerContext.currentTimeline.currentTime), context.previousNode = ast;
            }, AnimationTimelineBuilderVisitor.prototype._visitSubInstructions = function(instructions, context, options) {
                var furthestTime = context.currentTimeline.currentTime, duration = null != options.duration ? resolveTimingValue(options.duration) : null, delay = null != options.delay ? resolveTimingValue(options.delay) : null;
                return 0 !== duration && instructions.forEach(function(instruction) {
                    var instructionTimings = context.appendInstructionToTimeline(instruction, duration, delay);
                    furthestTime = Math.max(furthestTime, instructionTimings.duration + instructionTimings.delay);
                }), furthestTime;
            }, AnimationTimelineBuilderVisitor.prototype.visitReference = function(ast, context) {
                context.updateOptions(ast.options, !0), visitDslNode(this, ast.animation, context), 
                context.previousNode = ast;
            }, AnimationTimelineBuilderVisitor.prototype.visitSequence = function(ast, context) {
                var _this = this, subContextCount = context.subContextCount, ctx = context, options = ast.options;
                if (options && (options.params || options.delay) && ((ctx = context.createSubContext(options)).transformIntoNewTimeline(), 
                null != options.delay)) {
                    6 == ctx.previousNode.type && (ctx.currentTimeline.snapshotCurrentStyles(), ctx.previousNode = DEFAULT_NOOP_PREVIOUS_NODE);
                    var delay = resolveTimingValue(options.delay);
                    ctx.delayNextStep(delay);
                }
                ast.steps.length && (ast.steps.forEach(function(s) {
                    return visitDslNode(_this, s, ctx);
                }), ctx.currentTimeline.applyStylesToKeyframe(), ctx.subContextCount > subContextCount && ctx.transformIntoNewTimeline()), 
                context.previousNode = ast;
            }, AnimationTimelineBuilderVisitor.prototype.visitGroup = function(ast, context) {
                var _this = this, innerTimelines = [], furthestTime = context.currentTimeline.currentTime, delay = ast.options && ast.options.delay ? resolveTimingValue(ast.options.delay) : 0;
                ast.steps.forEach(function(s) {
                    var innerContext = context.createSubContext(ast.options);
                    delay && innerContext.delayNextStep(delay), visitDslNode(_this, s, innerContext), 
                    furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime), 
                    innerTimelines.push(innerContext.currentTimeline);
                }), innerTimelines.forEach(function(timeline) {
                    return context.currentTimeline.mergeTimelineCollectedStyles(timeline);
                }), context.transformIntoNewTimeline(furthestTime), context.previousNode = ast;
            }, AnimationTimelineBuilderVisitor.prototype._visitTiming = function(ast, context) {
                if (ast.dynamic) {
                    var strValue = ast.strValue;
                    return resolveTiming(context.params ? interpolateParams(strValue, context.params, context.errors) : strValue, context.errors);
                }
                return {
                    duration: ast.duration,
                    delay: ast.delay,
                    easing: ast.easing
                };
            }, AnimationTimelineBuilderVisitor.prototype.visitAnimate = function(ast, context) {
                var timings = context.currentAnimateTimings = this._visitTiming(ast.timings, context), timeline = context.currentTimeline;
                timings.delay && (context.incrementTime(timings.delay), timeline.snapshotCurrentStyles());
                var style = ast.style;
                5 == style.type ? this.visitKeyframes(style, context) : (context.incrementTime(timings.duration), 
                this.visitStyle(style, context), timeline.applyStylesToKeyframe()), context.currentAnimateTimings = null, 
                context.previousNode = ast;
            }, AnimationTimelineBuilderVisitor.prototype.visitStyle = function(ast, context) {
                var timeline = context.currentTimeline, timings = context.currentAnimateTimings;
                !timings && timeline.getCurrentStyleProperties().length && timeline.forwardFrame();
                var easing = timings && timings.easing || ast.easing;
                ast.isEmptyStep ? timeline.applyEmptyStep(easing) : timeline.setStyles(ast.styles, easing, context.errors, context.options), 
                context.previousNode = ast;
            }, AnimationTimelineBuilderVisitor.prototype.visitKeyframes = function(ast, context) {
                var currentAnimateTimings = context.currentAnimateTimings, startTime = context.currentTimeline.duration, duration = currentAnimateTimings.duration, innerTimeline = context.createSubContext().currentTimeline;
                innerTimeline.easing = currentAnimateTimings.easing, ast.styles.forEach(function(step) {
                    innerTimeline.forwardTime((step.offset || 0) * duration), innerTimeline.setStyles(step.styles, step.easing, context.errors, context.options), 
                    innerTimeline.applyStylesToKeyframe();
                }), context.currentTimeline.mergeTimelineCollectedStyles(innerTimeline), context.transformIntoNewTimeline(startTime + duration), 
                context.previousNode = ast;
            }, AnimationTimelineBuilderVisitor.prototype.visitQuery = function(ast, context) {
                var _this = this, startTime = context.currentTimeline.currentTime, options = ast.options || {}, delay = options.delay ? resolveTimingValue(options.delay) : 0;
                delay && (6 === context.previousNode.type || 0 == startTime && context.currentTimeline.getCurrentStyleProperties().length) && (context.currentTimeline.snapshotCurrentStyles(), 
                context.previousNode = DEFAULT_NOOP_PREVIOUS_NODE);
                var furthestTime = startTime, elms = context.invokeQuery(ast.selector, ast.originalSelector, ast.limit, ast.includeSelf, !!options.optional, context.errors);
                context.currentQueryTotal = elms.length;
                var sameElementTimeline = null;
                elms.forEach(function(element, i) {
                    context.currentQueryIndex = i;
                    var innerContext = context.createSubContext(ast.options, element);
                    delay && innerContext.delayNextStep(delay), element === context.element && (sameElementTimeline = innerContext.currentTimeline), 
                    visitDslNode(_this, ast.animation, innerContext), innerContext.currentTimeline.applyStylesToKeyframe(), 
                    furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);
                }), context.currentQueryIndex = 0, context.currentQueryTotal = 0, context.transformIntoNewTimeline(furthestTime), 
                sameElementTimeline && (context.currentTimeline.mergeTimelineCollectedStyles(sameElementTimeline), 
                context.currentTimeline.snapshotCurrentStyles()), context.previousNode = ast;
            }, AnimationTimelineBuilderVisitor.prototype.visitStagger = function(ast, context) {
                var parentContext = context.parentContext, tl = context.currentTimeline, timings = ast.timings, duration = Math.abs(timings.duration), maxTime = duration * (context.currentQueryTotal - 1), delay = duration * context.currentQueryIndex;
                switch (timings.duration < 0 ? "reverse" : timings.easing) {
                  case "reverse":
                    delay = maxTime - delay;
                    break;

                  case "full":
                    delay = parentContext.currentStaggerTime;
                }
                var timeline = context.currentTimeline;
                delay && timeline.delayNextStep(delay);
                var startingTime = timeline.currentTime;
                visitDslNode(this, ast.animation, context), context.previousNode = ast, parentContext.currentStaggerTime = tl.currentTime - startingTime + (tl.startTime - parentContext.currentTimeline.startTime);
            }, AnimationTimelineBuilderVisitor;
        }(), DEFAULT_NOOP_PREVIOUS_NODE = {}, browser_AnimationTimelineContext = function() {
            function AnimationTimelineContext(_driver, element, subInstructions, _enterClassName, _leaveClassName, errors, timelines, initialTimeline) {
                this._driver = _driver, this.element = element, this.subInstructions = subInstructions, 
                this._enterClassName = _enterClassName, this._leaveClassName = _leaveClassName, 
                this.errors = errors, this.timelines = timelines, this.parentContext = null, this.currentAnimateTimings = null, 
                this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE, this.subContextCount = 0, this.options = {}, 
                this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, 
                this.currentTimeline = initialTimeline || new browser_TimelineBuilder(this._driver, element, 0), 
                timelines.push(this.currentTimeline);
            }
            return Object.defineProperty(AnimationTimelineContext.prototype, "params", {
                get: function() {
                    return this.options.params;
                },
                enumerable: !0,
                configurable: !0
            }), AnimationTimelineContext.prototype.updateOptions = function(options, skipIfExists) {
                var _this = this;
                if (options) {
                    var newOptions = options, optionsToUpdate = this.options;
                    null != newOptions.duration && (optionsToUpdate.duration = resolveTimingValue(newOptions.duration)), 
                    null != newOptions.delay && (optionsToUpdate.delay = resolveTimingValue(newOptions.delay));
                    var newParams = newOptions.params;
                    if (newParams) {
                        var paramsToUpdate_1 = optionsToUpdate.params;
                        paramsToUpdate_1 || (paramsToUpdate_1 = this.options.params = {}), Object.keys(newParams).forEach(function(name) {
                            skipIfExists && paramsToUpdate_1.hasOwnProperty(name) || (paramsToUpdate_1[name] = interpolateParams(newParams[name], paramsToUpdate_1, _this.errors));
                        });
                    }
                }
            }, AnimationTimelineContext.prototype._copyOptions = function() {
                var options = {};
                if (this.options) {
                    var oldParams_1 = this.options.params;
                    if (oldParams_1) {
                        var params_1 = options.params = {};
                        Object.keys(oldParams_1).forEach(function(name) {
                            params_1[name] = oldParams_1[name];
                        });
                    }
                }
                return options;
            }, AnimationTimelineContext.prototype.createSubContext = function(options, element, newTime) {
                void 0 === options && (options = null);
                var target = element || this.element, context = new AnimationTimelineContext(this._driver, target, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(target, newTime || 0));
                return context.previousNode = this.previousNode, context.currentAnimateTimings = this.currentAnimateTimings, 
                context.options = this._copyOptions(), context.updateOptions(options), context.currentQueryIndex = this.currentQueryIndex, 
                context.currentQueryTotal = this.currentQueryTotal, context.parentContext = this, 
                this.subContextCount++, context;
            }, AnimationTimelineContext.prototype.transformIntoNewTimeline = function(newTime) {
                return this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE, this.currentTimeline = this.currentTimeline.fork(this.element, newTime), 
                this.timelines.push(this.currentTimeline), this.currentTimeline;
            }, AnimationTimelineContext.prototype.appendInstructionToTimeline = function(instruction, duration, delay) {
                var updatedTimings = {
                    duration: null != duration ? duration : instruction.duration,
                    delay: this.currentTimeline.currentTime + (null != delay ? delay : 0) + instruction.delay,
                    easing: ""
                }, builder = new browser_SubTimelineBuilder(this._driver, instruction.element, instruction.keyframes, instruction.preStyleProps, instruction.postStyleProps, updatedTimings, instruction.stretchStartingKeyframe);
                return this.timelines.push(builder), updatedTimings;
            }, AnimationTimelineContext.prototype.incrementTime = function(time) {
                this.currentTimeline.forwardTime(this.currentTimeline.duration + time);
            }, AnimationTimelineContext.prototype.delayNextStep = function(delay) {
                delay > 0 && this.currentTimeline.delayNextStep(delay);
            }, AnimationTimelineContext.prototype.invokeQuery = function(selector, originalSelector, limit, includeSelf, optional, errors) {
                var results = [];
                if (includeSelf && results.push(this.element), selector.length > 0) {
                    selector = (selector = selector.replace(ENTER_TOKEN_REGEX, "." + this._enterClassName)).replace(LEAVE_TOKEN_REGEX, "." + this._leaveClassName);
                    var elements = this._driver.query(this.element, selector, 1 != limit);
                    0 !== limit && (elements = limit < 0 ? elements.slice(elements.length + limit, elements.length) : elements.slice(0, limit)), 
                    results.push.apply(results, __spread(elements));
                }
                return optional || 0 != results.length || errors.push('`query("' + originalSelector + '")` returned zero elements. (Use `query("' + originalSelector + '", { optional: true })` if you wish to allow this.)'), 
                results;
            }, AnimationTimelineContext;
        }(), browser_TimelineBuilder = function() {
            function TimelineBuilder(_driver, element, startTime, _elementTimelineStylesLookup) {
                this._driver = _driver, this.element = element, this.startTime = startTime, this._elementTimelineStylesLookup = _elementTimelineStylesLookup, 
                this.duration = 0, this._previousKeyframe = {}, this._currentKeyframe = {}, this._keyframes = new Map(), 
                this._styleSummary = {}, this._pendingStyles = {}, this._backFill = {}, this._currentEmptyStepKeyframe = null, 
                this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map()), 
                this._localTimelineStyles = Object.create(this._backFill, {}), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(element), 
                this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, 
                this._elementTimelineStylesLookup.set(element, this._localTimelineStyles)), this._loadKeyframe();
            }
            return TimelineBuilder.prototype.containsAnimation = function() {
                switch (this._keyframes.size) {
                  case 0:
                    return !1;

                  case 1:
                    return this.getCurrentStyleProperties().length > 0;

                  default:
                    return !0;
                }
            }, TimelineBuilder.prototype.getCurrentStyleProperties = function() {
                return Object.keys(this._currentKeyframe);
            }, Object.defineProperty(TimelineBuilder.prototype, "currentTime", {
                get: function() {
                    return this.startTime + this.duration;
                },
                enumerable: !0,
                configurable: !0
            }), TimelineBuilder.prototype.delayNextStep = function(delay) {
                var hasPreStyleStep = 1 == this._keyframes.size && Object.keys(this._pendingStyles).length;
                this.duration || hasPreStyleStep ? (this.forwardTime(this.currentTime + delay), 
                hasPreStyleStep && this.snapshotCurrentStyles()) : this.startTime += delay;
            }, TimelineBuilder.prototype.fork = function(element, currentTime) {
                return this.applyStylesToKeyframe(), new TimelineBuilder(this._driver, element, currentTime || this.currentTime, this._elementTimelineStylesLookup);
            }, TimelineBuilder.prototype._loadKeyframe = function() {
                this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), 
                this._currentKeyframe || (this._currentKeyframe = Object.create(this._backFill, {}), 
                this._keyframes.set(this.duration, this._currentKeyframe));
            }, TimelineBuilder.prototype.forwardFrame = function() {
                this.duration += 1, this._loadKeyframe();
            }, TimelineBuilder.prototype.forwardTime = function(time) {
                this.applyStylesToKeyframe(), this.duration = time, this._loadKeyframe();
            }, TimelineBuilder.prototype._updateStyle = function(prop, value) {
                this._localTimelineStyles[prop] = value, this._globalTimelineStyles[prop] = value, 
                this._styleSummary[prop] = {
                    time: this.currentTime,
                    value: value
                };
            }, TimelineBuilder.prototype.allowOnlyTimelineStyles = function() {
                return this._currentEmptyStepKeyframe !== this._currentKeyframe;
            }, TimelineBuilder.prototype.applyEmptyStep = function(easing) {
                var _this = this;
                easing && (this._previousKeyframe.easing = easing), Object.keys(this._globalTimelineStyles).forEach(function(prop) {
                    _this._backFill[prop] = _this._globalTimelineStyles[prop] || AUTO_STYLE, _this._currentKeyframe[prop] = AUTO_STYLE;
                }), this._currentEmptyStepKeyframe = this._currentKeyframe;
            }, TimelineBuilder.prototype.setStyles = function(input, easing, errors, options) {
                var _this = this;
                easing && (this._previousKeyframe.easing = easing);
                var params = options && options.params || {}, styles = function(input, allStyles) {
                    var allProperties, styles = {};
                    return input.forEach(function(token) {
                        "*" === token ? (allProperties = allProperties || Object.keys(allStyles)).forEach(function(prop) {
                            styles[prop] = AUTO_STYLE;
                        }) : copyStyles(token, !1, styles);
                    }), styles;
                }(input, this._globalTimelineStyles);
                Object.keys(styles).forEach(function(prop) {
                    var val = interpolateParams(styles[prop], params, errors);
                    _this._pendingStyles[prop] = val, _this._localTimelineStyles.hasOwnProperty(prop) || (_this._backFill[prop] = _this._globalTimelineStyles.hasOwnProperty(prop) ? _this._globalTimelineStyles[prop] : AUTO_STYLE), 
                    _this._updateStyle(prop, val);
                });
            }, TimelineBuilder.prototype.applyStylesToKeyframe = function() {
                var _this = this, styles = this._pendingStyles, props = Object.keys(styles);
                0 != props.length && (this._pendingStyles = {}, props.forEach(function(prop) {
                    _this._currentKeyframe[prop] = styles[prop];
                }), Object.keys(this._localTimelineStyles).forEach(function(prop) {
                    _this._currentKeyframe.hasOwnProperty(prop) || (_this._currentKeyframe[prop] = _this._localTimelineStyles[prop]);
                }));
            }, TimelineBuilder.prototype.snapshotCurrentStyles = function() {
                var _this = this;
                Object.keys(this._localTimelineStyles).forEach(function(prop) {
                    var val = _this._localTimelineStyles[prop];
                    _this._pendingStyles[prop] = val, _this._updateStyle(prop, val);
                });
            }, TimelineBuilder.prototype.getFinalKeyframe = function() {
                return this._keyframes.get(this.duration);
            }, Object.defineProperty(TimelineBuilder.prototype, "properties", {
                get: function() {
                    var properties = [];
                    for (var prop in this._currentKeyframe) properties.push(prop);
                    return properties;
                },
                enumerable: !0,
                configurable: !0
            }), TimelineBuilder.prototype.mergeTimelineCollectedStyles = function(timeline) {
                var _this = this;
                Object.keys(timeline._styleSummary).forEach(function(prop) {
                    var details0 = _this._styleSummary[prop], details1 = timeline._styleSummary[prop];
                    (!details0 || details1.time > details0.time) && _this._updateStyle(prop, details1.value);
                });
            }, TimelineBuilder.prototype.buildKeyframes = function() {
                var _this = this;
                this.applyStylesToKeyframe();
                var preStyleProps = new Set(), postStyleProps = new Set(), isEmpty = 1 === this._keyframes.size && 0 === this.duration, finalKeyframes = [];
                this._keyframes.forEach(function(keyframe, time) {
                    var finalKeyframe = copyStyles(keyframe, !0);
                    Object.keys(finalKeyframe).forEach(function(prop) {
                        var value = finalKeyframe[prop];
                        value == \u0275PRE_STYLE ? preStyleProps.add(prop) : value == AUTO_STYLE && postStyleProps.add(prop);
                    }), isEmpty || (finalKeyframe.offset = time / _this.duration), finalKeyframes.push(finalKeyframe);
                });
                var preProps = preStyleProps.size ? iteratorToArray(preStyleProps.values()) : [], postProps = postStyleProps.size ? iteratorToArray(postStyleProps.values()) : [];
                if (isEmpty) {
                    var kf0 = finalKeyframes[0], kf1 = copyObj(kf0);
                    kf0.offset = 0, kf1.offset = 1, finalKeyframes = [ kf0, kf1 ];
                }
                return createTimelineInstruction(this.element, finalKeyframes, preProps, postProps, this.duration, this.startTime, this.easing, !1);
            }, TimelineBuilder;
        }(), browser_SubTimelineBuilder = function(_super) {
            function SubTimelineBuilder(driver, element, keyframes, preStyleProps, postStyleProps, timings, _stretchStartingKeyframe) {
                void 0 === _stretchStartingKeyframe && (_stretchStartingKeyframe = !1);
                var _this = _super.call(this, driver, element, timings.delay) || this;
                return _this.element = element, _this.keyframes = keyframes, _this.preStyleProps = preStyleProps, 
                _this.postStyleProps = postStyleProps, _this._stretchStartingKeyframe = _stretchStartingKeyframe, 
                _this.timings = {
                    duration: timings.duration,
                    delay: timings.delay,
                    easing: timings.easing
                }, _this;
            }
            return __extends(SubTimelineBuilder, _super), SubTimelineBuilder.prototype.containsAnimation = function() {
                return this.keyframes.length > 1;
            }, SubTimelineBuilder.prototype.buildKeyframes = function() {
                var keyframes = this.keyframes, _a = this.timings, delay = _a.delay, duration = _a.duration, easing = _a.easing;
                if (this._stretchStartingKeyframe && delay) {
                    var newKeyframes = [], totalTime = duration + delay, startingGap = delay / totalTime, newFirstKeyframe = copyStyles(keyframes[0], !1);
                    newFirstKeyframe.offset = 0, newKeyframes.push(newFirstKeyframe);
                    var oldFirstKeyframe = copyStyles(keyframes[0], !1);
                    oldFirstKeyframe.offset = roundOffset(startingGap), newKeyframes.push(oldFirstKeyframe);
                    for (var limit = keyframes.length - 1, i = 1; i <= limit; i++) {
                        var kf = copyStyles(keyframes[i], !1);
                        kf.offset = roundOffset((delay + kf.offset * duration) / totalTime), newKeyframes.push(kf);
                    }
                    duration = totalTime, delay = 0, easing = "", keyframes = newKeyframes;
                }
                return createTimelineInstruction(this.element, keyframes, this.preStyleProps, this.postStyleProps, duration, delay, easing, !0);
            }, SubTimelineBuilder;
        }(browser_TimelineBuilder);
        function roundOffset(offset, decimalPoints) {
            void 0 === decimalPoints && (decimalPoints = 3);
            var mult = Math.pow(10, decimalPoints - 1);
            return Math.round(offset * mult) / mult;
        }
        var AnimationStyleNormalizer = function() {
            return function() {};
        }(), browser_WebAnimationsStyleNormalizer = function(_super) {
            function WebAnimationsStyleNormalizer() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return __extends(WebAnimationsStyleNormalizer, _super), WebAnimationsStyleNormalizer.prototype.normalizePropertyName = function(propertyName, errors) {
                return dashCaseToCamelCase(propertyName);
            }, WebAnimationsStyleNormalizer.prototype.normalizeStyleValue = function(userProvidedProperty, normalizedProperty, value, errors) {
                var unit = "", strVal = value.toString().trim();
                if (DIMENSIONAL_PROP_MAP[normalizedProperty] && 0 !== value && "0" !== value) if ("number" == typeof value) unit = "px"; else {
                    var valAndSuffixMatch = value.match(/^[+-]?[\d\.]+([a-z]*)$/);
                    valAndSuffixMatch && 0 == valAndSuffixMatch[1].length && errors.push("Please provide a CSS unit value for " + userProvidedProperty + ":" + value);
                }
                return strVal + unit;
            }, WebAnimationsStyleNormalizer;
        }(AnimationStyleNormalizer), DIMENSIONAL_PROP_MAP = makeBooleanMap("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(","));
        function makeBooleanMap(keys) {
            var map = {};
            return keys.forEach(function(key) {
                return map[key] = !0;
            }), map;
        }
        function createTransitionInstruction(element, triggerName, fromState, toState, isRemovalTransition, fromStyles, toStyles, timelines, queriedElements, preStyleProps, postStyleProps, totalTime, errors) {
            return {
                type: 0,
                element: element,
                triggerName: triggerName,
                isRemovalTransition: isRemovalTransition,
                fromState: fromState,
                fromStyles: fromStyles,
                toState: toState,
                toStyles: toStyles,
                timelines: timelines,
                queriedElements: queriedElements,
                preStyleProps: preStyleProps,
                postStyleProps: postStyleProps,
                totalTime: totalTime,
                errors: errors
            };
        }
        var EMPTY_OBJECT = {}, browser_AnimationTransitionFactory = function() {
            function AnimationTransitionFactory(_triggerName, ast, _stateStyles) {
                this._triggerName = _triggerName, this.ast = ast, this._stateStyles = _stateStyles;
            }
            return AnimationTransitionFactory.prototype.match = function(currentState, nextState, element, params) {
                return function(matchFns, currentState, nextState, element, params) {
                    return matchFns.some(function(fn) {
                        return fn(currentState, nextState, element, params);
                    });
                }(this.ast.matchers, currentState, nextState, element, params);
            }, AnimationTransitionFactory.prototype.buildStyles = function(stateName, params, errors) {
                var backupStateStyler = this._stateStyles["*"], stateStyler = this._stateStyles[stateName], backupStyles = backupStateStyler ? backupStateStyler.buildStyles(params, errors) : {};
                return stateStyler ? stateStyler.buildStyles(params, errors) : backupStyles;
            }, AnimationTransitionFactory.prototype.build = function(driver, element, currentState, nextState, enterClassName, leaveClassName, currentOptions, nextOptions, subInstructions, skipAstBuild) {
                var errors = [], transitionAnimationParams = this.ast.options && this.ast.options.params || EMPTY_OBJECT, currentStateStyles = this.buildStyles(currentState, currentOptions && currentOptions.params || EMPTY_OBJECT, errors), nextAnimationParams = nextOptions && nextOptions.params || EMPTY_OBJECT, nextStateStyles = this.buildStyles(nextState, nextAnimationParams, errors), queriedElements = new Set(), preStyleMap = new Map(), postStyleMap = new Map(), isRemoval = "void" === nextState, animationOptions = {
                    params: __assign({}, transitionAnimationParams, nextAnimationParams)
                }, timelines = skipAstBuild ? [] : buildAnimationTimelines(driver, element, this.ast.animation, enterClassName, leaveClassName, currentStateStyles, nextStateStyles, animationOptions, subInstructions, errors), totalTime = 0;
                if (timelines.forEach(function(tl) {
                    totalTime = Math.max(tl.duration + tl.delay, totalTime);
                }), errors.length) return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, [], [], preStyleMap, postStyleMap, totalTime, errors);
                timelines.forEach(function(tl) {
                    var elm = tl.element, preProps = getOrSetAsInMap(preStyleMap, elm, {});
                    tl.preStyleProps.forEach(function(prop) {
                        return preProps[prop] = !0;
                    });
                    var postProps = getOrSetAsInMap(postStyleMap, elm, {});
                    tl.postStyleProps.forEach(function(prop) {
                        return postProps[prop] = !0;
                    }), elm !== element && queriedElements.add(elm);
                });
                var queriedElementsList = iteratorToArray(queriedElements.values());
                return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, timelines, queriedElementsList, preStyleMap, postStyleMap, totalTime);
            }, AnimationTransitionFactory;
        }(), AnimationStateStyles = function() {
            function AnimationStateStyles(styles, defaultParams) {
                this.styles = styles, this.defaultParams = defaultParams;
            }
            return AnimationStateStyles.prototype.buildStyles = function(params, errors) {
                var finalStyles = {}, combinedParams = copyObj(this.defaultParams);
                return Object.keys(params).forEach(function(key) {
                    var value = params[key];
                    null != value && (combinedParams[key] = value);
                }), this.styles.styles.forEach(function(value) {
                    if ("string" != typeof value) {
                        var styleObj_1 = value;
                        Object.keys(styleObj_1).forEach(function(prop) {
                            var val = styleObj_1[prop];
                            val.length > 1 && (val = interpolateParams(val, combinedParams, errors)), finalStyles[prop] = val;
                        });
                    }
                }), finalStyles;
            }, AnimationStateStyles;
        }(), AnimationTrigger = function() {
            function AnimationTrigger(name, ast) {
                var _this = this;
                this.name = name, this.ast = ast, this.transitionFactories = [], this.states = {}, 
                ast.states.forEach(function(ast) {
                    _this.states[ast.name] = new AnimationStateStyles(ast.style, ast.options && ast.options.params || {});
                }), balanceProperties(this.states, "true", "1"), balanceProperties(this.states, "false", "0"), 
                ast.transitions.forEach(function(ast) {
                    _this.transitionFactories.push(new browser_AnimationTransitionFactory(name, ast, _this.states));
                }), this.fallbackTransition = new browser_AnimationTransitionFactory(name, {
                    type: 1,
                    animation: {
                        type: 2,
                        steps: [],
                        options: null
                    },
                    matchers: [ function(fromState, toState) {
                        return !0;
                    } ],
                    options: null,
                    queryCount: 0,
                    depCount: 0
                }, this.states);
            }
            return Object.defineProperty(AnimationTrigger.prototype, "containsQueries", {
                get: function() {
                    return this.ast.queryCount > 0;
                },
                enumerable: !0,
                configurable: !0
            }), AnimationTrigger.prototype.matchTransition = function(currentState, nextState, element, params) {
                return this.transitionFactories.find(function(f) {
                    return f.match(currentState, nextState, element, params);
                }) || null;
            }, AnimationTrigger.prototype.matchStyles = function(currentState, params, errors) {
                return this.fallbackTransition.buildStyles(currentState, params, errors);
            }, AnimationTrigger;
        }();
        function balanceProperties(obj, key1, key2) {
            obj.hasOwnProperty(key1) ? obj.hasOwnProperty(key2) || (obj[key2] = obj[key1]) : obj.hasOwnProperty(key2) && (obj[key1] = obj[key2]);
        }
        var EMPTY_INSTRUCTION_MAP = new browser_ElementInstructionMap(), browser_TimelineAnimationEngine = function() {
            function TimelineAnimationEngine(bodyNode, _driver, _normalizer) {
                this.bodyNode = bodyNode, this._driver = _driver, this._normalizer = _normalizer, 
                this._animations = {}, this._playersById = {}, this.players = [];
            }
            return TimelineAnimationEngine.prototype.register = function(id, metadata) {
                var errors = [], ast = buildAnimationAst(this._driver, metadata, errors);
                if (errors.length) throw new Error("Unable to build the animation due to the following errors: " + errors.join("\n"));
                this._animations[id] = ast;
            }, TimelineAnimationEngine.prototype._buildPlayer = function(i, preStyles, postStyles) {
                var element = i.element, keyframes = normalizeKeyframes(0, this._normalizer, 0, i.keyframes, preStyles, postStyles);
                return this._driver.animate(element, keyframes, i.duration, i.delay, i.easing, [], !0);
            }, TimelineAnimationEngine.prototype.create = function(id, element, options) {
                var _this = this;
                void 0 === options && (options = {});
                var instructions, errors = [], ast = this._animations[id], autoStylesMap = new Map();
                if (ast ? (instructions = buildAnimationTimelines(this._driver, element, ast, "ng-enter", "ng-leave", {}, {}, options, EMPTY_INSTRUCTION_MAP, errors)).forEach(function(inst) {
                    var styles = getOrSetAsInMap(autoStylesMap, inst.element, {});
                    inst.postStyleProps.forEach(function(prop) {
                        return styles[prop] = null;
                    });
                }) : (errors.push("The requested animation doesn't exist or has already been destroyed"), 
                instructions = []), errors.length) throw new Error("Unable to create the animation due to the following errors: " + errors.join("\n"));
                autoStylesMap.forEach(function(styles, element) {
                    Object.keys(styles).forEach(function(prop) {
                        styles[prop] = _this._driver.computeStyle(element, prop, AUTO_STYLE);
                    });
                });
                var player = optimizeGroupPlayer(instructions.map(function(i) {
                    var styles = autoStylesMap.get(i.element);
                    return _this._buildPlayer(i, {}, styles);
                }));
                return this._playersById[id] = player, player.onDestroy(function() {
                    return _this.destroy(id);
                }), this.players.push(player), player;
            }, TimelineAnimationEngine.prototype.destroy = function(id) {
                var player = this._getPlayer(id);
                player.destroy(), delete this._playersById[id];
                var index = this.players.indexOf(player);
                index >= 0 && this.players.splice(index, 1);
            }, TimelineAnimationEngine.prototype._getPlayer = function(id) {
                var player = this._playersById[id];
                if (!player) throw new Error("Unable to find the timeline player referenced by " + id);
                return player;
            }, TimelineAnimationEngine.prototype.listen = function(id, element, eventName, callback) {
                var baseEvent = makeAnimationEvent(element, "", "", "");
                return listenOnPlayer(this._getPlayer(id), eventName, baseEvent, callback), function() {};
            }, TimelineAnimationEngine.prototype.command = function(id, element, command, args) {
                if ("register" != command) if ("create" != command) {
                    var player = this._getPlayer(id);
                    switch (command) {
                      case "play":
                        player.play();
                        break;

                      case "pause":
                        player.pause();
                        break;

                      case "reset":
                        player.reset();
                        break;

                      case "restart":
                        player.restart();
                        break;

                      case "finish":
                        player.finish();
                        break;

                      case "init":
                        player.init();
                        break;

                      case "setPosition":
                        player.setPosition(parseFloat(args[0]));
                        break;

                      case "destroy":
                        this.destroy(id);
                    }
                } else this.create(id, element, args[0] || {}); else this.register(id, args[0]);
            }, TimelineAnimationEngine;
        }(), EMPTY_PLAYER_ARRAY = [], NULL_REMOVAL_STATE = {
            namespaceId: "",
            setForRemoval: !1,
            setForMove: !1,
            hasAnimation: !1,
            removedBeforeQueried: !1
        }, NULL_REMOVED_QUERIED_STATE = {
            namespaceId: "",
            setForMove: !1,
            setForRemoval: !1,
            hasAnimation: !1,
            removedBeforeQueried: !0
        }, REMOVAL_FLAG = "__ng_removed", StateValue = function() {
            function StateValue(input, namespaceId) {
                void 0 === namespaceId && (namespaceId = ""), this.namespaceId = namespaceId;
                var isObj = input && input.hasOwnProperty("value");
                if (this.value = function(value) {
                    return null != value ? value : null;
                }(isObj ? input.value : input), isObj) {
                    var options = copyObj(input);
                    delete options.value, this.options = options;
                } else this.options = {};
                this.options.params || (this.options.params = {});
            }
            return Object.defineProperty(StateValue.prototype, "params", {
                get: function() {
                    return this.options.params;
                },
                enumerable: !0,
                configurable: !0
            }), StateValue.prototype.absorbOptions = function(options) {
                var newParams = options.params;
                if (newParams) {
                    var oldParams_1 = this.options.params;
                    Object.keys(newParams).forEach(function(prop) {
                        null == oldParams_1[prop] && (oldParams_1[prop] = newParams[prop]);
                    });
                }
            }, StateValue;
        }(), DEFAULT_STATE_VALUE = new StateValue("void"), AnimationTransitionNamespace = function() {
            function AnimationTransitionNamespace(id, hostElement, _engine) {
                this.id = id, this.hostElement = hostElement, this._engine = _engine, this.players = [], 
                this._triggers = {}, this._queue = [], this._elementListeners = new Map(), this._hostClassName = "ng-tns-" + id, 
                addClass(hostElement, this._hostClassName);
            }
            return AnimationTransitionNamespace.prototype.listen = function(element, name, phase, callback) {
                var eventName, _this = this;
                if (!this._triggers.hasOwnProperty(name)) throw new Error('Unable to listen on the animation trigger event "' + phase + '" because the animation trigger "' + name + "\" doesn't exist!");
                if (null == phase || 0 == phase.length) throw new Error('Unable to listen on the animation trigger "' + name + '" because the provided event is undefined!');
                if ("start" != (eventName = phase) && "done" != eventName) throw new Error('The provided animation trigger event "' + phase + '" for the animation trigger "' + name + '" is not supported!');
                var listeners = getOrSetAsInMap(this._elementListeners, element, []), data = {
                    name: name,
                    phase: phase,
                    callback: callback
                };
                listeners.push(data);
                var triggersWithStates = getOrSetAsInMap(this._engine.statesByElement, element, {});
                return triggersWithStates.hasOwnProperty(name) || (addClass(element, "ng-trigger"), 
                addClass(element, "ng-trigger-" + name), triggersWithStates[name] = DEFAULT_STATE_VALUE), 
                function() {
                    _this._engine.afterFlush(function() {
                        var index = listeners.indexOf(data);
                        index >= 0 && listeners.splice(index, 1), _this._triggers[name] || delete triggersWithStates[name];
                    });
                };
            }, AnimationTransitionNamespace.prototype.register = function(name, ast) {
                return !this._triggers[name] && (this._triggers[name] = ast, !0);
            }, AnimationTransitionNamespace.prototype._getTrigger = function(name) {
                var trigger = this._triggers[name];
                if (!trigger) throw new Error('The provided animation trigger "' + name + '" has not been registered!');
                return trigger;
            }, AnimationTransitionNamespace.prototype.trigger = function(element, triggerName, value, defaultToFallback) {
                var _this = this;
                void 0 === defaultToFallback && (defaultToFallback = !0);
                var trigger = this._getTrigger(triggerName), player = new browser_TransitionAnimationPlayer(this.id, triggerName, element), triggersWithStates = this._engine.statesByElement.get(element);
                triggersWithStates || (addClass(element, "ng-trigger"), addClass(element, "ng-trigger-" + triggerName), 
                this._engine.statesByElement.set(element, triggersWithStates = {}));
                var fromState = triggersWithStates[triggerName], toState = new StateValue(value, this.id);
                if (!(value && value.hasOwnProperty("value")) && fromState && toState.absorbOptions(fromState.options), 
                triggersWithStates[triggerName] = toState, fromState || (fromState = DEFAULT_STATE_VALUE), 
                "void" === toState.value || fromState.value !== toState.value) {
                    var playersOnElement = getOrSetAsInMap(this._engine.playersByElement, element, []);
                    playersOnElement.forEach(function(player) {
                        player.namespaceId == _this.id && player.triggerName == triggerName && player.queued && player.destroy();
                    });
                    var transition = trigger.matchTransition(fromState.value, toState.value, element, toState.params), isFallbackTransition = !1;
                    if (!transition) {
                        if (!defaultToFallback) return;
                        transition = trigger.fallbackTransition, isFallbackTransition = !0;
                    }
                    return this._engine.totalQueuedPlayers++, this._queue.push({
                        element: element,
                        triggerName: triggerName,
                        transition: transition,
                        fromState: fromState,
                        toState: toState,
                        player: player,
                        isFallbackTransition: isFallbackTransition
                    }), isFallbackTransition || (addClass(element, "ng-animate-queued"), player.onStart(function() {
                        removeClass(element, "ng-animate-queued");
                    })), player.onDone(function() {
                        var index = _this.players.indexOf(player);
                        index >= 0 && _this.players.splice(index, 1);
                        var players = _this._engine.playersByElement.get(element);
                        if (players) {
                            var index_1 = players.indexOf(player);
                            index_1 >= 0 && players.splice(index_1, 1);
                        }
                    }), this.players.push(player), playersOnElement.push(player), player;
                }
                if (!function(a, b) {
                    var k1 = Object.keys(a), k2 = Object.keys(b);
                    if (k1.length != k2.length) return !1;
                    for (var i = 0; i < k1.length; i++) {
                        var prop = k1[i];
                        if (!b.hasOwnProperty(prop) || a[prop] !== b[prop]) return !1;
                    }
                    return !0;
                }(fromState.params, toState.params)) {
                    var errors = [], fromStyles_1 = trigger.matchStyles(fromState.value, fromState.params, errors), toStyles_1 = trigger.matchStyles(toState.value, toState.params, errors);
                    errors.length ? this._engine.reportError(errors) : this._engine.afterFlush(function() {
                        eraseStyles(element, fromStyles_1), setStyles(element, toStyles_1);
                    });
                }
            }, AnimationTransitionNamespace.prototype.deregister = function(name) {
                var _this = this;
                delete this._triggers[name], this._engine.statesByElement.forEach(function(stateMap, element) {
                    delete stateMap[name];
                }), this._elementListeners.forEach(function(listeners, element) {
                    _this._elementListeners.set(element, listeners.filter(function(entry) {
                        return entry.name != name;
                    }));
                });
            }, AnimationTransitionNamespace.prototype.clearElementCache = function(element) {
                this._engine.statesByElement.delete(element), this._elementListeners.delete(element);
                var elementPlayers = this._engine.playersByElement.get(element);
                elementPlayers && (elementPlayers.forEach(function(player) {
                    return player.destroy();
                }), this._engine.playersByElement.delete(element));
            }, AnimationTransitionNamespace.prototype._signalRemovalForInnerTriggers = function(rootElement, context, animate) {
                var _this = this;
                void 0 === animate && (animate = !1), this._engine.driver.query(rootElement, ".ng-trigger", !0).forEach(function(elm) {
                    if (!elm[REMOVAL_FLAG]) {
                        var namespaces = _this._engine.fetchNamespacesByElement(elm);
                        namespaces.size ? namespaces.forEach(function(ns) {
                            return ns.triggerLeaveAnimation(elm, context, !1, !0);
                        }) : _this.clearElementCache(elm);
                    }
                });
            }, AnimationTransitionNamespace.prototype.triggerLeaveAnimation = function(element, context, destroyAfterComplete, defaultToFallback) {
                var _this = this, triggerStates = this._engine.statesByElement.get(element);
                if (triggerStates) {
                    var players_1 = [];
                    if (Object.keys(triggerStates).forEach(function(triggerName) {
                        if (_this._triggers[triggerName]) {
                            var player = _this.trigger(element, triggerName, "void", defaultToFallback);
                            player && players_1.push(player);
                        }
                    }), players_1.length) return this._engine.markElementAsRemoved(this.id, element, !0, context), 
                    destroyAfterComplete && optimizeGroupPlayer(players_1).onDone(function() {
                        return _this._engine.processLeaveNode(element);
                    }), !0;
                }
                return !1;
            }, AnimationTransitionNamespace.prototype.prepareLeaveAnimationListeners = function(element) {
                var _this = this, listeners = this._elementListeners.get(element);
                if (listeners) {
                    var visitedTriggers_1 = new Set();
                    listeners.forEach(function(listener) {
                        var triggerName = listener.name;
                        if (!visitedTriggers_1.has(triggerName)) {
                            visitedTriggers_1.add(triggerName);
                            var transition = _this._triggers[triggerName].fallbackTransition, fromState = _this._engine.statesByElement.get(element)[triggerName] || DEFAULT_STATE_VALUE, toState = new StateValue("void"), player = new browser_TransitionAnimationPlayer(_this.id, triggerName, element);
                            _this._engine.totalQueuedPlayers++, _this._queue.push({
                                element: element,
                                triggerName: triggerName,
                                transition: transition,
                                fromState: fromState,
                                toState: toState,
                                player: player,
                                isFallbackTransition: !0
                            });
                        }
                    });
                }
            }, AnimationTransitionNamespace.prototype.removeNode = function(element, context) {
                var _this = this, engine = this._engine;
                if (element.childElementCount && this._signalRemovalForInnerTriggers(element, context, !0), 
                !this.triggerLeaveAnimation(element, context, !0)) {
                    var containsPotentialParentTransition = !1;
                    if (engine.totalAnimations) {
                        var currentPlayers = engine.players.length ? engine.playersByQueriedElement.get(element) : [];
                        if (currentPlayers && currentPlayers.length) containsPotentialParentTransition = !0; else for (var parent_1 = element; parent_1 = parent_1.parentNode; ) if (engine.statesByElement.get(parent_1)) {
                            containsPotentialParentTransition = !0;
                            break;
                        }
                    }
                    this.prepareLeaveAnimationListeners(element), containsPotentialParentTransition ? engine.markElementAsRemoved(this.id, element, !1, context) : (engine.afterFlush(function() {
                        return _this.clearElementCache(element);
                    }), engine.destroyInnerAnimations(element), engine._onRemovalComplete(element, context));
                }
            }, AnimationTransitionNamespace.prototype.insertNode = function(element, parent) {
                addClass(element, this._hostClassName);
            }, AnimationTransitionNamespace.prototype.drainQueuedTransitions = function(microtaskId) {
                var _this = this, instructions = [];
                return this._queue.forEach(function(entry) {
                    var player = entry.player;
                    if (!player.destroyed) {
                        var element = entry.element, listeners = _this._elementListeners.get(element);
                        listeners && listeners.forEach(function(listener) {
                            if (listener.name == entry.triggerName) {
                                var baseEvent = makeAnimationEvent(element, entry.triggerName, entry.fromState.value, entry.toState.value);
                                baseEvent._data = microtaskId, listenOnPlayer(entry.player, listener.phase, baseEvent, listener.callback);
                            }
                        }), player.markedForDestroy ? _this._engine.afterFlush(function() {
                            player.destroy();
                        }) : instructions.push(entry);
                    }
                }), this._queue = [], instructions.sort(function(a, b) {
                    var d0 = a.transition.ast.depCount, d1 = b.transition.ast.depCount;
                    return 0 == d0 || 0 == d1 ? d0 - d1 : _this._engine.driver.containsElement(a.element, b.element) ? 1 : -1;
                });
            }, AnimationTransitionNamespace.prototype.destroy = function(context) {
                this.players.forEach(function(p) {
                    return p.destroy();
                }), this._signalRemovalForInnerTriggers(this.hostElement, context);
            }, AnimationTransitionNamespace.prototype.elementContainsData = function(element) {
                var containsData = !1;
                return this._elementListeners.has(element) && (containsData = !0), !!this._queue.find(function(entry) {
                    return entry.element === element;
                }) || containsData;
            }, AnimationTransitionNamespace;
        }(), browser_TransitionAnimationEngine = function() {
            function TransitionAnimationEngine(bodyNode, driver, _normalizer) {
                this.bodyNode = bodyNode, this.driver = driver, this._normalizer = _normalizer, 
                this.players = [], this.newHostElements = new Map(), this.playersByElement = new Map(), 
                this.playersByQueriedElement = new Map(), this.statesByElement = new Map(), this.disabledNodes = new Set(), 
                this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, 
                this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map(), 
                this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = function(element, context) {};
            }
            return TransitionAnimationEngine.prototype._onRemovalComplete = function(element, context) {
                this.onRemovalComplete(element, context);
            }, Object.defineProperty(TransitionAnimationEngine.prototype, "queuedPlayers", {
                get: function() {
                    var players = [];
                    return this._namespaceList.forEach(function(ns) {
                        ns.players.forEach(function(player) {
                            player.queued && players.push(player);
                        });
                    }), players;
                },
                enumerable: !0,
                configurable: !0
            }), TransitionAnimationEngine.prototype.createNamespace = function(namespaceId, hostElement) {
                var ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);
                return hostElement.parentNode ? this._balanceNamespaceList(ns, hostElement) : (this.newHostElements.set(hostElement, ns), 
                this.collectEnterElement(hostElement)), this._namespaceLookup[namespaceId] = ns;
            }, TransitionAnimationEngine.prototype._balanceNamespaceList = function(ns, hostElement) {
                var limit = this._namespaceList.length - 1;
                if (limit >= 0) {
                    for (var found = !1, i = limit; i >= 0; i--) if (this.driver.containsElement(this._namespaceList[i].hostElement, hostElement)) {
                        this._namespaceList.splice(i + 1, 0, ns), found = !0;
                        break;
                    }
                    found || this._namespaceList.splice(0, 0, ns);
                } else this._namespaceList.push(ns);
                return this.namespacesByHostElement.set(hostElement, ns), ns;
            }, TransitionAnimationEngine.prototype.register = function(namespaceId, hostElement) {
                var ns = this._namespaceLookup[namespaceId];
                return ns || (ns = this.createNamespace(namespaceId, hostElement)), ns;
            }, TransitionAnimationEngine.prototype.registerTrigger = function(namespaceId, name, trigger) {
                var ns = this._namespaceLookup[namespaceId];
                ns && ns.register(name, trigger) && this.totalAnimations++;
            }, TransitionAnimationEngine.prototype.destroy = function(namespaceId, context) {
                var _this = this;
                if (namespaceId) {
                    var ns = this._fetchNamespace(namespaceId);
                    this.afterFlush(function() {
                        _this.namespacesByHostElement.delete(ns.hostElement), delete _this._namespaceLookup[namespaceId];
                        var index = _this._namespaceList.indexOf(ns);
                        index >= 0 && _this._namespaceList.splice(index, 1);
                    }), this.afterFlushAnimationsDone(function() {
                        return ns.destroy(context);
                    });
                }
            }, TransitionAnimationEngine.prototype._fetchNamespace = function(id) {
                return this._namespaceLookup[id];
            }, TransitionAnimationEngine.prototype.fetchNamespacesByElement = function(element) {
                var namespaces = new Set(), elementStates = this.statesByElement.get(element);
                if (elementStates) for (var keys = Object.keys(elementStates), i = 0; i < keys.length; i++) {
                    var nsId = elementStates[keys[i]].namespaceId;
                    if (nsId) {
                        var ns = this._fetchNamespace(nsId);
                        ns && namespaces.add(ns);
                    }
                }
                return namespaces;
            }, TransitionAnimationEngine.prototype.trigger = function(namespaceId, element, name, value) {
                if (isElementNode(element)) {
                    var ns = this._fetchNamespace(namespaceId);
                    if (ns) return ns.trigger(element, name, value), !0;
                }
                return !1;
            }, TransitionAnimationEngine.prototype.insertNode = function(namespaceId, element, parent, insertBefore) {
                if (isElementNode(element)) {
                    var details = element[REMOVAL_FLAG];
                    if (details && details.setForRemoval) {
                        details.setForRemoval = !1, details.setForMove = !0;
                        var index = this.collectedLeaveElements.indexOf(element);
                        index >= 0 && this.collectedLeaveElements.splice(index, 1);
                    }
                    if (namespaceId) {
                        var ns = this._fetchNamespace(namespaceId);
                        ns && ns.insertNode(element, parent);
                    }
                    insertBefore && this.collectEnterElement(element);
                }
            }, TransitionAnimationEngine.prototype.collectEnterElement = function(element) {
                this.collectedEnterElements.push(element);
            }, TransitionAnimationEngine.prototype.markElementAsDisabled = function(element, value) {
                value ? this.disabledNodes.has(element) || (this.disabledNodes.add(element), addClass(element, "ng-animate-disabled")) : this.disabledNodes.has(element) && (this.disabledNodes.delete(element), 
                removeClass(element, "ng-animate-disabled"));
            }, TransitionAnimationEngine.prototype.removeNode = function(namespaceId, element, isHostElement, context) {
                if (isElementNode(element)) {
                    var ns = namespaceId ? this._fetchNamespace(namespaceId) : null;
                    if (ns ? ns.removeNode(element, context) : this.markElementAsRemoved(namespaceId, element, !1, context), 
                    isHostElement) {
                        var hostNS = this.namespacesByHostElement.get(element);
                        hostNS && hostNS.id !== namespaceId && hostNS.removeNode(element, context);
                    }
                } else this._onRemovalComplete(element, context);
            }, TransitionAnimationEngine.prototype.markElementAsRemoved = function(namespaceId, element, hasAnimation, context) {
                this.collectedLeaveElements.push(element), element[REMOVAL_FLAG] = {
                    namespaceId: namespaceId,
                    setForRemoval: context,
                    hasAnimation: hasAnimation,
                    removedBeforeQueried: !1
                };
            }, TransitionAnimationEngine.prototype.listen = function(namespaceId, element, name, phase, callback) {
                return isElementNode(element) ? this._fetchNamespace(namespaceId).listen(element, name, phase, callback) : function() {};
            }, TransitionAnimationEngine.prototype._buildInstruction = function(entry, subTimelines, enterClassName, leaveClassName, skipBuildAst) {
                return entry.transition.build(this.driver, entry.element, entry.fromState.value, entry.toState.value, enterClassName, leaveClassName, entry.fromState.options, entry.toState.options, subTimelines, skipBuildAst);
            }, TransitionAnimationEngine.prototype.destroyInnerAnimations = function(containerElement) {
                var _this = this, elements = this.driver.query(containerElement, ".ng-trigger", !0);
                elements.forEach(function(element) {
                    return _this.destroyActiveAnimationsForElement(element);
                }), 0 != this.playersByQueriedElement.size && (elements = this.driver.query(containerElement, ".ng-animating", !0)).forEach(function(element) {
                    return _this.finishActiveQueriedAnimationOnElement(element);
                });
            }, TransitionAnimationEngine.prototype.destroyActiveAnimationsForElement = function(element) {
                var players = this.playersByElement.get(element);
                players && players.forEach(function(player) {
                    player.queued ? player.markedForDestroy = !0 : player.destroy();
                });
            }, TransitionAnimationEngine.prototype.finishActiveQueriedAnimationOnElement = function(element) {
                var players = this.playersByQueriedElement.get(element);
                players && players.forEach(function(player) {
                    return player.finish();
                });
            }, TransitionAnimationEngine.prototype.whenRenderingDone = function() {
                var _this = this;
                return new Promise(function(resolve) {
                    if (_this.players.length) return optimizeGroupPlayer(_this.players).onDone(function() {
                        return resolve();
                    });
                    resolve();
                });
            }, TransitionAnimationEngine.prototype.processLeaveNode = function(element) {
                var _this = this, details = element[REMOVAL_FLAG];
                if (details && details.setForRemoval) {
                    if (element[REMOVAL_FLAG] = NULL_REMOVAL_STATE, details.namespaceId) {
                        this.destroyInnerAnimations(element);
                        var ns = this._fetchNamespace(details.namespaceId);
                        ns && ns.clearElementCache(element);
                    }
                    this._onRemovalComplete(element, details.setForRemoval);
                }
                this.driver.matchesElement(element, ".ng-animate-disabled") && this.markElementAsDisabled(element, !1), 
                this.driver.query(element, ".ng-animate-disabled", !0).forEach(function(node) {
                    _this.markElementAsDisabled(node, !1);
                });
            }, TransitionAnimationEngine.prototype.flush = function(microtaskId) {
                var _this = this;
                void 0 === microtaskId && (microtaskId = -1);
                var players = [];
                if (this.newHostElements.size && (this.newHostElements.forEach(function(ns, element) {
                    return _this._balanceNamespaceList(ns, element);
                }), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (var i = 0; i < this.collectedEnterElements.length; i++) addClass(this.collectedEnterElements[i], "ng-star-inserted");
                if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {
                    var cleanupFns = [];
                    try {
                        players = this._flushAnimations(cleanupFns, microtaskId);
                    } finally {
                        for (i = 0; i < cleanupFns.length; i++) cleanupFns[i]();
                    }
                } else for (i = 0; i < this.collectedLeaveElements.length; i++) this.processLeaveNode(this.collectedLeaveElements[i]);
                if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, 
                this._flushFns.forEach(function(fn) {
                    return fn();
                }), this._flushFns = [], this._whenQuietFns.length) {
                    var quietFns_1 = this._whenQuietFns;
                    this._whenQuietFns = [], players.length ? optimizeGroupPlayer(players).onDone(function() {
                        quietFns_1.forEach(function(fn) {
                            return fn();
                        });
                    }) : quietFns_1.forEach(function(fn) {
                        return fn();
                    });
                }
            }, TransitionAnimationEngine.prototype.reportError = function(errors) {
                throw new Error("Unable to process animations due to the following failed trigger transitions\n " + errors.join("\n"));
            }, TransitionAnimationEngine.prototype._flushAnimations = function(cleanupFns, microtaskId) {
                var _this = this, subTimelines = new browser_ElementInstructionMap(), skippedPlayers = [], skippedPlayersMap = new Map(), queuedInstructions = [], queriedElements = new Map(), allPreStyleElements = new Map(), allPostStyleElements = new Map(), disabledElementsSet = new Set();
                this.disabledNodes.forEach(function(node) {
                    disabledElementsSet.add(node);
                    for (var nodesThatAreDisabled = _this.driver.query(node, ".ng-animate-queued", !0), i_1 = 0; i_1 < nodesThatAreDisabled.length; i_1++) disabledElementsSet.add(nodesThatAreDisabled[i_1]);
                });
                var bodyNode = this.bodyNode, allTriggerElements = Array.from(this.statesByElement.keys()), enterNodeMap = buildRootMap(allTriggerElements, this.collectedEnterElements), enterNodeMapIds = new Map(), i = 0;
                enterNodeMap.forEach(function(nodes, root) {
                    var className = "ng-enter" + i++;
                    enterNodeMapIds.set(root, className), nodes.forEach(function(node) {
                        return addClass(node, className);
                    });
                });
                for (var allLeaveNodes = [], mergedLeaveNodes = new Set(), leaveNodesWithoutAnimations = new Set(), i_2 = 0; i_2 < this.collectedLeaveElements.length; i_2++) (details = (element = this.collectedLeaveElements[i_2])[REMOVAL_FLAG]) && details.setForRemoval && (allLeaveNodes.push(element), 
                mergedLeaveNodes.add(element), details.hasAnimation ? this.driver.query(element, ".ng-star-inserted", !0).forEach(function(elm) {
                    return mergedLeaveNodes.add(elm);
                }) : leaveNodesWithoutAnimations.add(element));
                var leaveNodeMapIds = new Map(), leaveNodeMap = buildRootMap(allTriggerElements, Array.from(mergedLeaveNodes));
                leaveNodeMap.forEach(function(nodes, root) {
                    var className = "ng-leave" + i++;
                    leaveNodeMapIds.set(root, className), nodes.forEach(function(node) {
                        return addClass(node, className);
                    });
                }), cleanupFns.push(function() {
                    enterNodeMap.forEach(function(nodes, root) {
                        var className = enterNodeMapIds.get(root);
                        nodes.forEach(function(node) {
                            return removeClass(node, className);
                        });
                    }), leaveNodeMap.forEach(function(nodes, root) {
                        var className = leaveNodeMapIds.get(root);
                        nodes.forEach(function(node) {
                            return removeClass(node, className);
                        });
                    }), allLeaveNodes.forEach(function(element) {
                        _this.processLeaveNode(element);
                    });
                });
                for (var allPlayers = [], erroneousTransitions = [], i_3 = this._namespaceList.length - 1; i_3 >= 0; i_3--) this._namespaceList[i_3].drainQueuedTransitions(microtaskId).forEach(function(entry) {
                    var player = entry.player, element = entry.element;
                    if (allPlayers.push(player), _this.collectedEnterElements.length) {
                        var details = element[REMOVAL_FLAG];
                        if (details && details.setForMove) return void player.destroy();
                    }
                    var nodeIsOrphaned = !bodyNode || !_this.driver.containsElement(bodyNode, element), leaveClassName = leaveNodeMapIds.get(element), enterClassName = enterNodeMapIds.get(element), instruction = _this._buildInstruction(entry, subTimelines, enterClassName, leaveClassName, nodeIsOrphaned);
                    if (instruction.errors && instruction.errors.length) erroneousTransitions.push(instruction); else {
                        if (nodeIsOrphaned) return player.onStart(function() {
                            return eraseStyles(element, instruction.fromStyles);
                        }), player.onDestroy(function() {
                            return setStyles(element, instruction.toStyles);
                        }), void skippedPlayers.push(player);
                        if (entry.isFallbackTransition) return player.onStart(function() {
                            return eraseStyles(element, instruction.fromStyles);
                        }), player.onDestroy(function() {
                            return setStyles(element, instruction.toStyles);
                        }), void skippedPlayers.push(player);
                        instruction.timelines.forEach(function(tl) {
                            return tl.stretchStartingKeyframe = !0;
                        }), subTimelines.append(element, instruction.timelines), queuedInstructions.push({
                            instruction: instruction,
                            player: player,
                            element: element
                        }), instruction.queriedElements.forEach(function(element) {
                            return getOrSetAsInMap(queriedElements, element, []).push(player);
                        }), instruction.preStyleProps.forEach(function(stringMap, element) {
                            var props = Object.keys(stringMap);
                            if (props.length) {
                                var setVal_1 = allPreStyleElements.get(element);
                                setVal_1 || allPreStyleElements.set(element, setVal_1 = new Set()), props.forEach(function(prop) {
                                    return setVal_1.add(prop);
                                });
                            }
                        }), instruction.postStyleProps.forEach(function(stringMap, element) {
                            var props = Object.keys(stringMap), setVal = allPostStyleElements.get(element);
                            setVal || allPostStyleElements.set(element, setVal = new Set()), props.forEach(function(prop) {
                                return setVal.add(prop);
                            });
                        });
                    }
                });
                if (erroneousTransitions.length) {
                    var errors_1 = [];
                    erroneousTransitions.forEach(function(instruction) {
                        errors_1.push("@" + instruction.triggerName + " has failed due to:\n"), instruction.errors.forEach(function(error) {
                            return errors_1.push("- " + error + "\n");
                        });
                    }), allPlayers.forEach(function(player) {
                        return player.destroy();
                    }), this.reportError(errors_1);
                }
                var allPreviousPlayersMap = new Map(), animationElementMap = new Map();
                queuedInstructions.forEach(function(entry) {
                    var element = entry.element;
                    subTimelines.has(element) && (animationElementMap.set(element, element), _this._beforeAnimationBuild(entry.player.namespaceId, entry.instruction, allPreviousPlayersMap));
                }), skippedPlayers.forEach(function(player) {
                    var element = player.element;
                    _this._getPreviousPlayers(element, !1, player.namespaceId, player.triggerName, null).forEach(function(prevPlayer) {
                        getOrSetAsInMap(allPreviousPlayersMap, element, []).push(prevPlayer), prevPlayer.destroy();
                    });
                });
                var replaceNodes = allLeaveNodes.filter(function(node) {
                    return replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements);
                }), postStylesMap = new Map();
                cloakAndComputeStyles(postStylesMap, this.driver, leaveNodesWithoutAnimations, allPostStyleElements, AUTO_STYLE).forEach(function(node) {
                    replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements) && replaceNodes.push(node);
                });
                var preStylesMap = new Map();
                enterNodeMap.forEach(function(nodes, root) {
                    cloakAndComputeStyles(preStylesMap, _this.driver, new Set(nodes), allPreStyleElements, \u0275PRE_STYLE);
                }), replaceNodes.forEach(function(node) {
                    var post = postStylesMap.get(node), pre = preStylesMap.get(node);
                    postStylesMap.set(node, __assign({}, post, pre));
                });
                var rootPlayers = [], subPlayers = [], NO_PARENT_ANIMATION_ELEMENT_DETECTED = {};
                queuedInstructions.forEach(function(entry) {
                    var element = entry.element, player = entry.player, instruction = entry.instruction;
                    if (subTimelines.has(element)) {
                        if (disabledElementsSet.has(element)) return player.onDestroy(function() {
                            return setStyles(element, instruction.toStyles);
                        }), player.disabled = !0, player.overrideTotalTime(instruction.totalTime), void skippedPlayers.push(player);
                        var parentWithAnimation_1 = NO_PARENT_ANIMATION_ELEMENT_DETECTED;
                        if (animationElementMap.size > 1) {
                            for (var elm = element, parentsToAdd = []; elm = elm.parentNode; ) {
                                var detectedParent = animationElementMap.get(elm);
                                if (detectedParent) {
                                    parentWithAnimation_1 = detectedParent;
                                    break;
                                }
                                parentsToAdd.push(elm);
                            }
                            parentsToAdd.forEach(function(parent) {
                                return animationElementMap.set(parent, parentWithAnimation_1);
                            });
                        }
                        var innerPlayer = _this._buildAnimation(player.namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap);
                        if (player.setRealPlayer(innerPlayer), parentWithAnimation_1 === NO_PARENT_ANIMATION_ELEMENT_DETECTED) rootPlayers.push(player); else {
                            var parentPlayers = _this.playersByElement.get(parentWithAnimation_1);
                            parentPlayers && parentPlayers.length && (player.parentPlayer = optimizeGroupPlayer(parentPlayers)), 
                            skippedPlayers.push(player);
                        }
                    } else eraseStyles(element, instruction.fromStyles), player.onDestroy(function() {
                        return setStyles(element, instruction.toStyles);
                    }), subPlayers.push(player), disabledElementsSet.has(element) && skippedPlayers.push(player);
                }), subPlayers.forEach(function(player) {
                    var playersForElement = skippedPlayersMap.get(player.element);
                    if (playersForElement && playersForElement.length) {
                        var innerPlayer = optimizeGroupPlayer(playersForElement);
                        player.setRealPlayer(innerPlayer);
                    }
                }), skippedPlayers.forEach(function(player) {
                    player.parentPlayer ? player.syncPlayerEvents(player.parentPlayer) : player.destroy();
                });
                for (var i_4 = 0; i_4 < allLeaveNodes.length; i_4++) {
                    var element, details = (element = allLeaveNodes[i_4])[REMOVAL_FLAG];
                    if (removeClass(element, "ng-leave"), !details || !details.hasAnimation) {
                        var players = [];
                        if (queriedElements.size) {
                            var queriedPlayerResults = queriedElements.get(element);
                            queriedPlayerResults && queriedPlayerResults.length && players.push.apply(players, __spread(queriedPlayerResults));
                            for (var queriedInnerElements = this.driver.query(element, ".ng-animating", !0), j = 0; j < queriedInnerElements.length; j++) {
                                var queriedPlayers = queriedElements.get(queriedInnerElements[j]);
                                queriedPlayers && queriedPlayers.length && players.push.apply(players, __spread(queriedPlayers));
                            }
                        }
                        var activePlayers = players.filter(function(p) {
                            return !p.destroyed;
                        });
                        activePlayers.length ? removeNodesAfterAnimationDone(this, element, activePlayers) : this.processLeaveNode(element);
                    }
                }
                return allLeaveNodes.length = 0, rootPlayers.forEach(function(player) {
                    _this.players.push(player), player.onDone(function() {
                        player.destroy();
                        var index = _this.players.indexOf(player);
                        _this.players.splice(index, 1);
                    }), player.play();
                }), rootPlayers;
            }, TransitionAnimationEngine.prototype.elementContainsData = function(namespaceId, element) {
                var containsData = !1, details = element[REMOVAL_FLAG];
                return details && details.setForRemoval && (containsData = !0), this.playersByElement.has(element) && (containsData = !0), 
                this.playersByQueriedElement.has(element) && (containsData = !0), this.statesByElement.has(element) && (containsData = !0), 
                this._fetchNamespace(namespaceId).elementContainsData(element) || containsData;
            }, TransitionAnimationEngine.prototype.afterFlush = function(callback) {
                this._flushFns.push(callback);
            }, TransitionAnimationEngine.prototype.afterFlushAnimationsDone = function(callback) {
                this._whenQuietFns.push(callback);
            }, TransitionAnimationEngine.prototype._getPreviousPlayers = function(element, isQueriedElement, namespaceId, triggerName, toStateValue) {
                var players = [];
                if (isQueriedElement) {
                    var queriedElementPlayers = this.playersByQueriedElement.get(element);
                    queriedElementPlayers && (players = queriedElementPlayers);
                } else {
                    var elementPlayers = this.playersByElement.get(element);
                    if (elementPlayers) {
                        var isRemovalAnimation_1 = !toStateValue || "void" == toStateValue;
                        elementPlayers.forEach(function(player) {
                            player.queued || (isRemovalAnimation_1 || player.triggerName == triggerName) && players.push(player);
                        });
                    }
                }
                return (namespaceId || triggerName) && (players = players.filter(function(player) {
                    return !(namespaceId && namespaceId != player.namespaceId || triggerName && triggerName != player.triggerName);
                })), players;
            }, TransitionAnimationEngine.prototype._beforeAnimationBuild = function(namespaceId, instruction, allPreviousPlayersMap) {
                var e_1, _a, rootElement = instruction.element, targetNameSpaceId = instruction.isRemovalTransition ? void 0 : namespaceId, targetTriggerName = instruction.isRemovalTransition ? void 0 : instruction.triggerName, _loop_1 = function(timelineInstruction) {
                    var element = timelineInstruction.element, isQueriedElement = element !== rootElement, players = getOrSetAsInMap(allPreviousPlayersMap, element, []);
                    this_1._getPreviousPlayers(element, isQueriedElement, targetNameSpaceId, targetTriggerName, instruction.toState).forEach(function(player) {
                        var realPlayer = player.getRealPlayer();
                        realPlayer.beforeDestroy && realPlayer.beforeDestroy(), player.destroy(), players.push(player);
                    });
                }, this_1 = this;
                try {
                    for (var _b = __values(instruction.timelines), _c = _b.next(); !_c.done; _c = _b.next()) _loop_1(_c.value);
                } catch (e_1_1) {
                    e_1 = {
                        error: e_1_1
                    };
                } finally {
                    try {
                        _c && !_c.done && (_a = _b.return) && _a.call(_b);
                    } finally {
                        if (e_1) throw e_1.error;
                    }
                }
                eraseStyles(rootElement, instruction.fromStyles);
            }, TransitionAnimationEngine.prototype._buildAnimation = function(namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap) {
                var _this = this, triggerName = instruction.triggerName, rootElement = instruction.element, allQueriedPlayers = [], allConsumedElements = new Set(), allSubElements = new Set(), allNewPlayers = instruction.timelines.map(function(timelineInstruction) {
                    var element = timelineInstruction.element;
                    allConsumedElements.add(element);
                    var details = element[REMOVAL_FLAG];
                    if (details && details.removedBeforeQueried) return new NoopAnimationPlayer(timelineInstruction.duration, timelineInstruction.delay);
                    var players, finalPlayers, isQueriedElement = element !== rootElement, previousPlayers = (players = (allPreviousPlayersMap.get(element) || EMPTY_PLAYER_ARRAY).map(function(p) {
                        return p.getRealPlayer();
                    }), finalPlayers = [], function _flattenGroupPlayersRecur(players, finalPlayers) {
                        for (var i = 0; i < players.length; i++) {
                            var player = players[i];
                            player instanceof AnimationGroupPlayer ? _flattenGroupPlayersRecur(player.players, finalPlayers) : finalPlayers.push(player);
                        }
                    }(players, finalPlayers), finalPlayers).filter(function(p) {
                        return !!p.element && p.element === element;
                    }), preStyles = preStylesMap.get(element), postStyles = postStylesMap.get(element), keyframes = normalizeKeyframes(0, _this._normalizer, 0, timelineInstruction.keyframes, preStyles, postStyles), player = _this._buildPlayer(timelineInstruction, keyframes, previousPlayers);
                    if (timelineInstruction.subTimeline && skippedPlayersMap && allSubElements.add(element), 
                    isQueriedElement) {
                        var wrappedPlayer = new browser_TransitionAnimationPlayer(namespaceId, triggerName, element);
                        wrappedPlayer.setRealPlayer(player), allQueriedPlayers.push(wrappedPlayer);
                    }
                    return player;
                });
                allQueriedPlayers.forEach(function(player) {
                    getOrSetAsInMap(_this.playersByQueriedElement, player.element, []).push(player), 
                    player.onDone(function() {
                        return function(map, key, value) {
                            var currentValues;
                            if (map instanceof Map) {
                                if (currentValues = map.get(key)) {
                                    if (currentValues.length) {
                                        var index = currentValues.indexOf(value);
                                        currentValues.splice(index, 1);
                                    }
                                    0 == currentValues.length && map.delete(key);
                                }
                            } else (currentValues = map[key]) && (currentValues.length && (index = currentValues.indexOf(value), 
                            currentValues.splice(index, 1)), 0 == currentValues.length && delete map[key]);
                            return currentValues;
                        }(_this.playersByQueriedElement, player.element, player);
                    });
                }), allConsumedElements.forEach(function(element) {
                    return addClass(element, "ng-animating");
                });
                var player = optimizeGroupPlayer(allNewPlayers);
                return player.onDestroy(function() {
                    allConsumedElements.forEach(function(element) {
                        return removeClass(element, "ng-animating");
                    }), setStyles(rootElement, instruction.toStyles);
                }), allSubElements.forEach(function(element) {
                    getOrSetAsInMap(skippedPlayersMap, element, []).push(player);
                }), player;
            }, TransitionAnimationEngine.prototype._buildPlayer = function(instruction, keyframes, previousPlayers) {
                return keyframes.length > 0 ? this.driver.animate(instruction.element, keyframes, instruction.duration, instruction.delay, instruction.easing, previousPlayers) : new NoopAnimationPlayer(instruction.duration, instruction.delay);
            }, TransitionAnimationEngine;
        }(), browser_TransitionAnimationPlayer = function() {
            function TransitionAnimationPlayer(namespaceId, triggerName, element) {
                this.namespaceId = namespaceId, this.triggerName = triggerName, this.element = element, 
                this._player = new NoopAnimationPlayer(), this._containsRealPlayer = !1, this._queuedCallbacks = {}, 
                this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, 
                this.totalTime = 0;
            }
            return TransitionAnimationPlayer.prototype.setRealPlayer = function(player) {
                var _this = this;
                this._containsRealPlayer || (this._player = player, Object.keys(this._queuedCallbacks).forEach(function(phase) {
                    _this._queuedCallbacks[phase].forEach(function(callback) {
                        return listenOnPlayer(player, phase, void 0, callback);
                    });
                }), this._queuedCallbacks = {}, this._containsRealPlayer = !0, this.overrideTotalTime(player.totalTime), 
                this.queued = !1);
            }, TransitionAnimationPlayer.prototype.getRealPlayer = function() {
                return this._player;
            }, TransitionAnimationPlayer.prototype.overrideTotalTime = function(totalTime) {
                this.totalTime = totalTime;
            }, TransitionAnimationPlayer.prototype.syncPlayerEvents = function(player) {
                var _this = this, p = this._player;
                p.triggerCallback && player.onStart(function() {
                    return p.triggerCallback("start");
                }), player.onDone(function() {
                    return _this.finish();
                }), player.onDestroy(function() {
                    return _this.destroy();
                });
            }, TransitionAnimationPlayer.prototype._queueEvent = function(name, callback) {
                getOrSetAsInMap(this._queuedCallbacks, name, []).push(callback);
            }, TransitionAnimationPlayer.prototype.onDone = function(fn) {
                this.queued && this._queueEvent("done", fn), this._player.onDone(fn);
            }, TransitionAnimationPlayer.prototype.onStart = function(fn) {
                this.queued && this._queueEvent("start", fn), this._player.onStart(fn);
            }, TransitionAnimationPlayer.prototype.onDestroy = function(fn) {
                this.queued && this._queueEvent("destroy", fn), this._player.onDestroy(fn);
            }, TransitionAnimationPlayer.prototype.init = function() {
                this._player.init();
            }, TransitionAnimationPlayer.prototype.hasStarted = function() {
                return !this.queued && this._player.hasStarted();
            }, TransitionAnimationPlayer.prototype.play = function() {
                !this.queued && this._player.play();
            }, TransitionAnimationPlayer.prototype.pause = function() {
                !this.queued && this._player.pause();
            }, TransitionAnimationPlayer.prototype.restart = function() {
                !this.queued && this._player.restart();
            }, TransitionAnimationPlayer.prototype.finish = function() {
                this._player.finish();
            }, TransitionAnimationPlayer.prototype.destroy = function() {
                this.destroyed = !0, this._player.destroy();
            }, TransitionAnimationPlayer.prototype.reset = function() {
                !this.queued && this._player.reset();
            }, TransitionAnimationPlayer.prototype.setPosition = function(p) {
                this.queued || this._player.setPosition(p);
            }, TransitionAnimationPlayer.prototype.getPosition = function() {
                return this.queued ? 0 : this._player.getPosition();
            }, TransitionAnimationPlayer.prototype.triggerCallback = function(phaseName) {
                var p = this._player;
                p.triggerCallback && p.triggerCallback(phaseName);
            }, TransitionAnimationPlayer;
        }();
        function isElementNode(node) {
            return node && 1 === node.nodeType;
        }
        function cloakElement(element, value) {
            var oldValue = element.style.display;
            return element.style.display = null != value ? value : "none", oldValue;
        }
        function cloakAndComputeStyles(valuesMap, driver, elements, elementPropsMap, defaultStyle) {
            var cloakVals = [];
            elements.forEach(function(element) {
                return cloakVals.push(cloakElement(element));
            });
            var failedElements = [];
            elementPropsMap.forEach(function(props, element) {
                var styles = {};
                props.forEach(function(prop) {
                    var value = styles[prop] = driver.computeStyle(element, prop, defaultStyle);
                    value && 0 != value.length || (element[REMOVAL_FLAG] = NULL_REMOVED_QUERIED_STATE, 
                    failedElements.push(element));
                }), valuesMap.set(element, styles);
            });
            var i = 0;
            return elements.forEach(function(element) {
                return cloakElement(element, cloakVals[i++]);
            }), failedElements;
        }
        function buildRootMap(roots, nodes) {
            var rootMap = new Map();
            if (roots.forEach(function(root) {
                return rootMap.set(root, []);
            }), 0 == nodes.length) return rootMap;
            var nodeSet = new Set(nodes), localRootMap = new Map();
            return nodes.forEach(function(node) {
                var root = function getRoot(node) {
                    if (!node) return 1;
                    var root = localRootMap.get(node);
                    if (root) return root;
                    var parent = node.parentNode;
                    return root = rootMap.has(parent) ? parent : nodeSet.has(parent) ? 1 : getRoot(parent), 
                    localRootMap.set(node, root), root;
                }(node);
                1 !== root && rootMap.get(root).push(node);
            }), rootMap;
        }
        var CLASSES_CACHE_KEY = "$$classes";
        function addClass(element, className) {
            if (element.classList) element.classList.add(className); else {
                var classes = element[CLASSES_CACHE_KEY];
                classes || (classes = element[CLASSES_CACHE_KEY] = {}), classes[className] = !0;
            }
        }
        function removeClass(element, className) {
            if (element.classList) element.classList.remove(className); else {
                var classes = element[CLASSES_CACHE_KEY];
                classes && delete classes[className];
            }
        }
        function removeNodesAfterAnimationDone(engine, element, players) {
            optimizeGroupPlayer(players).onDone(function() {
                return engine.processLeaveNode(element);
            });
        }
        function replacePostStylesAsPre(element, allPreStyleElements, allPostStyleElements) {
            var postEntry = allPostStyleElements.get(element);
            if (!postEntry) return !1;
            var preEntry = allPreStyleElements.get(element);
            return preEntry ? postEntry.forEach(function(data) {
                return preEntry.add(data);
            }) : allPreStyleElements.set(element, postEntry), allPostStyleElements.delete(element), 
            !0;
        }
        var browser_AnimationEngine = function() {
            function AnimationEngine(bodyNode, _driver, normalizer) {
                var _this = this;
                this.bodyNode = bodyNode, this._driver = _driver, this._triggerCache = {}, this.onRemovalComplete = function(element, context) {}, 
                this._transitionEngine = new browser_TransitionAnimationEngine(bodyNode, _driver, normalizer), 
                this._timelineEngine = new browser_TimelineAnimationEngine(bodyNode, _driver, normalizer), 
                this._transitionEngine.onRemovalComplete = function(element, context) {
                    return _this.onRemovalComplete(element, context);
                };
            }
            return AnimationEngine.prototype.registerTrigger = function(componentId, namespaceId, hostElement, name, metadata) {
                var cacheKey = componentId + "-" + name, trigger = this._triggerCache[cacheKey];
                if (!trigger) {
                    var errors = [], ast = buildAnimationAst(this._driver, metadata, errors);
                    if (errors.length) throw new Error('The animation trigger "' + name + '" has failed to build due to the following errors:\n - ' + errors.join("\n - "));
                    trigger = function(name, ast) {
                        return new AnimationTrigger(name, ast);
                    }(name, ast), this._triggerCache[cacheKey] = trigger;
                }
                this._transitionEngine.registerTrigger(namespaceId, name, trigger);
            }, AnimationEngine.prototype.register = function(namespaceId, hostElement) {
                this._transitionEngine.register(namespaceId, hostElement);
            }, AnimationEngine.prototype.destroy = function(namespaceId, context) {
                this._transitionEngine.destroy(namespaceId, context);
            }, AnimationEngine.prototype.onInsert = function(namespaceId, element, parent, insertBefore) {
                this._transitionEngine.insertNode(namespaceId, element, parent, insertBefore);
            }, AnimationEngine.prototype.onRemove = function(namespaceId, element, context, isHostElement) {
                this._transitionEngine.removeNode(namespaceId, element, isHostElement || !1, context);
            }, AnimationEngine.prototype.disableAnimations = function(element, disable) {
                this._transitionEngine.markElementAsDisabled(element, disable);
            }, AnimationEngine.prototype.process = function(namespaceId, element, property, value) {
                if ("@" == property.charAt(0)) {
                    var _a = __read(parseTimelineCommand(property), 2);
                    this._timelineEngine.command(_a[0], element, _a[1], value);
                } else this._transitionEngine.trigger(namespaceId, element, property, value);
            }, AnimationEngine.prototype.listen = function(namespaceId, element, eventName, eventPhase, callback) {
                if ("@" == eventName.charAt(0)) {
                    var _a = __read(parseTimelineCommand(eventName), 2);
                    return this._timelineEngine.listen(_a[0], element, _a[1], callback);
                }
                return this._transitionEngine.listen(namespaceId, element, eventName, eventPhase, callback);
            }, AnimationEngine.prototype.flush = function(microtaskId) {
                void 0 === microtaskId && (microtaskId = -1), this._transitionEngine.flush(microtaskId);
            }, Object.defineProperty(AnimationEngine.prototype, "players", {
                get: function() {
                    return this._transitionEngine.players.concat(this._timelineEngine.players);
                },
                enumerable: !0,
                configurable: !0
            }), AnimationEngine.prototype.whenRenderingDone = function() {
                return this._transitionEngine.whenRenderingDone();
            }, AnimationEngine;
        }();
        function packageNonAnimatableStyles(element, styles) {
            var startStyles = null, endStyles = null;
            return Array.isArray(styles) && styles.length ? (startStyles = filterNonAnimatableStyles(styles[0]), 
            styles.length > 1 && (endStyles = filterNonAnimatableStyles(styles[styles.length - 1]))) : styles && (startStyles = filterNonAnimatableStyles(styles)), 
            startStyles || endStyles ? new SpecialCasedStyles(element, startStyles, endStyles) : null;
        }
        var SpecialCasedStyles = function() {
            function SpecialCasedStyles(_element, _startStyles, _endStyles) {
                this._element = _element, this._startStyles = _startStyles, this._endStyles = _endStyles, 
                this._state = 0;
                var initialStyles = SpecialCasedStyles.initialStylesByElement.get(_element);
                initialStyles || SpecialCasedStyles.initialStylesByElement.set(_element, initialStyles = {}), 
                this._initialStyles = initialStyles;
            }
            return SpecialCasedStyles.prototype.start = function() {
                this._state < 1 && (this._startStyles && setStyles(this._element, this._startStyles, this._initialStyles), 
                this._state = 1);
            }, SpecialCasedStyles.prototype.finish = function() {
                this.start(), this._state < 2 && (setStyles(this._element, this._initialStyles), 
                this._endStyles && (setStyles(this._element, this._endStyles), this._endStyles = null), 
                this._state = 1);
            }, SpecialCasedStyles.prototype.destroy = function() {
                this.finish(), this._state < 3 && (SpecialCasedStyles.initialStylesByElement.delete(this._element), 
                this._startStyles && (eraseStyles(this._element, this._startStyles), this._endStyles = null), 
                this._endStyles && (eraseStyles(this._element, this._endStyles), this._endStyles = null), 
                setStyles(this._element, this._initialStyles), this._state = 3);
            }, SpecialCasedStyles.initialStylesByElement = new WeakMap(), SpecialCasedStyles;
        }();
        function filterNonAnimatableStyles(styles) {
            for (var result = null, props = Object.keys(styles), i = 0; i < props.length; i++) {
                var prop = props[i];
                isNonAnimatableStyle(prop) && ((result = result || {})[prop] = styles[prop]);
            }
            return result;
        }
        function isNonAnimatableStyle(prop) {
            return "display" === prop || "position" === prop;
        }
        var ANIMATION_PROP = "animation", ANIMATIONEND_EVENT = "animationend", ElementAnimationStyleHandler = function() {
            function ElementAnimationStyleHandler(_element, _name, _duration, _delay, _easing, _fillMode, _onDoneFn) {
                var _this = this;
                this._element = _element, this._name = _name, this._duration = _duration, this._delay = _delay, 
                this._easing = _easing, this._fillMode = _fillMode, this._onDoneFn = _onDoneFn, 
                this._finished = !1, this._destroyed = !1, this._startTime = 0, this._position = 0, 
                this._eventFn = function(e) {
                    return _this._handleCallback(e);
                };
            }
            return ElementAnimationStyleHandler.prototype.apply = function() {
                var element, value, anim;
                value = this._duration + "ms " + this._easing + " " + this._delay + "ms 1 normal " + this._fillMode + " " + this._name, 
                (anim = getAnimationStyle(element = this._element, "").trim()).length && (function(value, char) {
                    for (var i = 0; i < value.length; i++) "," === value.charAt(i) && 0;
                }(anim), value = anim + ", " + value), setAnimationStyle(element, "", value), addRemoveAnimationEvent(this._element, this._eventFn, !1), 
                this._startTime = Date.now();
            }, ElementAnimationStyleHandler.prototype.pause = function() {
                playPauseAnimation(this._element, this._name, "paused");
            }, ElementAnimationStyleHandler.prototype.resume = function() {
                playPauseAnimation(this._element, this._name, "running");
            }, ElementAnimationStyleHandler.prototype.setPosition = function(position) {
                var index = findIndexForAnimation(this._element, this._name);
                this._position = position * this._duration, setAnimationStyle(this._element, "Delay", "-" + this._position + "ms", index);
            }, ElementAnimationStyleHandler.prototype.getPosition = function() {
                return this._position;
            }, ElementAnimationStyleHandler.prototype._handleCallback = function(event) {
                var timestamp = event._ngTestManualTimestamp || Date.now(), elapsedTime = 1e3 * parseFloat(event.elapsedTime.toFixed(3));
                event.animationName == this._name && Math.max(timestamp - this._startTime, 0) >= this._delay && elapsedTime >= this._duration && this.finish();
            }, ElementAnimationStyleHandler.prototype.finish = function() {
                this._finished || (this._finished = !0, this._onDoneFn(), addRemoveAnimationEvent(this._element, this._eventFn, !0));
            }, ElementAnimationStyleHandler.prototype.destroy = function() {
                var element, name, tokens, index;
                this._destroyed || (this._destroyed = !0, this.finish(), name = this._name, (index = findMatchingTokenIndex(tokens = getAnimationStyle(element = this._element, "").split(","), name)) >= 0 && (tokens.splice(index, 1), 
                setAnimationStyle(element, "", tokens.join(","))));
            }, ElementAnimationStyleHandler;
        }();
        function playPauseAnimation(element, name, status) {
            setAnimationStyle(element, "PlayState", status, findIndexForAnimation(element, name));
        }
        function findIndexForAnimation(element, value) {
            var anim = getAnimationStyle(element, "");
            return anim.indexOf(",") > 0 ? findMatchingTokenIndex(anim.split(","), value) : findMatchingTokenIndex([ anim ], value);
        }
        function findMatchingTokenIndex(tokens, searchToken) {
            for (var i = 0; i < tokens.length; i++) if (tokens[i].indexOf(searchToken) >= 0) return i;
            return -1;
        }
        function addRemoveAnimationEvent(element, fn, doRemove) {
            doRemove ? element.removeEventListener(ANIMATIONEND_EVENT, fn) : element.addEventListener(ANIMATIONEND_EVENT, fn);
        }
        function setAnimationStyle(element, name, value, index) {
            var prop = ANIMATION_PROP + name;
            if (null != index) {
                var oldValue = element.style[prop];
                if (oldValue.length) {
                    var tokens = oldValue.split(",");
                    tokens[index] = value, value = tokens.join(",");
                }
            }
            element.style[prop] = value;
        }
        function getAnimationStyle(element, name) {
            return element.style[ANIMATION_PROP + name];
        }
        var DEFAULT_EASING = "linear", CssKeyframesPlayer = function() {
            function CssKeyframesPlayer(element, keyframes, animationName, _duration, _delay, easing, _finalStyles, _specialStyles) {
                this.element = element, this.keyframes = keyframes, this.animationName = animationName, 
                this._duration = _duration, this._delay = _delay, this._finalStyles = _finalStyles, 
                this._specialStyles = _specialStyles, this._onDoneFns = [], this._onStartFns = [], 
                this._onDestroyFns = [], this._started = !1, this.currentSnapshot = {}, this._state = 0, 
                this.easing = easing || DEFAULT_EASING, this.totalTime = _duration + _delay, this._buildStyler();
            }
            return CssKeyframesPlayer.prototype.onStart = function(fn) {
                this._onStartFns.push(fn);
            }, CssKeyframesPlayer.prototype.onDone = function(fn) {
                this._onDoneFns.push(fn);
            }, CssKeyframesPlayer.prototype.onDestroy = function(fn) {
                this._onDestroyFns.push(fn);
            }, CssKeyframesPlayer.prototype.destroy = function() {
                this.init(), this._state >= 4 || (this._state = 4, this._styler.destroy(), this._flushStartFns(), 
                this._flushDoneFns(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(function(fn) {
                    return fn();
                }), this._onDestroyFns = []);
            }, CssKeyframesPlayer.prototype._flushDoneFns = function() {
                this._onDoneFns.forEach(function(fn) {
                    return fn();
                }), this._onDoneFns = [];
            }, CssKeyframesPlayer.prototype._flushStartFns = function() {
                this._onStartFns.forEach(function(fn) {
                    return fn();
                }), this._onStartFns = [];
            }, CssKeyframesPlayer.prototype.finish = function() {
                this.init(), this._state >= 3 || (this._state = 3, this._styler.finish(), this._flushStartFns(), 
                this._specialStyles && this._specialStyles.finish(), this._flushDoneFns());
            }, CssKeyframesPlayer.prototype.setPosition = function(value) {
                this._styler.setPosition(value);
            }, CssKeyframesPlayer.prototype.getPosition = function() {
                return this._styler.getPosition();
            }, CssKeyframesPlayer.prototype.hasStarted = function() {
                return this._state >= 2;
            }, CssKeyframesPlayer.prototype.init = function() {
                this._state >= 1 || (this._state = 1, this._styler.apply(), this._delay && this._styler.pause());
            }, CssKeyframesPlayer.prototype.play = function() {
                this.init(), this.hasStarted() || (this._flushStartFns(), this._state = 2, this._specialStyles && this._specialStyles.start()), 
                this._styler.resume();
            }, CssKeyframesPlayer.prototype.pause = function() {
                this.init(), this._styler.pause();
            }, CssKeyframesPlayer.prototype.restart = function() {
                this.reset(), this.play();
            }, CssKeyframesPlayer.prototype.reset = function() {
                this._styler.destroy(), this._buildStyler(), this._styler.apply();
            }, CssKeyframesPlayer.prototype._buildStyler = function() {
                var _this = this;
                this._styler = new ElementAnimationStyleHandler(this.element, this.animationName, this._duration, this._delay, this.easing, "forwards", function() {
                    return _this.finish();
                });
            }, CssKeyframesPlayer.prototype.triggerCallback = function(phaseName) {
                var methods = "start" == phaseName ? this._onStartFns : this._onDoneFns;
                methods.forEach(function(fn) {
                    return fn();
                }), methods.length = 0;
            }, CssKeyframesPlayer.prototype.beforeDestroy = function() {
                var _this = this;
                this.init();
                var styles = {};
                if (this.hasStarted()) {
                    var finished_1 = this._state >= 3;
                    Object.keys(this._finalStyles).forEach(function(prop) {
                        "offset" != prop && (styles[prop] = finished_1 ? _this._finalStyles[prop] : computeStyle(_this.element, prop));
                    });
                }
                this.currentSnapshot = styles;
            }, CssKeyframesPlayer;
        }(), browser_DirectStylePlayer = function(_super) {
            function DirectStylePlayer(element, styles) {
                var _this = _super.call(this) || this;
                return _this.element = element, _this._startingStyles = {}, _this.__initialized = !1, 
                _this._styles = hypenatePropsObject(styles), _this;
            }
            return __extends(DirectStylePlayer, _super), DirectStylePlayer.prototype.init = function() {
                var _this = this;
                !this.__initialized && this._startingStyles && (this.__initialized = !0, Object.keys(this._styles).forEach(function(prop) {
                    _this._startingStyles[prop] = _this.element.style[prop];
                }), _super.prototype.init.call(this));
            }, DirectStylePlayer.prototype.play = function() {
                var _this = this;
                this._startingStyles && (this.init(), Object.keys(this._styles).forEach(function(prop) {
                    return _this.element.style.setProperty(prop, _this._styles[prop]);
                }), _super.prototype.play.call(this));
            }, DirectStylePlayer.prototype.destroy = function() {
                var _this = this;
                this._startingStyles && (Object.keys(this._startingStyles).forEach(function(prop) {
                    var value = _this._startingStyles[prop];
                    value ? _this.element.style.setProperty(prop, value) : _this.element.style.removeProperty(prop);
                }), this._startingStyles = null, _super.prototype.destroy.call(this));
            }, DirectStylePlayer;
        }(NoopAnimationPlayer), CssKeyframesDriver = function() {
            function CssKeyframesDriver() {
                this._count = 0, this._head = document.querySelector("head"), this._warningIssued = !1;
            }
            return CssKeyframesDriver.prototype.validateStyleProperty = function(prop) {
                return validateStyleProperty(prop);
            }, CssKeyframesDriver.prototype.matchesElement = function(element, selector) {
                return matchesElement(element, selector);
            }, CssKeyframesDriver.prototype.containsElement = function(elm1, elm2) {
                return containsElement(elm1, elm2);
            }, CssKeyframesDriver.prototype.query = function(element, selector, multi) {
                return invokeQuery(element, selector, multi);
            }, CssKeyframesDriver.prototype.computeStyle = function(element, prop, defaultValue) {
                return window.getComputedStyle(element)[prop];
            }, CssKeyframesDriver.prototype.buildKeyframeElement = function(element, name, keyframes) {
                keyframes = keyframes.map(function(kf) {
                    return hypenatePropsObject(kf);
                });
                var keyframeStr = "@keyframes " + name + " {\n", tab = "";
                keyframes.forEach(function(kf) {
                    tab = " ";
                    var offset = parseFloat(kf.offset);
                    keyframeStr += "" + tab + 100 * offset + "% {\n", tab += " ", Object.keys(kf).forEach(function(prop) {
                        var value = kf[prop];
                        switch (prop) {
                          case "offset":
                            return;

                          case "easing":
                            return void (value && (keyframeStr += tab + "animation-timing-function: " + value + ";\n"));

                          default:
                            return void (keyframeStr += "" + tab + prop + ": " + value + ";\n");
                        }
                    }), keyframeStr += tab + "}\n";
                }), keyframeStr += "}\n";
                var kfElm = document.createElement("style");
                return kfElm.innerHTML = keyframeStr, kfElm;
            }, CssKeyframesDriver.prototype.animate = function(element, keyframes, duration, delay, easing, previousPlayers, scrubberAccessRequested) {
                void 0 === previousPlayers && (previousPlayers = []), scrubberAccessRequested && this._notifyFaultyScrubber();
                var previousCssKeyframePlayers = previousPlayers.filter(function(player) {
                    return player instanceof CssKeyframesPlayer;
                }), previousStyles = {};
                allowPreviousPlayerStylesMerge(duration, delay) && previousCssKeyframePlayers.forEach(function(player) {
                    var styles = player.currentSnapshot;
                    Object.keys(styles).forEach(function(prop) {
                        return previousStyles[prop] = styles[prop];
                    });
                });
                var finalStyles = function(keyframes) {
                    var flatKeyframes = {};
                    return keyframes && (Array.isArray(keyframes) ? keyframes : [ keyframes ]).forEach(function(kf) {
                        Object.keys(kf).forEach(function(prop) {
                            "offset" != prop && "easing" != prop && (flatKeyframes[prop] = kf[prop]);
                        });
                    }), flatKeyframes;
                }(keyframes = balancePreviousStylesIntoKeyframes(element, keyframes, previousStyles));
                if (0 == duration) return new browser_DirectStylePlayer(element, finalStyles);
                var animationName = "gen_css_kf_" + this._count++, kfElm = this.buildKeyframeElement(element, animationName, keyframes);
                document.querySelector("head").appendChild(kfElm);
                var specialStyles = packageNonAnimatableStyles(element, keyframes), player = new CssKeyframesPlayer(element, keyframes, animationName, duration, delay, easing, finalStyles, specialStyles);
                return player.onDestroy(function() {
                    var node;
                    (node = kfElm).parentNode.removeChild(node);
                }), player;
            }, CssKeyframesDriver.prototype._notifyFaultyScrubber = function() {
                this._warningIssued || (console.warn("@angular/animations: please load the web-animations.js polyfill to allow programmatic access...\n", "  visit http://bit.ly/IWukam to learn more about using the web-animation-js polyfill."), 
                this._warningIssued = !0);
            }, CssKeyframesDriver;
        }(), WebAnimationsPlayer = function() {
            function WebAnimationsPlayer(element, keyframes, options, _specialStyles) {
                this.element = element, this.keyframes = keyframes, this.options = options, this._specialStyles = _specialStyles, 
                this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, 
                this._finished = !1, this._started = !1, this._destroyed = !1, this.time = 0, this.parentPlayer = null, 
                this.currentSnapshot = {}, this._duration = options.duration, this._delay = options.delay || 0, 
                this.time = this._duration + this._delay;
            }
            return WebAnimationsPlayer.prototype._onFinish = function() {
                this._finished || (this._finished = !0, this._onDoneFns.forEach(function(fn) {
                    return fn();
                }), this._onDoneFns = []);
            }, WebAnimationsPlayer.prototype.init = function() {
                this._buildPlayer(), this._preparePlayerBeforeStart();
            }, WebAnimationsPlayer.prototype._buildPlayer = function() {
                var _this = this;
                if (!this._initialized) {
                    this._initialized = !0;
                    var keyframes = this.keyframes;
                    this.domPlayer = this._triggerWebAnimation(this.element, keyframes, this.options), 
                    this._finalKeyframe = keyframes.length ? keyframes[keyframes.length - 1] : {}, this.domPlayer.addEventListener("finish", function() {
                        return _this._onFinish();
                    });
                }
            }, WebAnimationsPlayer.prototype._preparePlayerBeforeStart = function() {
                this._delay ? this._resetDomPlayerState() : this.domPlayer.pause();
            }, WebAnimationsPlayer.prototype._triggerWebAnimation = function(element, keyframes, options) {
                return element.animate(keyframes, options);
            }, WebAnimationsPlayer.prototype.onStart = function(fn) {
                this._onStartFns.push(fn);
            }, WebAnimationsPlayer.prototype.onDone = function(fn) {
                this._onDoneFns.push(fn);
            }, WebAnimationsPlayer.prototype.onDestroy = function(fn) {
                this._onDestroyFns.push(fn);
            }, WebAnimationsPlayer.prototype.play = function() {
                this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(function(fn) {
                    return fn();
                }), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), 
                this.domPlayer.play();
            }, WebAnimationsPlayer.prototype.pause = function() {
                this.init(), this.domPlayer.pause();
            }, WebAnimationsPlayer.prototype.finish = function() {
                this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), 
                this.domPlayer.finish();
            }, WebAnimationsPlayer.prototype.reset = function() {
                this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1;
            }, WebAnimationsPlayer.prototype._resetDomPlayerState = function() {
                this.domPlayer && this.domPlayer.cancel();
            }, WebAnimationsPlayer.prototype.restart = function() {
                this.reset(), this.play();
            }, WebAnimationsPlayer.prototype.hasStarted = function() {
                return this._started;
            }, WebAnimationsPlayer.prototype.destroy = function() {
                this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), 
                this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(function(fn) {
                    return fn();
                }), this._onDestroyFns = []);
            }, WebAnimationsPlayer.prototype.setPosition = function(p) {
                this.domPlayer.currentTime = p * this.time;
            }, WebAnimationsPlayer.prototype.getPosition = function() {
                return this.domPlayer.currentTime / this.time;
            }, Object.defineProperty(WebAnimationsPlayer.prototype, "totalTime", {
                get: function() {
                    return this._delay + this._duration;
                },
                enumerable: !0,
                configurable: !0
            }), WebAnimationsPlayer.prototype.beforeDestroy = function() {
                var _this = this, styles = {};
                this.hasStarted() && Object.keys(this._finalKeyframe).forEach(function(prop) {
                    "offset" != prop && (styles[prop] = _this._finished ? _this._finalKeyframe[prop] : computeStyle(_this.element, prop));
                }), this.currentSnapshot = styles;
            }, WebAnimationsPlayer.prototype.triggerCallback = function(phaseName) {
                var methods = "start" == phaseName ? this._onStartFns : this._onDoneFns;
                methods.forEach(function(fn) {
                    return fn();
                }), methods.length = 0;
            }, WebAnimationsPlayer;
        }(), WebAnimationsDriver = function() {
            function WebAnimationsDriver() {
                this._isNativeImpl = /\{\s*\[native\s+code\]\s*\}/.test(getElementAnimateFn().toString()), 
                this._cssKeyframesDriver = new CssKeyframesDriver();
            }
            return WebAnimationsDriver.prototype.validateStyleProperty = function(prop) {
                return validateStyleProperty(prop);
            }, WebAnimationsDriver.prototype.matchesElement = function(element, selector) {
                return matchesElement(element, selector);
            }, WebAnimationsDriver.prototype.containsElement = function(elm1, elm2) {
                return containsElement(elm1, elm2);
            }, WebAnimationsDriver.prototype.query = function(element, selector, multi) {
                return invokeQuery(element, selector, multi);
            }, WebAnimationsDriver.prototype.computeStyle = function(element, prop, defaultValue) {
                return window.getComputedStyle(element)[prop];
            }, WebAnimationsDriver.prototype.overrideWebAnimationsSupport = function(supported) {
                this._isNativeImpl = supported;
            }, WebAnimationsDriver.prototype.animate = function(element, keyframes, duration, delay, easing, previousPlayers, scrubberAccessRequested) {
                if (void 0 === previousPlayers && (previousPlayers = []), !scrubberAccessRequested && !this._isNativeImpl) return this._cssKeyframesDriver.animate(element, keyframes, duration, delay, easing, previousPlayers);
                var playerOptions = {
                    duration: duration,
                    delay: delay,
                    fill: 0 == delay ? "both" : "forwards"
                };
                easing && (playerOptions.easing = easing);
                var previousStyles = {}, previousWebAnimationPlayers = previousPlayers.filter(function(player) {
                    return player instanceof WebAnimationsPlayer;
                });
                allowPreviousPlayerStylesMerge(duration, delay) && previousWebAnimationPlayers.forEach(function(player) {
                    var styles = player.currentSnapshot;
                    Object.keys(styles).forEach(function(prop) {
                        return previousStyles[prop] = styles[prop];
                    });
                });
                var specialStyles = packageNonAnimatableStyles(element, keyframes = balancePreviousStylesIntoKeyframes(element, keyframes = keyframes.map(function(styles) {
                    return copyStyles(styles, !1);
                }), previousStyles));
                return new WebAnimationsPlayer(element, keyframes, playerOptions, specialStyles);
            }, WebAnimationsDriver;
        }();
        function getElementAnimateFn() {
            return "undefined" != typeof window && void 0 !== window.document && Element.prototype.animate || {};
        }
        var animations_BrowserAnimationBuilder = function(_super) {
            function BrowserAnimationBuilder(rootRenderer, doc) {
                var _this = _super.call(this) || this;
                return _this._nextAnimationId = 0, _this._renderer = rootRenderer.createRenderer(doc.body, {
                    id: "0",
                    encapsulation: ViewEncapsulation.None,
                    styles: [],
                    data: {
                        animation: []
                    }
                }), _this;
            }
            return __extends(BrowserAnimationBuilder, _super), BrowserAnimationBuilder.prototype.build = function(animation) {
                var id = this._nextAnimationId.toString();
                this._nextAnimationId++;
                var entry = Array.isArray(animation) ? sequence(animation) : animation;
                return issueAnimationCommand(this._renderer, null, id, "register", [ entry ]), new animations_BrowserAnimationFactory(id, this._renderer);
            }, BrowserAnimationBuilder.ngInjectableDef = defineInjectable({
                token: BrowserAnimationBuilder,
                factory: function(t) {
                    return new (t || BrowserAnimationBuilder)(inject(RendererFactory2), inject(DOCUMENT));
                },
                providedIn: null
            }), BrowserAnimationBuilder;
        }(AnimationBuilder), animations_BrowserAnimationFactory = function(_super) {
            function BrowserAnimationFactory(_id, _renderer) {
                var _this = _super.call(this) || this;
                return _this._id = _id, _this._renderer = _renderer, _this;
            }
            return __extends(BrowserAnimationFactory, _super), BrowserAnimationFactory.prototype.create = function(element, options) {
                return new RendererAnimationPlayer(this._id, element, options || {}, this._renderer);
            }, BrowserAnimationFactory;
        }(AnimationFactory), RendererAnimationPlayer = function() {
            function RendererAnimationPlayer(id, element, options, _renderer) {
                this.id = id, this.element = element, this._renderer = _renderer, this.parentPlayer = null, 
                this._started = !1, this.totalTime = 0, this._command("create", options);
            }
            return RendererAnimationPlayer.prototype._listen = function(eventName, callback) {
                return this._renderer.listen(this.element, "@@" + this.id + ":" + eventName, callback);
            }, RendererAnimationPlayer.prototype._command = function(command) {
                for (var args = [], _i = 1; _i < arguments.length; _i++) args[_i - 1] = arguments[_i];
                return issueAnimationCommand(this._renderer, this.element, this.id, command, args);
            }, RendererAnimationPlayer.prototype.onDone = function(fn) {
                this._listen("done", fn);
            }, RendererAnimationPlayer.prototype.onStart = function(fn) {
                this._listen("start", fn);
            }, RendererAnimationPlayer.prototype.onDestroy = function(fn) {
                this._listen("destroy", fn);
            }, RendererAnimationPlayer.prototype.init = function() {
                this._command("init");
            }, RendererAnimationPlayer.prototype.hasStarted = function() {
                return this._started;
            }, RendererAnimationPlayer.prototype.play = function() {
                this._command("play"), this._started = !0;
            }, RendererAnimationPlayer.prototype.pause = function() {
                this._command("pause");
            }, RendererAnimationPlayer.prototype.restart = function() {
                this._command("restart");
            }, RendererAnimationPlayer.prototype.finish = function() {
                this._command("finish");
            }, RendererAnimationPlayer.prototype.destroy = function() {
                this._command("destroy");
            }, RendererAnimationPlayer.prototype.reset = function() {
                this._command("reset");
            }, RendererAnimationPlayer.prototype.setPosition = function(p) {
                this._command("setPosition", p);
            }, RendererAnimationPlayer.prototype.getPosition = function() {
                return 0;
            }, RendererAnimationPlayer;
        }();
        function issueAnimationCommand(renderer, element, id, command, args) {
            return renderer.setProperty(element, "@@" + id + ":" + command, args);
        }
        var animations_AnimationRendererFactory = function() {
            function AnimationRendererFactory(delegate, engine, _zone) {
                this.delegate = delegate, this.engine = engine, this._zone = _zone, this._currentId = 0, 
                this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map(), 
                this._cdRecurDepth = 0, this.promise = Promise.resolve(0), engine.onRemovalComplete = function(element, delegate) {
                    delegate && delegate.parentNode(element) && delegate.removeChild(element.parentNode, element);
                };
            }
            return AnimationRendererFactory.prototype.createRenderer = function(hostElement, type) {
                var _this = this, delegate = this.delegate.createRenderer(hostElement, type);
                if (!(hostElement && type && type.data && type.data.animation)) {
                    var renderer = this._rendererCache.get(delegate);
                    return renderer || (renderer = new BaseAnimationRenderer("", delegate, this.engine), 
                    this._rendererCache.set(delegate, renderer)), renderer;
                }
                var componentId = type.id, namespaceId = type.id + "-" + this._currentId;
                return this._currentId++, this.engine.register(namespaceId, hostElement), type.data.animation.forEach(function(trigger) {
                    return _this.engine.registerTrigger(componentId, namespaceId, hostElement, trigger.name, trigger);
                }), new animations_AnimationRenderer(this, namespaceId, delegate, this.engine);
            }, AnimationRendererFactory.prototype.begin = function() {
                this._cdRecurDepth++, this.delegate.begin && this.delegate.begin();
            }, AnimationRendererFactory.prototype._scheduleCountTask = function() {
                var _this = this;
                this.promise.then(function() {
                    _this._microtaskId++;
                });
            }, AnimationRendererFactory.prototype.scheduleListenerCallback = function(count, fn, data) {
                var _this = this;
                count >= 0 && count < this._microtaskId ? this._zone.run(function() {
                    return fn(data);
                }) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(function() {
                    _this._zone.run(function() {
                        _this._animationCallbacksBuffer.forEach(function(tuple) {
                            var _a = __read(tuple, 2);
                            (0, _a[0])(_a[1]);
                        }), _this._animationCallbacksBuffer = [];
                    });
                }), this._animationCallbacksBuffer.push([ fn, data ]));
            }, AnimationRendererFactory.prototype.end = function() {
                var _this = this;
                this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(function() {
                    _this._scheduleCountTask(), _this.engine.flush(_this._microtaskId);
                }), this.delegate.end && this.delegate.end();
            }, AnimationRendererFactory.prototype.whenRenderingDone = function() {
                return this.engine.whenRenderingDone();
            }, AnimationRendererFactory.ngInjectableDef = defineInjectable({
                token: AnimationRendererFactory,
                factory: function(t) {
                    return new (t || AnimationRendererFactory)(inject(RendererFactory2), inject(browser_AnimationEngine), inject(NgZone));
                },
                providedIn: null
            }), AnimationRendererFactory;
        }(), BaseAnimationRenderer = function() {
            function BaseAnimationRenderer(namespaceId, delegate, engine) {
                this.namespaceId = namespaceId, this.delegate = delegate, this.engine = engine, 
                this.destroyNode = this.delegate.destroyNode ? function(n) {
                    return delegate.destroyNode(n);
                } : null;
            }
            return Object.defineProperty(BaseAnimationRenderer.prototype, "data", {
                get: function() {
                    return this.delegate.data;
                },
                enumerable: !0,
                configurable: !0
            }), BaseAnimationRenderer.prototype.destroy = function() {
                this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy();
            }, BaseAnimationRenderer.prototype.createElement = function(name, namespace) {
                return this.delegate.createElement(name, namespace);
            }, BaseAnimationRenderer.prototype.createComment = function(value) {
                return this.delegate.createComment(value);
            }, BaseAnimationRenderer.prototype.createText = function(value) {
                return this.delegate.createText(value);
            }, BaseAnimationRenderer.prototype.appendChild = function(parent, newChild) {
                this.delegate.appendChild(parent, newChild), this.engine.onInsert(this.namespaceId, newChild, parent, !1);
            }, BaseAnimationRenderer.prototype.insertBefore = function(parent, newChild, refChild) {
                this.delegate.insertBefore(parent, newChild, refChild), this.engine.onInsert(this.namespaceId, newChild, parent, !0);
            }, BaseAnimationRenderer.prototype.removeChild = function(parent, oldChild, isHostElement) {
                this.engine.onRemove(this.namespaceId, oldChild, this.delegate, isHostElement);
            }, BaseAnimationRenderer.prototype.selectRootElement = function(selectorOrNode, preserveContent) {
                return this.delegate.selectRootElement(selectorOrNode, preserveContent);
            }, BaseAnimationRenderer.prototype.parentNode = function(node) {
                return this.delegate.parentNode(node);
            }, BaseAnimationRenderer.prototype.nextSibling = function(node) {
                return this.delegate.nextSibling(node);
            }, BaseAnimationRenderer.prototype.setAttribute = function(el, name, value, namespace) {
                this.delegate.setAttribute(el, name, value, namespace);
            }, BaseAnimationRenderer.prototype.removeAttribute = function(el, name, namespace) {
                this.delegate.removeAttribute(el, name, namespace);
            }, BaseAnimationRenderer.prototype.addClass = function(el, name) {
                this.delegate.addClass(el, name);
            }, BaseAnimationRenderer.prototype.removeClass = function(el, name) {
                this.delegate.removeClass(el, name);
            }, BaseAnimationRenderer.prototype.setStyle = function(el, style, value, flags) {
                this.delegate.setStyle(el, style, value, flags);
            }, BaseAnimationRenderer.prototype.removeStyle = function(el, style, flags) {
                this.delegate.removeStyle(el, style, flags);
            }, BaseAnimationRenderer.prototype.setProperty = function(el, name, value) {
                "@" == name.charAt(0) && "@.disabled" == name ? this.disableAnimations(el, !!value) : this.delegate.setProperty(el, name, value);
            }, BaseAnimationRenderer.prototype.setValue = function(node, value) {
                this.delegate.setValue(node, value);
            }, BaseAnimationRenderer.prototype.listen = function(target, eventName, callback) {
                return this.delegate.listen(target, eventName, callback);
            }, BaseAnimationRenderer.prototype.disableAnimations = function(element, value) {
                this.engine.disableAnimations(element, value);
            }, BaseAnimationRenderer;
        }(), animations_AnimationRenderer = function(_super) {
            function AnimationRenderer(factory, namespaceId, delegate, engine) {
                var _this = _super.call(this, namespaceId, delegate, engine) || this;
                return _this.factory = factory, _this.namespaceId = namespaceId, _this;
            }
            return __extends(AnimationRenderer, _super), AnimationRenderer.prototype.setProperty = function(el, name, value) {
                "@" == name.charAt(0) ? "." == name.charAt(1) && "@.disabled" == name ? this.disableAnimations(el, value = void 0 === value || !!value) : this.engine.process(this.namespaceId, el, name.substr(1), value) : this.delegate.setProperty(el, name, value);
            }, AnimationRenderer.prototype.listen = function(target, eventName, callback) {
                var _a, triggerName, dotIndex, _this = this;
                if ("@" == eventName.charAt(0)) {
                    var element = function(target) {
                        switch (target) {
                          case "body":
                            return document.body;

                          case "document":
                            return document;

                          case "window":
                            return window;

                          default:
                            return target;
                        }
                    }(target), name_1 = eventName.substr(1), phase = "";
                    return "@" != name_1.charAt(0) && (name_1 = (_a = __read((triggerName = name_1, 
                    dotIndex = triggerName.indexOf("."), [ triggerName.substring(0, dotIndex), triggerName.substr(dotIndex + 1) ]), 2))[0], 
                    phase = _a[1]), this.engine.listen(this.namespaceId, element, name_1, phase, function(event) {
                        _this.factory.scheduleListenerCallback(event._data || -1, callback, event);
                    });
                }
                return this.delegate.listen(target, eventName, callback);
            }, AnimationRenderer;
        }(BaseAnimationRenderer), animations_InjectableAnimationEngine = function(_super) {
            function InjectableAnimationEngine(doc, driver, normalizer) {
                return _super.call(this, doc.body, driver, normalizer) || this;
            }
            return __extends(InjectableAnimationEngine, _super), InjectableAnimationEngine.ngInjectableDef = defineInjectable({
                token: InjectableAnimationEngine,
                factory: function(t) {
                    return new (t || InjectableAnimationEngine)(inject(DOCUMENT), inject(AnimationDriver), inject(AnimationStyleNormalizer));
                },
                providedIn: null
            }), InjectableAnimationEngine;
        }(browser_AnimationEngine), ANIMATION_MODULE_TYPE = new InjectionToken("AnimationModuleType"), BROWSER_ANIMATIONS_PROVIDERS = __spread([ {
            provide: AnimationDriver,
            useFactory: function() {
                return "function" == typeof getElementAnimateFn() ? new WebAnimationsDriver() : new CssKeyframesDriver();
            }
        }, {
            provide: ANIMATION_MODULE_TYPE,
            useValue: "BrowserAnimations"
        } ], [ {
            provide: AnimationBuilder,
            useClass: animations_BrowserAnimationBuilder
        }, {
            provide: AnimationStyleNormalizer,
            useFactory: function() {
                return new browser_WebAnimationsStyleNormalizer();
            }
        }, {
            provide: browser_AnimationEngine,
            useClass: animations_InjectableAnimationEngine
        }, {
            provide: RendererFactory2,
            useFactory: function(renderer, engine, zone) {
                return new animations_AnimationRendererFactory(renderer, engine, zone);
            },
            deps: [ platform_browser_DomRendererFactory2, browser_AnimationEngine, NgZone ]
        } ]), animations_BrowserAnimationsModule = function() {
            function BrowserAnimationsModule() {}
            return BrowserAnimationsModule.ngModuleDef = defineNgModule({
                type: BrowserAnimationsModule
            }), BrowserAnimationsModule.ngInjectorDef = defineInjector({
                factory: function(t) {
                    return new (t || BrowserAnimationsModule)();
                },
                providers: BROWSER_ANIMATIONS_PROVIDERS,
                imports: [ platform_browser_BrowserModule ]
            }), BrowserAnimationsModule;
        }();
        function switchMap(project, resultSelector) {
            return "function" == typeof resultSelector ? function(source) {
                return source.pipe(switchMap(function(a, i) {
                    return from_from(project(a, i)).pipe(map_map(function(b, ii) {
                        return resultSelector(a, b, i, ii);
                    }));
                }));
            } : function(source) {
                return source.lift(new SwitchMapOperator(project));
            };
        }
        var SwitchMapOperator = function() {
            function SwitchMapOperator(project) {
                this.project = project;
            }
            return SwitchMapOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new switchMap_SwitchMapSubscriber(subscriber, this.project));
            }, SwitchMapOperator;
        }(), switchMap_SwitchMapSubscriber = function(_super) {
            function SwitchMapSubscriber(destination, project) {
                var _this = _super.call(this, destination) || this;
                return _this.project = project, _this.index = 0, _this;
            }
            return __extends(SwitchMapSubscriber, _super), SwitchMapSubscriber.prototype._next = function(value) {
                var result, index = this.index++;
                try {
                    result = this.project(value, index);
                } catch (error) {
                    return void this.destination.error(error);
                }
                this._innerSub(result, value, index);
            }, SwitchMapSubscriber.prototype._innerSub = function(result, value, index) {
                var innerSubscription = this.innerSubscription;
                innerSubscription && innerSubscription.unsubscribe();
                var innerSubscriber = new InnerSubscriber_InnerSubscriber(this, void 0, void 0);
                this.destination.add(innerSubscriber), this.innerSubscription = subscribeToResult(this, result, value, index, innerSubscriber);
            }, SwitchMapSubscriber.prototype._complete = function() {
                var innerSubscription = this.innerSubscription;
                innerSubscription && !innerSubscription.closed || _super.prototype._complete.call(this), 
                this.unsubscribe();
            }, SwitchMapSubscriber.prototype._unsubscribe = function() {
                this.innerSubscription = null;
            }, SwitchMapSubscriber.prototype.notifyComplete = function(innerSub) {
                this.destination.remove(innerSub), this.innerSubscription = null, this.isStopped && _super.prototype._complete.call(this);
            }, SwitchMapSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            }, SwitchMapSubscriber;
        }(OuterSubscriber_OuterSubscriber);
        function ArgumentOutOfRangeErrorImpl() {
            return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", 
            this;
        }
        ArgumentOutOfRangeErrorImpl.prototype = Object.create(Error.prototype);
        var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
        function take(count) {
            return function(source) {
                return 0 === count ? empty_empty() : source.lift(new take_TakeOperator(count));
            };
        }
        var take_TakeOperator = function() {
            function TakeOperator(total) {
                if (this.total = total, this.total < 0) throw new ArgumentOutOfRangeError();
            }
            return TakeOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new take_TakeSubscriber(subscriber, this.total));
            }, TakeOperator;
        }(), take_TakeSubscriber = function(_super) {
            function TakeSubscriber(destination, total) {
                var _this = _super.call(this, destination) || this;
                return _this.total = total, _this.count = 0, _this;
            }
            return __extends(TakeSubscriber, _super), TakeSubscriber.prototype._next = function(value) {
                var total = this.total, count = ++this.count;
                count <= total && (this.destination.next(value), count === total && (this.destination.complete(), 
                this.unsubscribe()));
            }, TakeSubscriber;
        }(Subscriber_Subscriber);
        function tap(nextOrObserver, error, complete) {
            return function(source) {
                return source.lift(new DoOperator(nextOrObserver, error, complete));
            };
        }
        var DoOperator = function() {
            function DoOperator(nextOrObserver, error, complete) {
                this.nextOrObserver = nextOrObserver, this.error = error, this.complete = complete;
            }
            return DoOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new tap_TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
            }, DoOperator;
        }(), tap_TapSubscriber = function(_super) {
            function TapSubscriber(destination, observerOrNext, error, complete) {
                var _this = _super.call(this, destination) || this;
                return _this._tapNext = noop, _this._tapError = noop, _this._tapComplete = noop, 
                _this._tapError = error || noop, _this._tapComplete = complete || noop, isFunction(observerOrNext) ? (_this._context = _this, 
                _this._tapNext = observerOrNext) : observerOrNext && (_this._context = observerOrNext, 
                _this._tapNext = observerOrNext.next || noop, _this._tapError = observerOrNext.error || noop, 
                _this._tapComplete = observerOrNext.complete || noop), _this;
            }
            return __extends(TapSubscriber, _super), TapSubscriber.prototype._next = function(value) {
                try {
                    this._tapNext.call(this._context, value);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.next(value);
            }, TapSubscriber.prototype._error = function(err) {
                try {
                    this._tapError.call(this._context, err);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.error(err);
            }, TapSubscriber.prototype._complete = function() {
                try {
                    this._tapComplete.call(this._context);
                } catch (err) {
                    return void this.destination.error(err);
                }
                return this.destination.complete();
            }, TapSubscriber;
        }(Subscriber_Subscriber);
        function defer(observableFactory) {
            return new Observable_Observable(function(subscriber) {
                var input;
                try {
                    input = observableFactory();
                } catch (err) {
                    return void subscriber.error(err);
                }
                return (input ? from_from(input) : empty_empty()).subscribe(subscriber);
            });
        }
        function throwError_throwError(error, scheduler) {
            return new Observable_Observable(scheduler ? function(subscriber) {
                return scheduler.schedule(dispatch, 0, {
                    error: error,
                    subscriber: subscriber
                });
            } : function(subscriber) {
                return subscriber.error(error);
            });
        }
        function dispatch(_a) {
            _a.subscriber.error(_a.error);
        }
        function fromEvent(target, eventName, options, resultSelector) {
            return isFunction(options) && (resultSelector = options, options = void 0), resultSelector ? fromEvent(target, eventName, options).pipe(map_map(function(args) {
                return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
            })) : new Observable_Observable(function(subscriber) {
                !function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
                    var unsubscribe;
                    if (function(sourceObj) {
                        return sourceObj && "function" == typeof sourceObj.addEventListener && "function" == typeof sourceObj.removeEventListener;
                    }(sourceObj)) {
                        var source_1 = sourceObj;
                        sourceObj.addEventListener(eventName, handler, options), unsubscribe = function() {
                            return source_1.removeEventListener(eventName, handler, options);
                        };
                    } else if (function(sourceObj) {
                        return sourceObj && "function" == typeof sourceObj.on && "function" == typeof sourceObj.off;
                    }(sourceObj)) {
                        var source_2 = sourceObj;
                        sourceObj.on(eventName, handler), unsubscribe = function() {
                            return source_2.off(eventName, handler);
                        };
                    } else if (function(sourceObj) {
                        return sourceObj && "function" == typeof sourceObj.addListener && "function" == typeof sourceObj.removeListener;
                    }(sourceObj)) {
                        var source_3 = sourceObj;
                        sourceObj.addListener(eventName, handler), unsubscribe = function() {
                            return source_3.removeListener(eventName, handler);
                        };
                    } else {
                        if (!sourceObj || !sourceObj.length) throw new TypeError("Invalid event target");
                        for (var i = 0, len = sourceObj.length; i < len; i++) setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
                    }
                    subscriber.add(unsubscribe);
                }(target, eventName, function(e) {
                    subscriber.next(arguments.length > 1 ? Array.prototype.slice.call(arguments) : e);
                }, subscriber, options);
            });
        }
        function concat() {
            for (var observables = [], _i = 0; _i < arguments.length; _i++) observables[_i] = arguments[_i];
            return mergeAll(1)(of.apply(void 0, observables));
        }
        var NEVER = new Observable_Observable(noop), ERR_SW_NOT_SUPPORTED = "Service workers are disabled or not supported by this browser", service_worker_NgswCommChannel = function() {
            function NgswCommChannel(serviceWorker) {
                if (this.serviceWorker = serviceWorker, serviceWorker) {
                    var controllerChanges = fromEvent(serviceWorker, "controllerchange").pipe(map_map(function() {
                        return serviceWorker.controller;
                    })), controllerWithChanges = concat(defer(function() {
                        return of(serviceWorker.controller);
                    }), controllerChanges);
                    this.worker = controllerWithChanges.pipe(filter(function(c) {
                        return !!c;
                    })), this.registration = this.worker.pipe(switchMap(function() {
                        return serviceWorker.getRegistration();
                    }));
                    var events = fromEvent(serviceWorker, "message").pipe(map_map(function(event) {
                        return event.data;
                    })).pipe(filter(function(event) {
                        return event && event.type;
                    })).pipe(multicast(new Subject_Subject()));
                    events.connect(), this.events = events;
                } else this.worker = this.events = this.registration = (message = ERR_SW_NOT_SUPPORTED, 
                defer(function() {
                    return throwError_throwError(new Error(message));
                }));
                var message;
            }
            return NgswCommChannel.prototype.postMessage = function(action, payload) {
                return this.worker.pipe(take(1), tap(function(sw) {
                    sw.postMessage(__assign({
                        action: action
                    }, payload));
                })).toPromise().then(function() {});
            }, NgswCommChannel.prototype.postMessageWithStatus = function(type, payload, nonce) {
                var waitForStatus = this.waitForStatus(nonce), postMessage = this.postMessage(type, payload);
                return Promise.all([ waitForStatus, postMessage ]).then(function() {});
            }, NgswCommChannel.prototype.generateNonce = function() {
                return Math.round(1e7 * Math.random());
            }, NgswCommChannel.prototype.eventsOfType = function(type) {
                return this.events.pipe(filter(function(event) {
                    return event.type === type;
                }));
            }, NgswCommChannel.prototype.nextEventOfType = function(type) {
                return this.eventsOfType(type).pipe(take(1));
            }, NgswCommChannel.prototype.waitForStatus = function(nonce) {
                return this.eventsOfType("STATUS").pipe(filter(function(event) {
                    return event.nonce === nonce;
                }), take(1), map_map(function(event) {
                    if (!event.status) throw new Error(event.error);
                })).toPromise();
            }, Object.defineProperty(NgswCommChannel.prototype, "isEnabled", {
                get: function() {
                    return !!this.serviceWorker;
                },
                enumerable: !0,
                configurable: !0
            }), NgswCommChannel;
        }(), service_worker_SwPush = function() {
            function SwPush(sw) {
                if (this.sw = sw, this.subscriptionChanges = new Subject_Subject(), !sw.isEnabled) return this.messages = NEVER, 
                this.notificationClicks = NEVER, void (this.subscription = NEVER);
                this.messages = this.sw.eventsOfType("PUSH").pipe(map_map(function(message) {
                    return message.data;
                })), this.notificationClicks = this.sw.eventsOfType("NOTIFICATION_CLICK").pipe(map_map(function(message) {
                    return message.data;
                })), this.pushManager = this.sw.registration.pipe(map_map(function(registration) {
                    return registration.pushManager;
                }));
                var workerDrivenSubscriptions = this.pushManager.pipe(switchMap(function(pm) {
                    return pm.getSubscription();
                }));
                this.subscription = merge(workerDrivenSubscriptions, this.subscriptionChanges);
            }
            return Object.defineProperty(SwPush.prototype, "isEnabled", {
                get: function() {
                    return this.sw.isEnabled;
                },
                enumerable: !0,
                configurable: !0
            }), SwPush.prototype.requestSubscription = function(options) {
                var _this = this;
                if (!this.sw.isEnabled) return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));
                for (var pushOptions = {
                    userVisibleOnly: !0
                }, key = this.decodeBase64(options.serverPublicKey.replace(/_/g, "/").replace(/-/g, "+")), applicationServerKey = new Uint8Array(new ArrayBuffer(key.length)), i = 0; i < key.length; i++) applicationServerKey[i] = key.charCodeAt(i);
                return pushOptions.applicationServerKey = applicationServerKey, this.pushManager.pipe(switchMap(function(pm) {
                    return pm.subscribe(pushOptions);
                }), take(1)).toPromise().then(function(sub) {
                    return _this.subscriptionChanges.next(sub), sub;
                });
            }, SwPush.prototype.unsubscribe = function() {
                var _this = this;
                return this.sw.isEnabled ? this.subscription.pipe(take(1), switchMap(function(sub) {
                    if (null === sub) throw new Error("Not subscribed to push notifications.");
                    return sub.unsubscribe().then(function(success) {
                        if (!success) throw new Error("Unsubscribe failed!");
                        _this.subscriptionChanges.next(null);
                    });
                })).toPromise() : Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));
            }, SwPush.prototype.decodeBase64 = function(input) {
                return atob(input);
            }, SwPush.ngInjectableDef = defineInjectable({
                token: SwPush,
                factory: function(t) {
                    return new (t || SwPush)(inject(service_worker_NgswCommChannel));
                },
                providedIn: null
            }), SwPush;
        }(), service_worker_SwUpdate = function() {
            function SwUpdate(sw) {
                if (this.sw = sw, !sw.isEnabled) return this.available = NEVER, void (this.activated = NEVER);
                this.available = this.sw.eventsOfType("UPDATE_AVAILABLE"), this.activated = this.sw.eventsOfType("UPDATE_ACTIVATED");
            }
            return Object.defineProperty(SwUpdate.prototype, "isEnabled", {
                get: function() {
                    return this.sw.isEnabled;
                },
                enumerable: !0,
                configurable: !0
            }), SwUpdate.prototype.checkForUpdate = function() {
                if (!this.sw.isEnabled) return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));
                var statusNonce = this.sw.generateNonce();
                return this.sw.postMessageWithStatus("CHECK_FOR_UPDATES", {
                    statusNonce: statusNonce
                }, statusNonce);
            }, SwUpdate.prototype.activateUpdate = function() {
                if (!this.sw.isEnabled) return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));
                var statusNonce = this.sw.generateNonce();
                return this.sw.postMessageWithStatus("ACTIVATE_UPDATE", {
                    statusNonce: statusNonce
                }, statusNonce);
            }, SwUpdate.ngInjectableDef = defineInjectable({
                token: SwUpdate,
                factory: function(t) {
                    return new (t || SwUpdate)(inject(service_worker_NgswCommChannel));
                },
                providedIn: null
            }), SwUpdate;
        }(), RegistrationOptions = function() {
            return function() {};
        }(), SCRIPT = new InjectionToken("NGSW_REGISTER_SCRIPT");
        function ngswAppInitializer(injector, script, options, platformId) {
            return function() {
                var app = injector.get(core_ApplicationRef);
                if (isPlatformBrowser(platformId) && "serviceWorker" in navigator && !1 !== options.enabled) {
                    var whenStable = app.isStable.pipe(filter(function(stable) {
                        return !!stable;
                    }), take(1)).toPromise();
                    navigator.serviceWorker.addEventListener("controllerchange", function() {
                        null !== navigator.serviceWorker.controller && navigator.serviceWorker.controller.postMessage({
                            action: "INITIALIZE"
                        });
                    }), whenStable.then(function() {
                        return navigator.serviceWorker.register(script, {
                            scope: options.scope
                        });
                    });
                }
            };
        }
        function ngswCommChannelFactory(opts, platformId) {
            return new service_worker_NgswCommChannel(isPlatformBrowser(platformId) && !1 !== opts.enabled ? navigator.serviceWorker : void 0);
        }
        var service_worker_ServiceWorkerModule = function() {
            function ServiceWorkerModule() {}
            var ServiceWorkerModule_1;
            return ServiceWorkerModule_1 = ServiceWorkerModule, ServiceWorkerModule.register = function(script, opts) {
                return void 0 === opts && (opts = {}), {
                    ngModule: ServiceWorkerModule_1,
                    providers: [ {
                        provide: SCRIPT,
                        useValue: script
                    }, {
                        provide: RegistrationOptions,
                        useValue: opts
                    }, {
                        provide: service_worker_NgswCommChannel,
                        useFactory: ngswCommChannelFactory,
                        deps: [ RegistrationOptions, PLATFORM_ID ]
                    }, {
                        provide: APP_INITIALIZER,
                        useFactory: ngswAppInitializer,
                        deps: [ Injector, SCRIPT, RegistrationOptions, PLATFORM_ID ],
                        multi: !0
                    } ]
                };
            }, ServiceWorkerModule.ngModuleDef = defineNgModule({
                type: ServiceWorkerModule
            }), ServiceWorkerModule.ngInjectorDef = defineInjector({
                factory: function(t) {
                    return new (t || ServiceWorkerModule)();
                },
                providers: [ service_worker_SwPush, service_worker_SwUpdate ]
            }), ServiceWorkerModule;
        }(), DIR_DOCUMENT = new InjectionToken("cdk-dir-doc", {
            providedIn: "root",
            factory: function() {
                return inject(DOCUMENT);
            }
        }), bidi_es5_Directionality = function() {
            function Directionality(_document) {
                if (this.value = "ltr", this.change = new core_EventEmitter(), _document) {
                    var value = (_document.body ? _document.body.dir : null) || (_document.documentElement ? _document.documentElement.dir : null);
                    this.value = "ltr" === value || "rtl" === value ? value : "ltr";
                }
            }
            return Directionality.prototype.ngOnDestroy = function() {
                this.change.complete();
            }, Directionality.ngInjectableDef = defineInjectable({
                factory: function() {
                    return new Directionality(inject(DIR_DOCUMENT, 8));
                },
                token: Directionality,
                providedIn: "root"
            }), Directionality.ngInjectableDef = defineInjectable({
                token: Directionality,
                factory: function(t) {
                    return new (t || Directionality)(inject(DIR_DOCUMENT, 8));
                },
                providedIn: "root"
            }), Directionality;
        }(), bidi_es5_BidiModule = function() {
            function BidiModule() {}
            return BidiModule.ngModuleDef = defineNgModule({
                type: BidiModule
            }), BidiModule.ngInjectorDef = defineInjector({
                factory: function(t) {
                    return new (t || BidiModule)();
                }
            }), BidiModule;
        }();
        function coerceBooleanProperty(value) {
            return null != value && "" + value != "false";
        }
        function coerceNumberProperty(value, fallbackValue) {
            return void 0 === fallbackValue && (fallbackValue = 0), function(value) {
                return !isNaN(parseFloat(value)) && !isNaN(Number(value));
            }(value) ? Number(value) : fallbackValue;
        }
        var supportsPassiveEvents, hasV8BreakIterator = "undefined" != typeof Intl && Intl.v8BreakIterator, platform_es5_Platform = function() {
            function Platform(_platformId) {
                this._platformId = _platformId, this.isBrowser = this._platformId ? isPlatformBrowser(this._platformId) : "object" == typeof document && !!document, 
                this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), 
                this.BLINK = this.isBrowser && !(!window.chrome && !hasV8BreakIterator) && "undefined" != typeof CSS && !this.EDGE && !this.TRIDENT, 
                this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, 
                this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), 
                this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), 
                this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, 
                this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;
            }
            return Platform.ngInjectableDef = defineInjectable({
                factory: function() {
                    return new Platform(inject(PLATFORM_ID, 8));
                },
                token: Platform,
                providedIn: "root"
            }), Platform.ngInjectableDef = defineInjectable({
                token: Platform,
                factory: function(t) {
                    return new (t || Platform)(inject(PLATFORM_ID, 8));
                },
                providedIn: "root"
            }), Platform;
        }(), platform_es5_PlatformModule = function() {
            function PlatformModule() {}
            return PlatformModule.ngModuleDef = defineNgModule({
                type: PlatformModule
            }), PlatformModule.ngInjectorDef = defineInjector({
                factory: function(t) {
                    return new (t || PlatformModule)();
                }
            }), PlatformModule;
        }();
        function supportsPassiveEventListeners() {
            if (null == supportsPassiveEvents && "undefined" != typeof window) try {
                window.addEventListener("test", null, Object.defineProperty({}, "passive", {
                    get: function() {
                        return supportsPassiveEvents = !0;
                    }
                }));
            } finally {
                supportsPassiveEvents = supportsPassiveEvents || !1;
            }
            return supportsPassiveEvents;
        }
        var rtlScrollAxisType, RtlScrollAxisType = function() {
            var RtlScrollAxisType = {
                NORMAL: 0,
                NEGATED: 1,
                INVERTED: 2
            };
            return RtlScrollAxisType[RtlScrollAxisType.NORMAL] = "NORMAL", RtlScrollAxisType[RtlScrollAxisType.NEGATED] = "NEGATED", 
            RtlScrollAxisType[RtlScrollAxisType.INVERTED] = "INVERTED", RtlScrollAxisType;
        }();
        function getRtlScrollAxisType() {
            if ("object" != typeof document || !document) return RtlScrollAxisType.NORMAL;
            if (!rtlScrollAxisType) {
                var scrollContainer = document.createElement("div"), containerStyle = scrollContainer.style;
                scrollContainer.dir = "rtl", containerStyle.height = "1px", containerStyle.width = "1px", 
                containerStyle.overflow = "auto", containerStyle.visibility = "hidden", containerStyle.pointerEvents = "none", 
                containerStyle.position = "absolute";
                var content = document.createElement("div"), contentStyle = content.style;
                contentStyle.width = "2px", contentStyle.height = "1px", scrollContainer.appendChild(content), 
                document.body.appendChild(scrollContainer), rtlScrollAxisType = RtlScrollAxisType.NORMAL, 
                0 === scrollContainer.scrollLeft && (scrollContainer.scrollLeft = 1, rtlScrollAxisType = 0 === scrollContainer.scrollLeft ? RtlScrollAxisType.NEGATED : RtlScrollAxisType.INVERTED), 
                scrollContainer.parentNode.removeChild(scrollContainer);
            }
            return rtlScrollAxisType;
        }
        var ESCAPE = 27, AsyncAction_AsyncAction = function(_super) {
            function AsyncAction(scheduler, work) {
                var _this = _super.call(this, scheduler, work) || this;
                return _this.scheduler = scheduler, _this.work = work, _this.pending = !1, _this;
            }
            return __extends(AsyncAction, _super), AsyncAction.prototype.schedule = function(state, delay) {
                if (void 0 === delay && (delay = 0), this.closed) return this;
                this.state = state;
                var id = this.id, scheduler = this.scheduler;
                return null != id && (this.id = this.recycleAsyncId(scheduler, id, delay)), this.pending = !0, 
                this.delay = delay, this.id = this.id || this.requestAsyncId(scheduler, this.id, delay), 
                this;
            }, AsyncAction.prototype.requestAsyncId = function(scheduler, id, delay) {
                return void 0 === delay && (delay = 0), setInterval(scheduler.flush.bind(scheduler, this), delay);
            }, AsyncAction.prototype.recycleAsyncId = function(scheduler, id, delay) {
                if (void 0 === delay && (delay = 0), null !== delay && this.delay === delay && !1 === this.pending) return id;
                clearInterval(id);
            }, AsyncAction.prototype.execute = function(state, delay) {
                if (this.closed) return new Error("executing a cancelled action");
                this.pending = !1;
                var error = this._execute(state, delay);
                if (error) return error;
                !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
            }, AsyncAction.prototype._execute = function(state, delay) {
                var errored = !1, errorValue = void 0;
                try {
                    this.work(state);
                } catch (e) {
                    errored = !0, errorValue = !!e && e || new Error(e);
                }
                if (errored) return this.unsubscribe(), errorValue;
            }, AsyncAction.prototype._unsubscribe = function() {
                var id = this.id, scheduler = this.scheduler, actions = scheduler.actions, index = actions.indexOf(this);
                this.work = null, this.state = null, this.pending = !1, this.scheduler = null, -1 !== index && actions.splice(index, 1), 
                null != id && (this.id = this.recycleAsyncId(scheduler, id, null)), this.delay = null;
            }, AsyncAction;
        }(function(_super) {
            function Action(scheduler, work) {
                return _super.call(this) || this;
            }
            return __extends(Action, _super), Action.prototype.schedule = function(state, delay) {
                return void 0 === delay && (delay = 0), this;
            }, Action;
        }(Subscription_Subscription)), Scheduler = function() {
            function Scheduler(SchedulerAction, now) {
                void 0 === now && (now = Scheduler.now), this.SchedulerAction = SchedulerAction, 
                this.now = now;
            }
            return Scheduler.prototype.schedule = function(work, delay, state) {
                return void 0 === delay && (delay = 0), new this.SchedulerAction(this, work).schedule(state, delay);
            }, Scheduler.now = function() {
                return Date.now();
            }, Scheduler;
        }(), AsyncScheduler_AsyncScheduler = function(_super) {
            function AsyncScheduler(SchedulerAction, now) {
                void 0 === now && (now = Scheduler.now);
                var _this = _super.call(this, SchedulerAction, function() {
                    return AsyncScheduler.delegate && AsyncScheduler.delegate !== _this ? AsyncScheduler.delegate.now() : now();
                }) || this;
                return _this.actions = [], _this.active = !1, _this.scheduled = void 0, _this;
            }
            return __extends(AsyncScheduler, _super), AsyncScheduler.prototype.schedule = function(work, delay, state) {
                return void 0 === delay && (delay = 0), AsyncScheduler.delegate && AsyncScheduler.delegate !== this ? AsyncScheduler.delegate.schedule(work, delay, state) : _super.prototype.schedule.call(this, work, delay, state);
            }, AsyncScheduler.prototype.flush = function(action) {
                var actions = this.actions;
                if (this.active) actions.push(action); else {
                    var error;
                    this.active = !0;
                    do {
                        if (error = action.execute(action.state, action.delay)) break;
                    } while (action = actions.shift());
                    if (this.active = !1, error) {
                        for (;action = actions.shift(); ) action.unsubscribe();
                        throw error;
                    }
                }
            }, AsyncScheduler;
        }(Scheduler), async_async = new AsyncScheduler_AsyncScheduler(AsyncAction_AsyncAction);
        function debounceTime(dueTime, scheduler) {
            return void 0 === scheduler && (scheduler = async_async), function(source) {
                return source.lift(new DebounceTimeOperator(dueTime, scheduler));
            };
        }
        var DebounceTimeOperator = function() {
            function DebounceTimeOperator(dueTime, scheduler) {
                this.dueTime = dueTime, this.scheduler = scheduler;
            }
            return DebounceTimeOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new debounceTime_DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
            }, DebounceTimeOperator;
        }(), debounceTime_DebounceTimeSubscriber = function(_super) {
            function DebounceTimeSubscriber(destination, dueTime, scheduler) {
                var _this = _super.call(this, destination) || this;
                return _this.dueTime = dueTime, _this.scheduler = scheduler, _this.debouncedSubscription = null, 
                _this.lastValue = null, _this.hasValue = !1, _this;
            }
            return __extends(DebounceTimeSubscriber, _super), DebounceTimeSubscriber.prototype._next = function(value) {
                this.clearDebounce(), this.lastValue = value, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
            }, DebounceTimeSubscriber.prototype._complete = function() {
                this.debouncedNext(), this.destination.complete();
            }, DebounceTimeSubscriber.prototype.debouncedNext = function() {
                if (this.clearDebounce(), this.hasValue) {
                    var lastValue = this.lastValue;
                    this.lastValue = null, this.hasValue = !1, this.destination.next(lastValue);
                }
            }, DebounceTimeSubscriber.prototype.clearDebounce = function() {
                var debouncedSubscription = this.debouncedSubscription;
                null !== debouncedSubscription && (this.remove(debouncedSubscription), debouncedSubscription.unsubscribe(), 
                this.debouncedSubscription = null);
            }, DebounceTimeSubscriber;
        }(Subscriber_Subscriber);
        function dispatchNext(subscriber) {
            subscriber.debouncedNext();
        }
        var a11y_es5_InteractivityChecker = function() {
            function InteractivityChecker(_platform) {
                this._platform = _platform;
            }
            return InteractivityChecker.prototype.isDisabled = function(element) {
                return element.hasAttribute("disabled");
            }, InteractivityChecker.prototype.isVisible = function(element) {
                return function(element) {
                    return !!(element.offsetWidth || element.offsetHeight || "function" == typeof element.getClientRects && element.getClientRects().length);
                }(element) && "visible" === getComputedStyle(element).visibility;
            }, InteractivityChecker.prototype.isTabbable = function(element) {
                if (!this._platform.isBrowser) return !1;
                var node, frameElement = function(window) {
                    try {
                        return window.frameElement;
                    } catch (e) {
                        return null;
                    }
                }((node = element).ownerDocument && node.ownerDocument.defaultView || window);
                if (frameElement) {
                    var frameType = frameElement && frameElement.nodeName.toLowerCase();
                    if (-1 === getTabIndexValue(frameElement)) return !1;
                    if ((this._platform.BLINK || this._platform.WEBKIT) && "object" === frameType) return !1;
                    if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) return !1;
                }
                var nodeName = element.nodeName.toLowerCase(), tabIndexValue = getTabIndexValue(element);
                if (element.hasAttribute("contenteditable")) return -1 !== tabIndexValue;
                if ("iframe" === nodeName) return !1;
                if ("audio" === nodeName) {
                    if (!element.hasAttribute("controls")) return !1;
                    if (this._platform.BLINK) return !0;
                }
                if ("video" === nodeName) {
                    if (!element.hasAttribute("controls") && this._platform.TRIDENT) return !1;
                    if (this._platform.BLINK || this._platform.FIREFOX) return !0;
                }
                return ("object" !== nodeName || !this._platform.BLINK && !this._platform.WEBKIT) && !(this._platform.WEBKIT && this._platform.IOS && !function(element) {
                    var nodeName = element.nodeName.toLowerCase(), inputType = "input" === nodeName && element.type;
                    return "text" === inputType || "password" === inputType || "select" === nodeName || "textarea" === nodeName;
                }(element)) && element.tabIndex >= 0;
            }, InteractivityChecker.prototype.isFocusable = function(element) {
                return function(element) {
                    return !function(element) {
                        return function(element) {
                            return "input" == element.nodeName.toLowerCase();
                        }(element) && "hidden" == element.type;
                    }(element) && (function(element) {
                        var nodeName = element.nodeName.toLowerCase();
                        return "input" === nodeName || "select" === nodeName || "button" === nodeName || "textarea" === nodeName;
                    }(element) || function(element) {
                        return function(element) {
                            return "a" == element.nodeName.toLowerCase();
                        }(element) && element.hasAttribute("href");
                    }(element) || element.hasAttribute("contenteditable") || hasValidTabIndex(element));
                }(element) && !this.isDisabled(element) && this.isVisible(element);
            }, InteractivityChecker.ngInjectableDef = defineInjectable({
                factory: function() {
                    return new InteractivityChecker(inject(platform_es5_Platform));
                },
                token: InteractivityChecker,
                providedIn: "root"
            }), InteractivityChecker.ngInjectableDef = defineInjectable({
                token: InteractivityChecker,
                factory: function(t) {
                    return new (t || InteractivityChecker)(inject(platform_es5_Platform));
                },
                providedIn: "root"
            }), InteractivityChecker;
        }();
        function hasValidTabIndex(element) {
            if (!element.hasAttribute("tabindex") || void 0 === element.tabIndex) return !1;
            var tabIndex = element.getAttribute("tabindex");
            return "-32768" != tabIndex && !(!tabIndex || isNaN(parseInt(tabIndex, 10)));
        }
        function getTabIndexValue(element) {
            if (!hasValidTabIndex(element)) return null;
            var tabIndex = parseInt(element.getAttribute("tabindex") || "", 10);
            return isNaN(tabIndex) ? -1 : tabIndex;
        }
        var a11y_es5_FocusTrap = function() {
            function FocusTrap(_element, _checker, _ngZone, _document, deferAnchors) {
                void 0 === deferAnchors && (deferAnchors = !1), this._element = _element, this._checker = _checker, 
                this._ngZone = _ngZone, this._document = _document, this._hasAttached = !1, this._enabled = !0, 
                deferAnchors || this.attachAnchors();
            }
            return Object.defineProperty(FocusTrap.prototype, "enabled", {
                get: function() {
                    return this._enabled;
                },
                set: function(value) {
                    this._enabled = value, this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(value, this._startAnchor), 
                    this._toggleAnchorTabIndex(value, this._endAnchor));
                },
                enumerable: !0,
                configurable: !0
            }), FocusTrap.prototype.destroy = function() {
                this._startAnchor && this._startAnchor.parentNode && this._startAnchor.parentNode.removeChild(this._startAnchor), 
                this._endAnchor && this._endAnchor.parentNode && this._endAnchor.parentNode.removeChild(this._endAnchor), 
                this._startAnchor = this._endAnchor = null;
            }, FocusTrap.prototype.attachAnchors = function() {
                var _this = this;
                return !!this._hasAttached || (this._ngZone.runOutsideAngular(function() {
                    _this._startAnchor || (_this._startAnchor = _this._createAnchor(), _this._startAnchor.addEventListener("focus", function() {
                        return _this.focusLastTabbableElement();
                    })), _this._endAnchor || (_this._endAnchor = _this._createAnchor(), _this._endAnchor.addEventListener("focus", function() {
                        return _this.focusFirstTabbableElement();
                    }));
                }), this._element.parentNode && (this._element.parentNode.insertBefore(this._startAnchor, this._element), 
                this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling), 
                this._hasAttached = !0), this._hasAttached);
            }, FocusTrap.prototype.focusInitialElementWhenReady = function() {
                var _this = this;
                return new Promise(function(resolve) {
                    _this._executeOnStable(function() {
                        return resolve(_this.focusInitialElement());
                    });
                });
            }, FocusTrap.prototype.focusFirstTabbableElementWhenReady = function() {
                var _this = this;
                return new Promise(function(resolve) {
                    _this._executeOnStable(function() {
                        return resolve(_this.focusFirstTabbableElement());
                    });
                });
            }, FocusTrap.prototype.focusLastTabbableElementWhenReady = function() {
                var _this = this;
                return new Promise(function(resolve) {
                    _this._executeOnStable(function() {
                        return resolve(_this.focusLastTabbableElement());
                    });
                });
            }, FocusTrap.prototype._getRegionBoundary = function(bound) {
                for (var markers = this._element.querySelectorAll("[cdk-focus-region-" + bound + "], [cdkFocusRegion" + bound + "], [cdk-focus-" + bound + "]"), i = 0; i < markers.length; i++) markers[i].hasAttribute("cdk-focus-" + bound) ? console.warn("Found use of deprecated attribute 'cdk-focus-" + bound + "', use 'cdkFocusRegion" + bound + "' instead. The deprecated attribute will be removed in 8.0.0.", markers[i]) : markers[i].hasAttribute("cdk-focus-region-" + bound) && console.warn("Found use of deprecated attribute 'cdk-focus-region-" + bound + "', use 'cdkFocusRegion" + bound + "' instead. The deprecated attribute will be removed in 8.0.0.", markers[i]);
                return "start" == bound ? markers.length ? markers[0] : this._getFirstTabbableElement(this._element) : markers.length ? markers[markers.length - 1] : this._getLastTabbableElement(this._element);
            }, FocusTrap.prototype.focusInitialElement = function() {
                var redirectToElement = this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]");
                return redirectToElement ? (redirectToElement.hasAttribute("cdk-focus-initial") && console.warn("Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0", redirectToElement), 
                redirectToElement.focus(), !0) : this.focusFirstTabbableElement();
            }, FocusTrap.prototype.focusFirstTabbableElement = function() {
                var redirectToElement = this._getRegionBoundary("start");
                return redirectToElement && redirectToElement.focus(), !!redirectToElement;
            }, FocusTrap.prototype.focusLastTabbableElement = function() {
                var redirectToElement = this._getRegionBoundary("end");
                return redirectToElement && redirectToElement.focus(), !!redirectToElement;
            }, FocusTrap.prototype.hasAttached = function() {
                return this._hasAttached;
            }, FocusTrap.prototype._getFirstTabbableElement = function(root) {
                if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) return root;
                for (var children = root.children || root.childNodes, i = 0; i < children.length; i++) {
                    var tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(children[i]) : null;
                    if (tabbableChild) return tabbableChild;
                }
                return null;
            }, FocusTrap.prototype._getLastTabbableElement = function(root) {
                if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) return root;
                for (var children = root.children || root.childNodes, i = children.length - 1; i >= 0; i--) {
                    var tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(children[i]) : null;
                    if (tabbableChild) return tabbableChild;
                }
                return null;
            }, FocusTrap.prototype._createAnchor = function() {
                var anchor = this._document.createElement("div");
                return this._toggleAnchorTabIndex(this._enabled, anchor), anchor.classList.add("cdk-visually-hidden"), 
                anchor.classList.add("cdk-focus-trap-anchor"), anchor;
            }, FocusTrap.prototype._toggleAnchorTabIndex = function(isEnabled, anchor) {
                isEnabled ? anchor.setAttribute("tabindex", "0") : anchor.removeAttribute("tabindex");
            }, FocusTrap.prototype._executeOnStable = function(fn) {
                this._ngZone.isStable ? fn() : this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(fn);
            }, FocusTrap;
        }(), a11y_es5_FocusTrapFactory = function() {
            function FocusTrapFactory(_checker, _ngZone, _document) {
                this._checker = _checker, this._ngZone = _ngZone, this._document = _document;
            }
            return FocusTrapFactory.prototype.create = function(element, deferCaptureElements) {
                return void 0 === deferCaptureElements && (deferCaptureElements = !1), new a11y_es5_FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);
            }, FocusTrapFactory.ngInjectableDef = defineInjectable({
                factory: function() {
                    return new FocusTrapFactory(inject(a11y_es5_InteractivityChecker), inject(NgZone), inject(DOCUMENT));
                },
                token: FocusTrapFactory,
                providedIn: "root"
            }), FocusTrapFactory.ngInjectableDef = defineInjectable({
                token: FocusTrapFactory,
                factory: function(t) {
                    return new (t || FocusTrapFactory)(inject(a11y_es5_InteractivityChecker), inject(NgZone), inject(DOCUMENT));
                },
                providedIn: "root"
            }), FocusTrapFactory;
        }(), a11y_es5_FocusMonitor = function() {
            function FocusMonitor(_ngZone, _platform) {
                this._ngZone = _ngZone, this._platform = _platform, this._origin = null, this._windowFocused = !1, 
                this._elementInfo = new Map(), this._unregisterGlobalListeners = function() {}, 
                this._monitoredElementCount = 0;
            }
            return FocusMonitor.prototype.monitor = function(element, checkChildren) {
                var _this = this;
                if (void 0 === checkChildren && (checkChildren = !1), !this._platform.isBrowser) return of(null);
                var nativeElement = this._getNativeElement(element);
                if (this._elementInfo.has(nativeElement)) {
                    var cachedInfo = this._elementInfo.get(nativeElement);
                    return cachedInfo.checkChildren = checkChildren, cachedInfo.subject.asObservable();
                }
                var info = {
                    unlisten: function() {},
                    checkChildren: checkChildren,
                    subject: new Subject_Subject()
                };
                this._elementInfo.set(nativeElement, info), this._incrementMonitoredElementCount();
                var focusListener = function(event) {
                    return _this._onFocus(event, nativeElement);
                }, blurListener = function(event) {
                    return _this._onBlur(event, nativeElement);
                };
                return this._ngZone.runOutsideAngular(function() {
                    nativeElement.addEventListener("focus", focusListener, !0), nativeElement.addEventListener("blur", blurListener, !0);
                }), info.unlisten = function() {
                    nativeElement.removeEventListener("focus", focusListener, !0), nativeElement.removeEventListener("blur", blurListener, !0);
                }, info.subject.asObservable();
            }, FocusMonitor.prototype.stopMonitoring = function(element) {
                var nativeElement = this._getNativeElement(element), elementInfo = this._elementInfo.get(nativeElement);
                elementInfo && (elementInfo.unlisten(), elementInfo.subject.complete(), this._setClasses(nativeElement), 
                this._elementInfo.delete(nativeElement), this._decrementMonitoredElementCount());
            }, FocusMonitor.prototype.focusVia = function(element, origin, options) {
                var nativeElement = this._getNativeElement(element);
                this._setOriginForCurrentEventQueue(origin), "function" == typeof nativeElement.focus && nativeElement.focus(options);
            }, FocusMonitor.prototype.ngOnDestroy = function() {
                var _this = this;
                this._elementInfo.forEach(function(_info, element) {
                    return _this.stopMonitoring(element);
                });
            }, FocusMonitor.prototype._registerGlobalListeners = function() {
                var _this = this;
                if (this._platform.isBrowser) {
                    var documentKeydownListener = function() {
                        _this._lastTouchTarget = null, _this._setOriginForCurrentEventQueue("keyboard");
                    }, documentMousedownListener = function() {
                        _this._lastTouchTarget || _this._setOriginForCurrentEventQueue("mouse");
                    }, documentTouchstartListener = function(event) {
                        null != _this._touchTimeoutId && clearTimeout(_this._touchTimeoutId), _this._lastTouchTarget = event.target, 
                        _this._touchTimeoutId = setTimeout(function() {
                            return _this._lastTouchTarget = null;
                        }, 650);
                    }, windowFocusListener = function() {
                        _this._windowFocused = !0, _this._windowFocusTimeoutId = setTimeout(function() {
                            return _this._windowFocused = !1;
                        });
                    };
                    this._ngZone.runOutsideAngular(function() {
                        document.addEventListener("keydown", documentKeydownListener, !0), document.addEventListener("mousedown", documentMousedownListener, !0), 
                        document.addEventListener("touchstart", documentTouchstartListener, !supportsPassiveEventListeners() || {
                            passive: !0,
                            capture: !0
                        }), window.addEventListener("focus", windowFocusListener);
                    }), this._unregisterGlobalListeners = function() {
                        document.removeEventListener("keydown", documentKeydownListener, !0), document.removeEventListener("mousedown", documentMousedownListener, !0), 
                        document.removeEventListener("touchstart", documentTouchstartListener, !supportsPassiveEventListeners() || {
                            passive: !0,
                            capture: !0
                        }), window.removeEventListener("focus", windowFocusListener), clearTimeout(_this._windowFocusTimeoutId), 
                        clearTimeout(_this._touchTimeoutId), clearTimeout(_this._originTimeoutId);
                    };
                }
            }, FocusMonitor.prototype._toggleClass = function(element, className, shouldSet) {
                shouldSet ? element.classList.add(className) : element.classList.remove(className);
            }, FocusMonitor.prototype._setClasses = function(element, origin) {
                this._elementInfo.get(element) && (this._toggleClass(element, "cdk-focused", !!origin), 
                this._toggleClass(element, "cdk-touch-focused", "touch" === origin), this._toggleClass(element, "cdk-keyboard-focused", "keyboard" === origin), 
                this._toggleClass(element, "cdk-mouse-focused", "mouse" === origin), this._toggleClass(element, "cdk-program-focused", "program" === origin));
            }, FocusMonitor.prototype._setOriginForCurrentEventQueue = function(origin) {
                var _this = this;
                this._ngZone.runOutsideAngular(function() {
                    _this._origin = origin, _this._originTimeoutId = setTimeout(function() {
                        return _this._origin = null;
                    }, 1);
                });
            }, FocusMonitor.prototype._wasCausedByTouch = function(event) {
                var focusTarget = event.target;
                return this._lastTouchTarget instanceof Node && focusTarget instanceof Node && (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));
            }, FocusMonitor.prototype._onFocus = function(event, element) {
                var elementInfo = this._elementInfo.get(element);
                if (elementInfo && (elementInfo.checkChildren || element === event.target)) {
                    var origin = this._origin;
                    origin || (origin = this._windowFocused && this._lastFocusOrigin ? this._lastFocusOrigin : this._wasCausedByTouch(event) ? "touch" : "program"), 
                    this._setClasses(element, origin), this._emitOrigin(elementInfo.subject, origin), 
                    this._lastFocusOrigin = origin;
                }
            }, FocusMonitor.prototype._onBlur = function(event, element) {
                var elementInfo = this._elementInfo.get(element);
                !elementInfo || elementInfo.checkChildren && event.relatedTarget instanceof Node && element.contains(event.relatedTarget) || (this._setClasses(element), 
                this._emitOrigin(elementInfo.subject, null));
            }, FocusMonitor.prototype._emitOrigin = function(subject, origin) {
                this._ngZone.run(function() {
                    return subject.next(origin);
                });
            }, FocusMonitor.prototype._incrementMonitoredElementCount = function() {
                1 == ++this._monitoredElementCount && this._registerGlobalListeners();
            }, FocusMonitor.prototype._decrementMonitoredElementCount = function() {
                --this._monitoredElementCount || (this._unregisterGlobalListeners(), this._unregisterGlobalListeners = function() {});
            }, FocusMonitor.prototype._getNativeElement = function(element) {
                return element instanceof ElementRef ? element.nativeElement : element;
            }, FocusMonitor.ngInjectableDef = defineInjectable({
                factory: function() {
                    return new FocusMonitor(inject(NgZone), inject(platform_es5_Platform));
                },
                token: FocusMonitor,
                providedIn: "root"
            }), FocusMonitor.ngInjectableDef = defineInjectable({
                token: FocusMonitor,
                factory: function(t) {
                    return new (t || FocusMonitor)(inject(NgZone), inject(platform_es5_Platform));
                },
                providedIn: "root"
            }), FocusMonitor;
        }();
        const _c1 = [ 1, "mat-ripple" ], _c2 = [ "mat-ripple-unbounded" ];
        var MATERIAL_SANITY_CHECKS = new InjectionToken("mat-sanity-checks", {
            providedIn: "root",
            factory: function() {
                return !0;
            }
        }), core_es5_MatCommonModule = function() {
            function MatCommonModule(_sanityChecksEnabled, _hammerLoader) {
                this._sanityChecksEnabled = _sanityChecksEnabled, this._hammerLoader = _hammerLoader, 
                this._hasDoneGlobalChecks = !1, this._hasCheckedHammer = !1, this._document = "object" == typeof document && document ? document : null, 
                this._window = "object" == typeof window && window ? window : null, this._areChecksEnabled() && !this._hasDoneGlobalChecks && (this._checkDoctypeIsDefined(), 
                this._checkThemeIsPresent(), this._hasDoneGlobalChecks = !0);
            }
            return MatCommonModule.prototype._areChecksEnabled = function() {
                return this._sanityChecksEnabled && isDevMode() && !this._isTestEnv();
            }, MatCommonModule.prototype._isTestEnv = function() {
                var window = this._window;
                return window && (window.__karma__ || window.jasmine);
            }, MatCommonModule.prototype._checkDoctypeIsDefined = function() {
                this._document && !this._document.doctype && console.warn("Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.");
            }, MatCommonModule.prototype._checkThemeIsPresent = function() {
                if (this._document && this._document.body && "function" == typeof getComputedStyle) {
                    var testElement = this._document.createElement("div");
                    testElement.classList.add("mat-theme-loaded-marker"), this._document.body.appendChild(testElement);
                    var computedStyle = getComputedStyle(testElement);
                    computedStyle && "none" !== computedStyle.display && console.warn("Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming"), 
                    this._document.body.removeChild(testElement);
                }
            }, MatCommonModule.prototype._checkHammerIsAvailable = function() {
                !this._hasCheckedHammer && this._window && (!this._areChecksEnabled() || this._window.Hammer || this._hammerLoader || console.warn("Could not find HammerJS. Certain Angular Material components may not work correctly."), 
                this._hasCheckedHammer = !0);
            }, MatCommonModule.ngModuleDef = defineNgModule({
                type: MatCommonModule
            }), MatCommonModule.ngInjectorDef = defineInjector({
                factory: function(t) {
                    return new (t || MatCommonModule)(inject(MATERIAL_SANITY_CHECKS, 8), inject(HAMMER_LOADER, 8));
                },
                imports: [ [ bidi_es5_BidiModule ], bidi_es5_BidiModule ]
            }), MatCommonModule;
        }();
        function mixinDisabled(base) {
            return function(_super) {
                function class_1() {
                    for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
                    var _this = _super.apply(this, args) || this;
                    return _this._disabled = !1, _this;
                }
                return __extends(class_1, _super), Object.defineProperty(class_1.prototype, "disabled", {
                    get: function() {
                        return this._disabled;
                    },
                    set: function(value) {
                        this._disabled = coerceBooleanProperty(value);
                    },
                    enumerable: !0,
                    configurable: !0
                }), class_1;
            }(base);
        }
        function mixinColor(base, defaultColor) {
            return function(_super) {
                function class_1() {
                    for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
                    var _this = _super.apply(this, args) || this;
                    return _this.color = defaultColor, _this;
                }
                return __extends(class_1, _super), Object.defineProperty(class_1.prototype, "color", {
                    get: function() {
                        return this._color;
                    },
                    set: function(value) {
                        var colorPalette = value || defaultColor;
                        colorPalette !== this._color && (this._color && this._elementRef.nativeElement.classList.remove("mat-" + this._color), 
                        colorPalette && this._elementRef.nativeElement.classList.add("mat-" + colorPalette), 
                        this._color = colorPalette);
                    },
                    enumerable: !0,
                    configurable: !0
                }), class_1;
            }(base);
        }
        function mixinDisableRipple(base) {
            return function(_super) {
                function class_1() {
                    for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
                    var _this = _super.apply(this, args) || this;
                    return _this._disableRipple = !1, _this;
                }
                return __extends(class_1, _super), Object.defineProperty(class_1.prototype, "disableRipple", {
                    get: function() {
                        return this._disableRipple;
                    },
                    set: function(value) {
                        this._disableRipple = coerceBooleanProperty(value);
                    },
                    enumerable: !0,
                    configurable: !0
                }), class_1;
            }(base);
        }
        var RippleState = function() {
            var RippleState = {
                FADING_IN: 0,
                VISIBLE: 1,
                FADING_OUT: 2,
                HIDDEN: 3
            };
            return RippleState[RippleState.FADING_IN] = "FADING_IN", RippleState[RippleState.VISIBLE] = "VISIBLE", 
            RippleState[RippleState.FADING_OUT] = "FADING_OUT", RippleState[RippleState.HIDDEN] = "HIDDEN", 
            RippleState;
        }(), RippleRef = function() {
            function RippleRef(_renderer, element, config) {
                this._renderer = _renderer, this.element = element, this.config = config, this.state = RippleState.HIDDEN;
            }
            return RippleRef.prototype.fadeOut = function() {
                this._renderer.fadeOutRipple(this);
            }, RippleRef;
        }(), defaultRippleAnimationConfig = {
            enterDuration: 450,
            exitDuration: 400
        }, ignoreMouseEventsTimeout = 800, core_es5_RippleRenderer = function() {
            function RippleRenderer(_target, _ngZone, elementRef, platform) {
                var _this = this;
                this._target = _target, this._ngZone = _ngZone, this._isPointerDown = !1, this._triggerEvents = new Map(), 
                this._activeRipples = new Set(), this._eventOptions = !!supportsPassiveEventListeners() && {
                    passive: !0
                }, this.onMousedown = function(event) {
                    var isFakeMousedown = function(event) {
                        return 0 === event.buttons;
                    }(event), isSyntheticEvent = _this._lastTouchStartEvent && Date.now() < _this._lastTouchStartEvent + ignoreMouseEventsTimeout;
                    _this._target.rippleDisabled || isFakeMousedown || isSyntheticEvent || (_this._isPointerDown = !0, 
                    _this.fadeInRipple(event.clientX, event.clientY, _this._target.rippleConfig));
                }, this.onTouchStart = function(event) {
                    if (!_this._target.rippleDisabled) {
                        _this._lastTouchStartEvent = Date.now(), _this._isPointerDown = !0;
                        for (var touches = event.changedTouches, i = 0; i < touches.length; i++) _this.fadeInRipple(touches[i].clientX, touches[i].clientY, _this._target.rippleConfig);
                    }
                }, this.onPointerUp = function() {
                    _this._isPointerDown && (_this._isPointerDown = !1, _this._activeRipples.forEach(function(ripple) {
                        !ripple.config.persistent && (ripple.state === RippleState.VISIBLE || ripple.config.terminateOnPointerUp && ripple.state === RippleState.FADING_IN) && ripple.fadeOut();
                    }));
                }, platform.isBrowser && (this._containerElement = elementRef.nativeElement, this._triggerEvents.set("mousedown", this.onMousedown).set("mouseup", this.onPointerUp).set("mouseleave", this.onPointerUp).set("touchstart", this.onTouchStart).set("touchend", this.onPointerUp).set("touchcancel", this.onPointerUp));
            }
            return RippleRenderer.prototype.fadeInRipple = function(x, y, config) {
                var _this = this;
                void 0 === config && (config = {});
                var containerRect = this._containerRect = this._containerRect || this._containerElement.getBoundingClientRect(), animationConfig = __assign({}, defaultRippleAnimationConfig, config.animation);
                config.centered && (x = containerRect.left + containerRect.width / 2, y = containerRect.top + containerRect.height / 2);
                var radius = config.radius || function(x, y, rect) {
                    var distX = Math.max(Math.abs(x - rect.left), Math.abs(x - rect.right)), distY = Math.max(Math.abs(y - rect.top), Math.abs(y - rect.bottom));
                    return Math.sqrt(distX * distX + distY * distY);
                }(x, y, containerRect), offsetX = x - containerRect.left, offsetY = y - containerRect.top, duration = animationConfig.enterDuration, ripple = document.createElement("div");
                ripple.classList.add("mat-ripple-element"), ripple.style.left = offsetX - radius + "px", 
                ripple.style.top = offsetY - radius + "px", ripple.style.height = 2 * radius + "px", 
                ripple.style.width = 2 * radius + "px", ripple.style.backgroundColor = config.color || null, 
                ripple.style.transitionDuration = duration + "ms", this._containerElement.appendChild(ripple), 
                window.getComputedStyle(ripple).getPropertyValue("opacity"), ripple.style.transform = "scale(1)";
                var rippleRef = new RippleRef(this, ripple, config);
                return rippleRef.state = RippleState.FADING_IN, this._activeRipples.add(rippleRef), 
                config.persistent || (this._mostRecentTransientRipple = rippleRef), this.runTimeoutOutsideZone(function() {
                    var isMostRecentTransientRipple = rippleRef === _this._mostRecentTransientRipple;
                    rippleRef.state = RippleState.VISIBLE, config.persistent || isMostRecentTransientRipple && _this._isPointerDown || rippleRef.fadeOut();
                }, duration), rippleRef;
            }, RippleRenderer.prototype.fadeOutRipple = function(rippleRef) {
                var wasActive = this._activeRipples.delete(rippleRef);
                if (rippleRef === this._mostRecentTransientRipple && (this._mostRecentTransientRipple = null), 
                this._activeRipples.size || (this._containerRect = null), wasActive) {
                    var rippleEl = rippleRef.element, animationConfig = __assign({}, defaultRippleAnimationConfig, rippleRef.config.animation);
                    rippleEl.style.transitionDuration = animationConfig.exitDuration + "ms", rippleEl.style.opacity = "0", 
                    rippleRef.state = RippleState.FADING_OUT, this.runTimeoutOutsideZone(function() {
                        rippleRef.state = RippleState.HIDDEN, rippleEl.parentNode.removeChild(rippleEl);
                    }, animationConfig.exitDuration);
                }
            }, RippleRenderer.prototype.fadeOutAll = function() {
                this._activeRipples.forEach(function(ripple) {
                    return ripple.fadeOut();
                });
            }, RippleRenderer.prototype.setupTriggerEvents = function(element) {
                var _this = this;
                element && element !== this._triggerElement && (this._removeTriggerEvents(), this._ngZone.runOutsideAngular(function() {
                    _this._triggerEvents.forEach(function(fn, type) {
                        return element.addEventListener(type, fn, _this._eventOptions);
                    });
                }), this._triggerElement = element);
            }, RippleRenderer.prototype.runTimeoutOutsideZone = function(fn, delay) {
                void 0 === delay && (delay = 0), this._ngZone.runOutsideAngular(function() {
                    return setTimeout(fn, delay);
                });
            }, RippleRenderer.prototype._removeTriggerEvents = function() {
                var _this = this;
                this._triggerElement && this._triggerEvents.forEach(function(fn, type) {
                    _this._triggerElement.removeEventListener(type, fn, _this._eventOptions);
                });
            }, RippleRenderer;
        }(), MAT_RIPPLE_GLOBAL_OPTIONS = new InjectionToken("mat-ripple-global-options"), core_es5_MatRipple = function() {
            function MatRipple(_elementRef, ngZone, platform, globalOptions, animationMode) {
                this._elementRef = _elementRef, this.radius = 0, this._disabled = !1, this._isInitialized = !1, 
                this._globalOptions = globalOptions || {}, this._rippleRenderer = new core_es5_RippleRenderer(this, ngZone, _elementRef, platform), 
                "NoopAnimations" === animationMode && (this._globalOptions.animation = {
                    enterDuration: 0,
                    exitDuration: 0
                });
            }
            return Object.defineProperty(MatRipple.prototype, "disabled", {
                get: function() {
                    return this._disabled;
                },
                set: function(value) {
                    this._disabled = value, this._setupTriggerEventsIfEnabled();
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(MatRipple.prototype, "trigger", {
                get: function() {
                    return this._trigger || this._elementRef.nativeElement;
                },
                set: function(trigger) {
                    this._trigger = trigger, this._setupTriggerEventsIfEnabled();
                },
                enumerable: !0,
                configurable: !0
            }), MatRipple.prototype.ngOnInit = function() {
                this._isInitialized = !0, this._setupTriggerEventsIfEnabled();
            }, MatRipple.prototype.ngOnDestroy = function() {
                this._rippleRenderer._removeTriggerEvents();
            }, MatRipple.prototype.fadeOutAll = function() {
                this._rippleRenderer.fadeOutAll();
            }, Object.defineProperty(MatRipple.prototype, "rippleConfig", {
                get: function() {
                    return {
                        centered: this.centered,
                        radius: this.radius,
                        color: this.color,
                        animation: __assign({}, this._globalOptions.animation, this.animation),
                        terminateOnPointerUp: this._globalOptions.terminateOnPointerUp
                    };
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(MatRipple.prototype, "rippleDisabled", {
                get: function() {
                    return this.disabled || !!this._globalOptions.disabled;
                },
                enumerable: !0,
                configurable: !0
            }), MatRipple.prototype._setupTriggerEventsIfEnabled = function() {
                !this.disabled && this._isInitialized && this._rippleRenderer.setupTriggerEvents(this.trigger);
            }, MatRipple.prototype.launch = function(configOrX, y, config) {
                return void 0 === y && (y = 0), "number" == typeof configOrX ? this._rippleRenderer.fadeInRipple(configOrX, y, __assign({}, this.rippleConfig, config)) : this._rippleRenderer.fadeInRipple(0, 0, __assign({}, this.rippleConfig, configOrX));
            }, MatRipple.ngDirectiveDef = defineDirective({
                type: MatRipple,
                selectors: [ [ "", "mat-ripple", "" ], [ "", "matRipple", "" ] ],
                factory: function(t) {
                    return new (t || MatRipple)(directiveInject(ElementRef), directiveInject(NgZone), directiveInject(platform_es5_Platform), directiveInject(MAT_RIPPLE_GLOBAL_OPTIONS, 8), directiveInject(ANIMATION_MODULE_TYPE, 8));
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (elementHostAttrs(_c1), elementHostStyling(_c2)), 2 & rf && (elementHostClassProp(0, ctx.unbounded), 
                    elementHostStylingApply());
                },
                inputs: {
                    radius: [ "matRippleRadius", "radius" ],
                    disabled: [ "matRippleDisabled", "disabled" ],
                    trigger: [ "matRippleTrigger", "trigger" ],
                    color: [ "matRippleColor", "color" ],
                    unbounded: [ "matRippleUnbounded", "unbounded" ],
                    centered: [ "matRippleCentered", "centered" ],
                    animation: [ "matRippleAnimation", "animation" ]
                },
                exportAs: [ "matRipple" ]
            }), MatRipple;
        }(), core_es5_MatRippleModule = function() {
            function MatRippleModule() {}
            return MatRippleModule.ngModuleDef = defineNgModule({
                type: MatRippleModule
            }), MatRippleModule.ngInjectorDef = defineInjector({
                factory: function(t) {
                    return new (t || MatRippleModule)();
                },
                imports: [ [ core_es5_MatCommonModule, platform_es5_PlatformModule ], core_es5_MatCommonModule ]
            }), MatRippleModule;
        }();
        const button_es5_c0 = [ "_mat-animation-noopable" ], button_es5_c1 = [ "mat-button", "" ], button_es5_c2 = [ 1, "mat-button-wrapper" ], button_es5_c3 = [ "matRipple", "", 1, "mat-button-ripple", 3, "matRippleDisabled", "matRippleCentered", "matRippleTrigger" ], button_es5_c4 = [ 1, "mat-button-focus-overlay" ], button_es5_c5 = [ "mat-button-ripple-round" ], button_es5_c6 = [];
        var DEFAULT_ROUND_BUTTON_COLOR = "accent", BUTTON_HOST_ATTRIBUTES = [ "mat-button", "mat-flat-button", "mat-icon-button", "mat-raised-button", "mat-stroked-button", "mat-mini-fab", "mat-fab" ], button_es5_MatButton = function(_super) {
            function MatButton(elementRef, _platform, _focusMonitor, _animationMode) {
                var _this = _super.call(this, elementRef) || this;
                _this._platform = _platform, _this._focusMonitor = _focusMonitor, _this._animationMode = _animationMode, 
                _this.isRoundButton = _this._hasHostAttributes("mat-fab", "mat-mini-fab"), _this.isIconButton = _this._hasHostAttributes("mat-icon-button");
                for (var _i = 0, BUTTON_HOST_ATTRIBUTES_1 = BUTTON_HOST_ATTRIBUTES; _i < BUTTON_HOST_ATTRIBUTES_1.length; _i++) {
                    var attr = BUTTON_HOST_ATTRIBUTES_1[_i];
                    _this._hasHostAttributes(attr) && elementRef.nativeElement.classList.add(attr);
                }
                return _this._focusMonitor.monitor(_this._elementRef, !0), _this.isRoundButton && (_this.color = DEFAULT_ROUND_BUTTON_COLOR), 
                _this;
            }
            return __extends(MatButton, _super), MatButton.prototype.ngOnDestroy = function() {
                this._focusMonitor.stopMonitoring(this._elementRef);
            }, MatButton.prototype.focus = function() {
                this._getHostElement().focus();
            }, MatButton.prototype._getHostElement = function() {
                return this._elementRef.nativeElement;
            }, MatButton.prototype._isRippleDisabled = function() {
                return this.disableRipple || this.disabled;
            }, MatButton.prototype._hasHostAttributes = function() {
                for (var _this = this, attributes = [], _i = 0; _i < arguments.length; _i++) attributes[_i] = arguments[_i];
                return attributes.some(function(attribute) {
                    return _this._getHostElement().hasAttribute(attribute);
                });
            }, MatButton.ngComponentDef = defineComponent({
                type: MatButton,
                selectors: [ [ "button", "mat-button", "" ], [ "button", "mat-raised-button", "" ], [ "button", "mat-icon-button", "" ], [ "button", "mat-fab", "" ], [ "button", "mat-mini-fab", "" ], [ "button", "mat-stroked-button", "" ], [ "button", "mat-flat-button", "" ] ],
                factory: function(t) {
                    return new (t || MatButton)(directiveInject(ElementRef), directiveInject(platform_es5_Platform), directiveInject(a11y_es5_FocusMonitor), directiveInject(ANIMATION_MODULE_TYPE, 8));
                },
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && viewQuery(core_es5_MatRipple, !0, null), 2 & rf && queryRefresh(_t = loadViewQuery()) && (ctx.ripple = _t.first);
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (allocHostVars(1), elementHostStyling(button_es5_c0)), 2 & rf && (elementProperty(elIndex, "disabled", bind(ctx.disabled || null), null, !0), 
                    elementHostClassProp(0, "NoopAnimations" === ctx._animationMode), elementHostStylingApply());
                },
                inputs: {
                    disabled: "disabled",
                    disableRipple: "disableRipple",
                    color: "color"
                },
                exportAs: [ "matButton" ],
                features: [ InheritDefinitionFeature ],
                attrs: button_es5_c1,
                ngContentSelectors: button_es5_c6,
                consts: 4,
                vars: 3,
                template: function(rf, ctx) {
                    1 & rf && (projectionDef(), elementStart(0, "span", button_es5_c2), projection(1), 
                    elementEnd(), elementStart(2, "div", button_es5_c3), elementStyling(button_es5_c5), 
                    elementEnd(), core_element(3, "div", button_es5_c4)), 2 & rf && (elementClassProp(2, 0, ctx.isRoundButton || ctx.isIconButton), 
                    elementStylingApply(2), core_select(2), elementProperty(2, "matRippleDisabled", bind(ctx._isRippleDisabled())), 
                    elementProperty(2, "matRippleCentered", bind(ctx.isIconButton)), elementProperty(2, "matRippleTrigger", bind(ctx._getHostElement())));
                },
                directives: [ core_es5_MatRipple ],
                styles: [ ".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:.04}@media (hover:none){.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-flat-button,.mat-icon-button,.mat-stroked-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner{border:0}.mat-button[disabled],.mat-flat-button[disabled],.mat-icon-button[disabled],.mat-stroked-button[disabled]{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button[disabled]{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab[disabled]{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab[disabled]{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button .mat-icon,.mat-icon-button i{line-height:24px}.mat-button-focus-overlay,.mat-button-ripple.mat-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-focus-overlay{border-radius:inherit;opacity:0;transition:opacity .2s cubic-bezier(.35,0,.25,1),background-color .2s cubic-bezier(.35,0,.25,1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}@media screen and (-ms-high-contrast:active){.mat-button-focus-overlay{background-color:rgba(255,255,255,.5)}}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:block;font-size:inherit;width:2.5em;height:2.5em}@media screen and (-ms-high-contrast:active){.mat-button,.mat-fab,.mat-flat-button,.mat-icon-button,.mat-mini-fab,.mat-raised-button{outline:solid 1px}}" ],
                encapsulation: 2,
                changeDetection: 0
            }), MatButton;
        }(mixinColor(mixinDisabled(mixinDisableRipple(function() {
            return function(_elementRef) {
                this._elementRef = _elementRef;
            };
        }())))), button_es5_MatButtonModule = function() {
            function MatButtonModule() {}
            return MatButtonModule.ngModuleDef = defineNgModule({
                type: MatButtonModule
            }), MatButtonModule.ngInjectorDef = defineInjector({
                factory: function(t) {
                    return new (t || MatButtonModule)();
                },
                imports: [ [ common_CommonModule, core_es5_MatRippleModule, core_es5_MatCommonModule ], core_es5_MatCommonModule ]
            }), MatButtonModule;
        }(), forkJoin_ForkJoinSubscriber = function(_super) {
            function ForkJoinSubscriber(destination, sources) {
                var _this = _super.call(this, destination) || this;
                _this.sources = sources, _this.completed = 0, _this.haveValues = 0;
                var len = sources.length;
                _this.values = new Array(len);
                for (var i = 0; i < len; i++) {
                    var innerSubscription = subscribeToResult(_this, sources[i], null, i);
                    innerSubscription && _this.add(innerSubscription);
                }
                return _this;
            }
            return __extends(ForkJoinSubscriber, _super), ForkJoinSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.values[outerIndex] = innerValue, innerSub._hasValue || (innerSub._hasValue = !0, 
                this.haveValues++);
            }, ForkJoinSubscriber.prototype.notifyComplete = function(innerSub) {
                var destination = this.destination, haveValues = this.haveValues, values = this.values, len = values.length;
                innerSub._hasValue ? (this.completed++, this.completed === len && (haveValues === len && destination.next(values), 
                destination.complete())) : destination.complete();
            }, ForkJoinSubscriber;
        }(OuterSubscriber_OuterSubscriber);
        function catchError(selector) {
            return function(source) {
                var operator = new CatchOperator(selector), caught = source.lift(operator);
                return operator.caught = caught;
            };
        }
        var CatchOperator = function() {
            function CatchOperator(selector) {
                this.selector = selector;
            }
            return CatchOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new catchError_CatchSubscriber(subscriber, this.selector, this.caught));
            }, CatchOperator;
        }(), catchError_CatchSubscriber = function(_super) {
            function CatchSubscriber(destination, selector, caught) {
                var _this = _super.call(this, destination) || this;
                return _this.selector = selector, _this.caught = caught, _this;
            }
            return __extends(CatchSubscriber, _super), CatchSubscriber.prototype.error = function(err) {
                if (!this.isStopped) {
                    var result = void 0;
                    try {
                        result = this.selector(err, this.caught);
                    } catch (err2) {
                        return void _super.prototype.error.call(this, err2);
                    }
                    this._unsubscribeAndRecycle();
                    var innerSubscriber = new InnerSubscriber_InnerSubscriber(this, void 0, void 0);
                    this.add(innerSubscriber), subscribeToResult(this, result, void 0, void 0, innerSubscriber);
                }
            }, CatchSubscriber;
        }(OuterSubscriber_OuterSubscriber), FinallyOperator = function() {
            function FinallyOperator(callback) {
                this.callback = callback;
            }
            return FinallyOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new finalize_FinallySubscriber(subscriber, this.callback));
            }, FinallyOperator;
        }(), finalize_FinallySubscriber = function(_super) {
            function FinallySubscriber(destination, callback) {
                var _this = _super.call(this, destination) || this;
                return _this.add(new Subscription_Subscription(callback)), _this;
            }
            return __extends(FinallySubscriber, _super), FinallySubscriber;
        }(Subscriber_Subscriber);
        const icon_es5_c0 = [ "role", "img", 1, "mat-icon" ], icon_es5_c1 = [ "mat-icon-inline" ], icon_es5_c2 = [];
        function getMatIconNameNotFoundError(iconName) {
            return Error('Unable to find icon with the name "' + iconName + '"');
        }
        function getMatIconFailedToSanitizeUrlError(url) {
            return Error("The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was \"" + url + '".');
        }
        function getMatIconFailedToSanitizeLiteralError(literal) {
            return Error("The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was \"" + literal + '".');
        }
        var SvgIconConfig = function() {
            return function(data) {
                data.nodeName ? this.svgElement = data : this.url = data;
            };
        }(), icon_es5_MatIconRegistry = function() {
            function MatIconRegistry(_httpClient, _sanitizer, document) {
                this._httpClient = _httpClient, this._sanitizer = _sanitizer, this._svgIconConfigs = new Map(), 
                this._iconSetConfigs = new Map(), this._cachedIconsByUrl = new Map(), this._inProgressUrlFetches = new Map(), 
                this._fontCssClassesByAlias = new Map(), this._defaultFontSetClass = "material-icons", 
                this._document = document;
            }
            return MatIconRegistry.prototype.addSvgIcon = function(iconName, url) {
                return this.addSvgIconInNamespace("", iconName, url);
            }, MatIconRegistry.prototype.addSvgIconLiteral = function(iconName, literal) {
                return this.addSvgIconLiteralInNamespace("", iconName, literal);
            }, MatIconRegistry.prototype.addSvgIconInNamespace = function(namespace, iconName, url) {
                return this._addSvgIconConfig(namespace, iconName, new SvgIconConfig(url));
            }, MatIconRegistry.prototype.addSvgIconLiteralInNamespace = function(namespace, iconName, literal) {
                var sanitizedLiteral = this._sanitizer.sanitize(SecurityContext.HTML, literal);
                if (!sanitizedLiteral) throw getMatIconFailedToSanitizeLiteralError(literal);
                var svgElement = this._createSvgElementForSingleIcon(sanitizedLiteral);
                return this._addSvgIconConfig(namespace, iconName, new SvgIconConfig(svgElement));
            }, MatIconRegistry.prototype.addSvgIconSet = function(url) {
                return this.addSvgIconSetInNamespace("", url);
            }, MatIconRegistry.prototype.addSvgIconSetLiteral = function(literal) {
                return this.addSvgIconSetLiteralInNamespace("", literal);
            }, MatIconRegistry.prototype.addSvgIconSetInNamespace = function(namespace, url) {
                return this._addSvgIconSetConfig(namespace, new SvgIconConfig(url));
            }, MatIconRegistry.prototype.addSvgIconSetLiteralInNamespace = function(namespace, literal) {
                var sanitizedLiteral = this._sanitizer.sanitize(SecurityContext.HTML, literal);
                if (!sanitizedLiteral) throw getMatIconFailedToSanitizeLiteralError(literal);
                var svgElement = this._svgElementFromString(sanitizedLiteral);
                return this._addSvgIconSetConfig(namespace, new SvgIconConfig(svgElement));
            }, MatIconRegistry.prototype.registerFontClassAlias = function(alias, className) {
                return void 0 === className && (className = alias), this._fontCssClassesByAlias.set(alias, className), 
                this;
            }, MatIconRegistry.prototype.classNameForFontAlias = function(alias) {
                return this._fontCssClassesByAlias.get(alias) || alias;
            }, MatIconRegistry.prototype.setDefaultFontSetClass = function(className) {
                return this._defaultFontSetClass = className, this;
            }, MatIconRegistry.prototype.getDefaultFontSetClass = function() {
                return this._defaultFontSetClass;
            }, MatIconRegistry.prototype.getSvgIconFromUrl = function(safeUrl) {
                var _this = this, url = this._sanitizer.sanitize(SecurityContext.RESOURCE_URL, safeUrl);
                if (!url) throw getMatIconFailedToSanitizeUrlError(safeUrl);
                var cachedIcon = this._cachedIconsByUrl.get(url);
                return cachedIcon ? of(cloneSvg(cachedIcon)) : this._loadSvgIconFromConfig(new SvgIconConfig(safeUrl)).pipe(tap(function(svg) {
                    return _this._cachedIconsByUrl.set(url, svg);
                }), map_map(function(svg) {
                    return cloneSvg(svg);
                }));
            }, MatIconRegistry.prototype.getNamedSvgIcon = function(name, namespace) {
                void 0 === namespace && (namespace = "");
                var key = iconKey(namespace, name), config = this._svgIconConfigs.get(key);
                if (config) return this._getSvgFromConfig(config);
                var iconSetConfigs = this._iconSetConfigs.get(namespace);
                return iconSetConfigs ? this._getSvgFromIconSetConfigs(name, iconSetConfigs) : throwError_throwError(getMatIconNameNotFoundError(key));
            }, MatIconRegistry.prototype._getSvgFromConfig = function(config) {
                return config.svgElement ? of(cloneSvg(config.svgElement)) : this._loadSvgIconFromConfig(config).pipe(tap(function(svg) {
                    return config.svgElement = svg;
                }), map_map(function(svg) {
                    return cloneSvg(svg);
                }));
            }, MatIconRegistry.prototype._getSvgFromIconSetConfigs = function(name, iconSetConfigs) {
                var _this = this, namedIcon = this._extractIconWithNameFromAnySet(name, iconSetConfigs);
                return namedIcon ? of(namedIcon) : function forkJoin() {
                    for (var resultSelector, sources = [], _i = 0; _i < arguments.length; _i++) sources[_i] = arguments[_i];
                    return "function" == typeof sources[sources.length - 1] && (resultSelector = sources.pop()), 
                    1 === sources.length && isArray(sources[0]) && (sources = sources[0]), 0 === sources.length ? empty_EMPTY : resultSelector ? forkJoin(sources).pipe(map_map(function(args) {
                        return resultSelector.apply(void 0, args);
                    })) : new Observable_Observable(function(subscriber) {
                        return new forkJoin_ForkJoinSubscriber(subscriber, sources);
                    });
                }(iconSetConfigs.filter(function(iconSetConfig) {
                    return !iconSetConfig.svgElement;
                }).map(function(iconSetConfig) {
                    return _this._loadSvgIconSetFromConfig(iconSetConfig).pipe(catchError(function(err) {
                        var url = _this._sanitizer.sanitize(SecurityContext.RESOURCE_URL, iconSetConfig.url);
                        return console.error("Loading icon set URL: " + url + " failed: " + err.message), 
                        of(null);
                    }));
                })).pipe(map_map(function() {
                    var foundIcon = _this._extractIconWithNameFromAnySet(name, iconSetConfigs);
                    if (!foundIcon) throw getMatIconNameNotFoundError(name);
                    return foundIcon;
                }));
            }, MatIconRegistry.prototype._extractIconWithNameFromAnySet = function(iconName, iconSetConfigs) {
                for (var i = iconSetConfigs.length - 1; i >= 0; i--) {
                    var config = iconSetConfigs[i];
                    if (config.svgElement) {
                        var foundIcon = this._extractSvgIconFromSet(config.svgElement, iconName);
                        if (foundIcon) return foundIcon;
                    }
                }
                return null;
            }, MatIconRegistry.prototype._loadSvgIconFromConfig = function(config) {
                var _this = this;
                return this._fetchUrl(config.url).pipe(map_map(function(svgText) {
                    return _this._createSvgElementForSingleIcon(svgText);
                }));
            }, MatIconRegistry.prototype._loadSvgIconSetFromConfig = function(config) {
                var _this = this;
                return config.svgElement ? of(config.svgElement) : this._fetchUrl(config.url).pipe(map_map(function(svgText) {
                    return config.svgElement || (config.svgElement = _this._svgElementFromString(svgText)), 
                    config.svgElement;
                }));
            }, MatIconRegistry.prototype._createSvgElementForSingleIcon = function(responseText) {
                var svg = this._svgElementFromString(responseText);
                return this._setSvgAttributes(svg), svg;
            }, MatIconRegistry.prototype._extractSvgIconFromSet = function(iconSet, iconName) {
                var iconSource = iconSet.querySelector("#" + iconName);
                if (!iconSource) return null;
                var iconElement = iconSource.cloneNode(!0);
                if (iconElement.removeAttribute("id"), "svg" === iconElement.nodeName.toLowerCase()) return this._setSvgAttributes(iconElement);
                if ("symbol" === iconElement.nodeName.toLowerCase()) return this._setSvgAttributes(this._toSvgElement(iconElement));
                var svg = this._svgElementFromString("<svg></svg>");
                return svg.appendChild(iconElement), this._setSvgAttributes(svg);
            }, MatIconRegistry.prototype._svgElementFromString = function(str) {
                var div = this._document.createElement("DIV");
                div.innerHTML = str;
                var svg = div.querySelector("svg");
                if (!svg) throw Error("<svg> tag not found");
                return svg;
            }, MatIconRegistry.prototype._toSvgElement = function(element) {
                for (var svg = this._svgElementFromString("<svg></svg>"), i = 0; i < element.childNodes.length; i++) element.childNodes[i].nodeType === this._document.ELEMENT_NODE && svg.appendChild(element.childNodes[i].cloneNode(!0));
                return svg;
            }, MatIconRegistry.prototype._setSvgAttributes = function(svg) {
                return svg.setAttribute("fit", ""), svg.setAttribute("height", "100%"), svg.setAttribute("width", "100%"), 
                svg.setAttribute("preserveAspectRatio", "xMidYMid meet"), svg.setAttribute("focusable", "false"), 
                svg;
            }, MatIconRegistry.prototype._fetchUrl = function(safeUrl) {
                var _this = this;
                if (!this._httpClient) throw Error("Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports.");
                if (null == safeUrl) throw Error('Cannot fetch icon from URL "' + safeUrl + '".');
                var url = this._sanitizer.sanitize(SecurityContext.RESOURCE_URL, safeUrl);
                if (!url) throw getMatIconFailedToSanitizeUrlError(safeUrl);
                var inProgressFetch = this._inProgressUrlFetches.get(url);
                if (inProgressFetch) return inProgressFetch;
                var callback, req = this._httpClient.get(url, {
                    responseType: "text"
                }).pipe((callback = function() {
                    return _this._inProgressUrlFetches.delete(url);
                }, function(source) {
                    return source.lift(new FinallyOperator(callback));
                }), share());
                return this._inProgressUrlFetches.set(url, req), req;
            }, MatIconRegistry.prototype._addSvgIconConfig = function(namespace, iconName, config) {
                return this._svgIconConfigs.set(iconKey(namespace, iconName), config), this;
            }, MatIconRegistry.prototype._addSvgIconSetConfig = function(namespace, config) {
                var configNamespace = this._iconSetConfigs.get(namespace);
                return configNamespace ? configNamespace.push(config) : this._iconSetConfigs.set(namespace, [ config ]), 
                this;
            }, MatIconRegistry.ngInjectableDef = defineInjectable({
                factory: function() {
                    return new MatIconRegistry(inject(http_HttpClient, 8), inject(DomSanitizer), inject(DOCUMENT, 8));
                },
                token: MatIconRegistry,
                providedIn: "root"
            }), MatIconRegistry.ngInjectableDef = defineInjectable({
                token: MatIconRegistry,
                factory: function(t) {
                    return new (t || MatIconRegistry)(inject(http_HttpClient, 8), inject(DomSanitizer), inject(DOCUMENT, 8));
                },
                providedIn: "root"
            }), MatIconRegistry;
        }();
        function cloneSvg(svg) {
            return svg.cloneNode(!0);
        }
        function iconKey(namespace, name) {
            return namespace + ":" + name;
        }
        var _MatIconMixinBase = mixinColor(function() {
            return function(_elementRef) {
                this._elementRef = _elementRef;
            };
        }()), MAT_ICON_LOCATION = new InjectionToken("mat-icon-location", {
            providedIn: "root",
            factory: function() {
                var _document = inject(DOCUMENT);
                return {
                    getPathname: function() {
                        return _document && _document.location && _document.location.pathname || "";
                    }
                };
            }
        }), funcIriAttributes = [ "clip-path", "color-profile", "src", "cursor", "fill", "filter", "marker", "marker-start", "marker-mid", "marker-end", "mask", "stroke" ], funcIriAttributeSelector = funcIriAttributes.map(function(attr) {
            return "[" + attr + "]";
        }).join(", "), funcIriPattern = /^url\(['"]?#(.*?)['"]?\)$/, icon_es5_MatIcon = function(_super) {
            function MatIcon(elementRef, _iconRegistry, ariaHidden, _location) {
                var _this = _super.call(this, elementRef) || this;
                return _this._iconRegistry = _iconRegistry, _this._location = _location, _this._inline = !1, 
                ariaHidden || elementRef.nativeElement.setAttribute("aria-hidden", "true"), _this;
            }
            return __extends(MatIcon, _super), Object.defineProperty(MatIcon.prototype, "inline", {
                get: function() {
                    return this._inline;
                },
                set: function(inline) {
                    this._inline = coerceBooleanProperty(inline);
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(MatIcon.prototype, "fontSet", {
                get: function() {
                    return this._fontSet;
                },
                set: function(value) {
                    this._fontSet = this._cleanupFontValue(value);
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(MatIcon.prototype, "fontIcon", {
                get: function() {
                    return this._fontIcon;
                },
                set: function(value) {
                    this._fontIcon = this._cleanupFontValue(value);
                },
                enumerable: !0,
                configurable: !0
            }), MatIcon.prototype._splitIconName = function(iconName) {
                if (!iconName) return [ "", "" ];
                var parts = iconName.split(":");
                switch (parts.length) {
                  case 1:
                    return [ "", parts[0] ];

                  case 2:
                    return parts;

                  default:
                    throw Error('Invalid icon name: "' + iconName + '"');
                }
            }, MatIcon.prototype.ngOnChanges = function(changes) {
                var _this = this;
                if (changes.svgIcon) if (this.svgIcon) {
                    var _a = this._splitIconName(this.svgIcon);
                    this._iconRegistry.getNamedSvgIcon(_a[1], _a[0]).pipe(take(1)).subscribe(function(svg) {
                        return _this._setSvgElement(svg);
                    }, function(err) {
                        return console.log("Error retrieving icon: " + err.message);
                    });
                } else this._clearSvgElement();
                this._usingFontIcon() && this._updateFontIconClasses();
            }, MatIcon.prototype.ngOnInit = function() {
                this._usingFontIcon() && this._updateFontIconClasses();
            }, MatIcon.prototype.ngAfterViewChecked = function() {
                var cachedElements = this._elementsWithExternalReferences;
                if (cachedElements && this._location && cachedElements.size) {
                    var newPath = this._location.getPathname();
                    newPath !== this._previousPath && (this._previousPath = newPath, this._prependPathToReferences(newPath));
                }
            }, MatIcon.prototype.ngOnDestroy = function() {
                this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear();
            }, MatIcon.prototype._usingFontIcon = function() {
                return !this.svgIcon;
            }, MatIcon.prototype._setSvgElement = function(svg) {
                this._clearSvgElement();
                for (var styleTags = svg.querySelectorAll("style"), i = 0; i < styleTags.length; i++) styleTags[i].textContent += " ";
                if (this._location) {
                    var path = this._location.getPathname();
                    this._previousPath = path, this._cacheChildrenWithExternalReferences(svg), this._prependPathToReferences(path);
                }
                this._elementRef.nativeElement.appendChild(svg);
            }, MatIcon.prototype._clearSvgElement = function() {
                var layoutElement = this._elementRef.nativeElement, childCount = layoutElement.childNodes.length;
                for (this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear(); childCount--; ) {
                    var child = layoutElement.childNodes[childCount];
                    1 === child.nodeType && "svg" !== child.nodeName.toLowerCase() || layoutElement.removeChild(child);
                }
            }, MatIcon.prototype._updateFontIconClasses = function() {
                if (this._usingFontIcon()) {
                    var elem = this._elementRef.nativeElement, fontSetClass = this.fontSet ? this._iconRegistry.classNameForFontAlias(this.fontSet) : this._iconRegistry.getDefaultFontSetClass();
                    fontSetClass != this._previousFontSetClass && (this._previousFontSetClass && elem.classList.remove(this._previousFontSetClass), 
                    fontSetClass && elem.classList.add(fontSetClass), this._previousFontSetClass = fontSetClass), 
                    this.fontIcon != this._previousFontIconClass && (this._previousFontIconClass && elem.classList.remove(this._previousFontIconClass), 
                    this.fontIcon && elem.classList.add(this.fontIcon), this._previousFontIconClass = this.fontIcon);
                }
            }, MatIcon.prototype._cleanupFontValue = function(value) {
                return "string" == typeof value ? value.trim().split(" ")[0] : value;
            }, MatIcon.prototype._prependPathToReferences = function(path) {
                var elements = this._elementsWithExternalReferences;
                elements && elements.forEach(function(attrs, element) {
                    attrs.forEach(function(attr) {
                        element.setAttribute(attr.name, "url('" + path + "#" + attr.value + "')");
                    });
                });
            }, MatIcon.prototype._cacheChildrenWithExternalReferences = function(element) {
                for (var elementsWithFuncIri = element.querySelectorAll(funcIriAttributeSelector), elements = this._elementsWithExternalReferences = this._elementsWithExternalReferences || new Map(), _loop_1 = function(i) {
                    funcIriAttributes.forEach(function(attr) {
                        var elementWithReference = elementsWithFuncIri[i], value = elementWithReference.getAttribute(attr), match = value ? value.match(funcIriPattern) : null;
                        if (match) {
                            var attributes = elements.get(elementWithReference);
                            attributes || elements.set(elementWithReference, attributes = []), attributes.push({
                                name: attr,
                                value: match[1]
                            });
                        }
                    });
                }, i = 0; i < elementsWithFuncIri.length; i++) _loop_1(i);
            }, MatIcon.ngComponentDef = defineComponent({
                type: MatIcon,
                selectors: [ [ "mat-icon" ] ],
                factory: function(t) {
                    return new (t || MatIcon)(directiveInject(ElementRef), directiveInject(icon_es5_MatIconRegistry), ("aria-hidden", 
                    function(tNode, attrNameToInject) {
                        var attrs = tNode.attrs;
                        if (attrs) for (var attrsLength = attrs.length, i = 0; i < attrsLength; ) {
                            var value = attrs[i];
                            if (isNameOnlyAttributeMarker(value)) break;
                            if (0 === value) i += 2; else if ("number" == typeof value) {
                                for (i++; i < attrsLength && "string" == typeof attrs[i]; ) i++;
                            } else {
                                if ("aria-hidden" === value) return attrs[i + 1];
                                i += 2;
                            }
                        }
                        return null;
                    }(getPreviousOrParentTNode())), directiveInject(MAT_ICON_LOCATION, 8));
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (elementHostAttrs(icon_es5_c0), elementHostStyling(icon_es5_c1)), 2 & rf && (elementHostClassProp(0, ctx.inline), 
                    elementHostStylingApply());
                },
                inputs: {
                    color: "color",
                    inline: "inline",
                    fontSet: "fontSet",
                    fontIcon: "fontIcon",
                    svgIcon: "svgIcon"
                },
                exportAs: [ "matIcon" ],
                features: [ InheritDefinitionFeature, NgOnChangesFeature() ],
                ngContentSelectors: icon_es5_c2,
                consts: 1,
                vars: 0,
                template: function(rf, ctx) {
                    1 & rf && (projectionDef(), projection(0));
                },
                styles: [ ".mat-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1,1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}" ],
                encapsulation: 2,
                changeDetection: 0
            }), MatIcon;
        }(_MatIconMixinBase), icon_es5_MatIconModule = function() {
            function MatIconModule() {}
            return MatIconModule.ngModuleDef = defineNgModule({
                type: MatIconModule
            }), MatIconModule.ngInjectorDef = defineInjector({
                factory: function(t) {
                    return new (t || MatIconModule)();
                },
                imports: [ [ core_es5_MatCommonModule ], core_es5_MatCommonModule ]
            }), MatIconModule;
        }();
        const progress_bar_es5_c0 = [ "primaryValueBar" ], progress_bar_es5_c1 = [ "role", "progressbar", "aria-valuemin", "0", "aria-valuemax", "100", 1, "mat-progress-bar" ], progress_bar_es5_c2 = [ "_mat-animation-noopable" ], progress_bar_es5_c3 = [ "width", "100%", "height", "4", "focusable", "false", 1, "mat-progress-bar-background", "mat-progress-bar-element" ], progress_bar_es5_c4 = [ "x", "4", "y", "0", "width", "8", "height", "4", "patternUnits", "userSpaceOnUse", 3, "id" ], progress_bar_es5_c5 = [ "cx", "2", "cy", "2", "r", "2" ], progress_bar_es5_c6 = [ "width", "100%", "height", "100%", 3, "fill" ], progress_bar_es5_c7 = [ 1, "mat-progress-bar-buffer", "mat-progress-bar-element", 3, "ngStyle" ], progress_bar_es5_c8 = [ 1, "mat-progress-bar-primary", "mat-progress-bar-fill", "mat-progress-bar-element", 3, "ngStyle" ], progress_bar_es5_c9 = [ "primaryValueBar", "" ], progress_bar_es5_c10 = [ 1, "mat-progress-bar-secondary", "mat-progress-bar-fill", "mat-progress-bar-element" ];
        var _MatProgressBarMixinBase = mixinColor(function() {
            return function(_elementRef) {
                this._elementRef = _elementRef;
            };
        }(), "primary"), MAT_PROGRESS_BAR_LOCATION = new InjectionToken("mat-progress-bar-location", {
            providedIn: "root",
            factory: function() {
                var _document = inject(DOCUMENT);
                return {
                    pathname: _document && _document.location && _document.location.pathname || ""
                };
            }
        }), progressbarId = 0, progress_bar_es5_MatProgressBar = function(_super) {
            function MatProgressBar(_elementRef, _ngZone, _animationMode, location) {
                var _this = _super.call(this, _elementRef) || this;
                _this._elementRef = _elementRef, _this._ngZone = _ngZone, _this._animationMode = _animationMode, 
                _this._isNoopAnimation = !1, _this._value = 0, _this._bufferValue = 0, _this.animationEnd = new core_EventEmitter(), 
                _this._animationEndSubscription = Subscription_Subscription.EMPTY, _this.mode = "determinate", 
                _this.progressbarId = "mat-progress-bar-" + progressbarId++;
                var path = location && location.pathname ? location.pathname.split("#")[0] : "";
                return _this._rectangleFillValue = "url('" + path + "#" + _this.progressbarId + "')", 
                _this._isNoopAnimation = "NoopAnimations" === _animationMode, _this;
            }
            return __extends(MatProgressBar, _super), Object.defineProperty(MatProgressBar.prototype, "value", {
                get: function() {
                    return this._value;
                },
                set: function(v) {
                    this._value = clamp(v || 0), this._isNoopAnimation && this.emitAnimationEnd();
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(MatProgressBar.prototype, "bufferValue", {
                get: function() {
                    return this._bufferValue;
                },
                set: function(v) {
                    this._bufferValue = clamp(v || 0);
                },
                enumerable: !0,
                configurable: !0
            }), MatProgressBar.prototype._primaryTransform = function() {
                return {
                    transform: "scaleX(" + this.value / 100 + ")"
                };
            }, MatProgressBar.prototype._bufferTransform = function() {
                if ("buffer" === this.mode) return {
                    transform: "scaleX(" + this.bufferValue / 100 + ")"
                };
            }, MatProgressBar.prototype.ngAfterViewInit = function() {
                var _this = this;
                this._isNoopAnimation || this._ngZone.runOutsideAngular(function() {
                    _this._animationEndSubscription = fromEvent(_this._primaryValueBar.nativeElement, "transitionend").pipe(filter(function(e) {
                        return e.target === _this._primaryValueBar.nativeElement;
                    })).subscribe(function(_) {
                        return _this._ngZone.run(function() {
                            return _this.emitAnimationEnd();
                        });
                    });
                });
            }, MatProgressBar.prototype.ngOnDestroy = function() {
                this._animationEndSubscription.unsubscribe();
            }, MatProgressBar.prototype.emitAnimationEnd = function() {
                "determinate" !== this.mode && "buffer" !== this.mode || this.animationEnd.next({
                    value: this.value
                });
            }, MatProgressBar.ngComponentDef = defineComponent({
                type: MatProgressBar,
                selectors: [ [ "mat-progress-bar" ] ],
                factory: function(t) {
                    return new (t || MatProgressBar)(directiveInject(ElementRef), directiveInject(NgZone), directiveInject(ANIMATION_MODULE_TYPE, 8), directiveInject(MAT_PROGRESS_BAR_LOCATION, 8));
                },
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && viewQuery(progress_bar_es5_c0, !0, null), 2 & rf && queryRefresh(_t = loadViewQuery()) && (ctx._primaryValueBar = _t.first);
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (allocHostVars(2), elementHostAttrs(progress_bar_es5_c1), elementHostStyling(progress_bar_es5_c2)), 
                    2 & rf && (elementAttribute(elIndex, "aria-valuenow", bind(ctx.value)), elementAttribute(elIndex, "mode", bind(ctx.mode)), 
                    elementHostClassProp(0, ctx._isNoopAnimation), elementHostStylingApply());
                },
                inputs: {
                    color: "color",
                    value: "value",
                    bufferValue: "bufferValue",
                    mode: "mode"
                },
                outputs: {
                    animationEnd: "animationEnd"
                },
                exportAs: [ "matProgressBar" ],
                features: [ InheritDefinitionFeature ],
                consts: 9,
                vars: 4,
                template: function(rf, ctx) {
                    1 & rf && (_currentNamespace = "http://www.w3.org/2000/svg", elementStart(0, "svg", progress_bar_es5_c3), 
                    elementStart(1, "defs"), elementStart(2, "pattern", progress_bar_es5_c4), core_element(3, "circle", progress_bar_es5_c5), 
                    elementEnd(), elementEnd(), core_element(4, "rect", progress_bar_es5_c6), elementEnd(), 
                    namespaceHTML(), core_element(5, "div", progress_bar_es5_c7), core_element(6, "div", progress_bar_es5_c8, progress_bar_es5_c9), 
                    core_element(8, "div", progress_bar_es5_c10)), 2 & rf && (core_select(2), elementProperty(2, "id", bind(ctx.progressbarId)), 
                    core_select(4), elementAttribute(4, "fill", bind(ctx._rectangleFillValue)), core_select(5), 
                    elementProperty(5, "ngStyle", bind(ctx._bufferTransform())), core_select(6), elementProperty(6, "ngStyle", bind(ctx._primaryTransform())));
                },
                directives: [ common_NgStyle ],
                styles: [ ".mat-progress-bar{display:block;height:4px;overflow:hidden;position:relative;transition:opacity 250ms linear;width:100%}._mat-animation-noopable.mat-progress-bar{transition:none;animation:none}.mat-progress-bar .mat-progress-bar-element,.mat-progress-bar .mat-progress-bar-fill::after{height:100%;position:absolute;width:100%}.mat-progress-bar .mat-progress-bar-background{width:calc(100% + 10px)}@media screen and (-ms-high-contrast:active){.mat-progress-bar .mat-progress-bar-background{display:none}}.mat-progress-bar .mat-progress-bar-buffer{transform-origin:top left;transition:transform 250ms ease}@media screen and (-ms-high-contrast:active){.mat-progress-bar .mat-progress-bar-buffer{border-top:solid 5px;opacity:.5}}.mat-progress-bar .mat-progress-bar-secondary{display:none}.mat-progress-bar .mat-progress-bar-fill{animation:none;transform-origin:top left;transition:transform 250ms ease}@media screen and (-ms-high-contrast:active){.mat-progress-bar .mat-progress-bar-fill{border-top:solid 4px}}.mat-progress-bar .mat-progress-bar-fill::after{animation:none;content:'';display:inline-block;left:0}.mat-progress-bar[dir=rtl],[dir=rtl] .mat-progress-bar{transform:rotateY(180deg)}.mat-progress-bar[mode=query]{transform:rotateZ(180deg)}.mat-progress-bar[mode=query][dir=rtl],[dir=rtl] .mat-progress-bar[mode=query]{transform:rotateZ(180deg) rotateY(180deg)}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-fill,.mat-progress-bar[mode=query] .mat-progress-bar-fill{transition:none}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary,.mat-progress-bar[mode=query] .mat-progress-bar-primary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-translate 2s infinite linear;left:-145.166611%}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-primary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-scale 2s infinite linear}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary,.mat-progress-bar[mode=query] .mat-progress-bar-secondary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-translate 2s infinite linear;left:-54.888891%;display:block}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-secondary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-scale 2s infinite linear}.mat-progress-bar[mode=buffer] .mat-progress-bar-background{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-background-scroll 250ms infinite linear;display:block}.mat-progress-bar._mat-animation-noopable .mat-progress-bar-background,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-buffer,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary.mat-progress-bar-fill::after{animation:none;transition:none}@keyframes mat-progress-bar-primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(.5,0,.70173,.49582);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(.30244,.38135,.55,.95635);transform:translateX(83.67142%)}100%{transform:translateX(200.61106%)}}@keyframes mat-progress-bar-primary-indeterminate-scale{0%{transform:scaleX(.08)}36.65%{animation-timing-function:cubic-bezier(.33473,.12482,.78584,1);transform:scaleX(.08)}69.15%{animation-timing-function:cubic-bezier(.06,.11,.6,1);transform:scaleX(.66148)}100%{transform:scaleX(.08)}}@keyframes mat-progress-bar-secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(.15,0,.51506,.40969);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(.31033,.28406,.8,.73371);transform:translateX(37.65191%)}48.35%{animation-timing-function:cubic-bezier(.4,.62704,.6,.90203);transform:translateX(84.38617%)}100%{transform:translateX(160.27778%)}}@keyframes mat-progress-bar-secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(.15,0,.51506,.40969);transform:scaleX(.08)}19.15%{animation-timing-function:cubic-bezier(.31033,.28406,.8,.73371);transform:scaleX(.4571)}44.15%{animation-timing-function:cubic-bezier(.4,.62704,.6,.90203);transform:scaleX(.72796)}100%{transform:scaleX(.08)}}@keyframes mat-progress-bar-background-scroll{to{transform:translateX(-8px)}}" ],
                encapsulation: 2,
                changeDetection: 0
            }), MatProgressBar;
        }(_MatProgressBarMixinBase);
        function clamp(v, min, max) {
            return void 0 === min && (min = 0), void 0 === max && (max = 100), Math.max(min, Math.min(max, v));
        }
        var progress_bar_es5_MatProgressBarModule = function() {
            function MatProgressBarModule() {}
            return MatProgressBarModule.ngModuleDef = defineNgModule({
                type: MatProgressBarModule
            }), MatProgressBarModule.ngInjectorDef = defineInjector({
                factory: function(t) {
                    return new (t || MatProgressBarModule)();
                },
                imports: [ [ common_CommonModule, core_es5_MatCommonModule ], core_es5_MatCommonModule ]
            }), MatProgressBarModule;
        }();
        function distinctUntilChanged(compare, keySelector) {
            return function(source) {
                return source.lift(new DistinctUntilChangedOperator(compare, keySelector));
            };
        }
        var DistinctUntilChangedOperator = function() {
            function DistinctUntilChangedOperator(compare, keySelector) {
                this.compare = compare, this.keySelector = keySelector;
            }
            return DistinctUntilChangedOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new distinctUntilChanged_DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
            }, DistinctUntilChangedOperator;
        }(), distinctUntilChanged_DistinctUntilChangedSubscriber = function(_super) {
            function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
                var _this = _super.call(this, destination) || this;
                return _this.keySelector = keySelector, _this.hasKey = !1, "function" == typeof compare && (_this.compare = compare), 
                _this;
            }
            return __extends(DistinctUntilChangedSubscriber, _super), DistinctUntilChangedSubscriber.prototype.compare = function(x, y) {
                return x === y;
            }, DistinctUntilChangedSubscriber.prototype._next = function(value) {
                var key;
                try {
                    var keySelector = this.keySelector;
                    key = keySelector ? keySelector(value) : value;
                } catch (err) {
                    return this.destination.error(err);
                }
                var result = !1;
                if (this.hasKey) try {
                    result = (0, this.compare)(this.key, key);
                } catch (err) {
                    return this.destination.error(err);
                } else this.hasKey = !0;
                result || (this.key = key, this.destination.next(value));
            }, DistinctUntilChangedSubscriber;
        }(Subscriber_Subscriber), AuditOperator = function() {
            function AuditOperator(durationSelector) {
                this.durationSelector = durationSelector;
            }
            return AuditOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new audit_AuditSubscriber(subscriber, this.durationSelector));
            }, AuditOperator;
        }(), audit_AuditSubscriber = function(_super) {
            function AuditSubscriber(destination, durationSelector) {
                var _this = _super.call(this, destination) || this;
                return _this.durationSelector = durationSelector, _this.hasValue = !1, _this;
            }
            return __extends(AuditSubscriber, _super), AuditSubscriber.prototype._next = function(value) {
                if (this.value = value, this.hasValue = !0, !this.throttled) {
                    var duration = void 0;
                    try {
                        duration = (0, this.durationSelector)(value);
                    } catch (err) {
                        return this.destination.error(err);
                    }
                    var innerSubscription = subscribeToResult(this, duration);
                    !innerSubscription || innerSubscription.closed ? this.clearThrottle() : this.add(this.throttled = innerSubscription);
                }
            }, AuditSubscriber.prototype.clearThrottle = function() {
                var value = this.value, hasValue = this.hasValue, throttled = this.throttled;
                throttled && (this.remove(throttled), this.throttled = null, throttled.unsubscribe()), 
                hasValue && (this.value = null, this.hasValue = !1, this.destination.next(value));
            }, AuditSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex) {
                this.clearThrottle();
            }, AuditSubscriber.prototype.notifyComplete = function() {
                this.clearThrottle();
            }, AuditSubscriber;
        }(OuterSubscriber_OuterSubscriber);
        function isNumeric(val) {
            return !isArray(val) && val - parseFloat(val) + 1 >= 0;
        }
        function timer(dueTime, periodOrScheduler, scheduler) {
            void 0 === dueTime && (dueTime = 0);
            var period = -1;
            return isNumeric(periodOrScheduler) ? period = Number(periodOrScheduler) < 1 ? 1 : Number(periodOrScheduler) : isScheduler(periodOrScheduler) && (scheduler = periodOrScheduler), 
            isScheduler(scheduler) || (scheduler = async_async), new Observable_Observable(function(subscriber) {
                var due = isNumeric(dueTime) ? dueTime : +dueTime - scheduler.now();
                return scheduler.schedule(timer_dispatch, due, {
                    index: 0,
                    period: period,
                    subscriber: subscriber
                });
            });
        }
        function timer_dispatch(state) {
            var index = state.index, period = state.period, subscriber = state.subscriber;
            if (subscriber.next(index), !subscriber.closed) {
                if (-1 === period) return subscriber.complete();
                state.index = index + 1, this.schedule(state, period);
            }
        }
        function auditTime(duration, scheduler) {
            return void 0 === scheduler && (scheduler = async_async), durationSelector = function() {
                return timer(duration, scheduler);
            }, function(source) {
                return source.lift(new AuditOperator(durationSelector));
            };
            var durationSelector;
        }
        function takeUntil(notifier) {
            return function(source) {
                return source.lift(new takeUntil_TakeUntilOperator(notifier));
            };
        }
        var NotificationKind, takeUntil_TakeUntilOperator = function() {
            function TakeUntilOperator(notifier) {
                this.notifier = notifier;
            }
            return TakeUntilOperator.prototype.call = function(subscriber, source) {
                var takeUntilSubscriber = new takeUntil_TakeUntilSubscriber(subscriber), notifierSubscription = subscribeToResult(takeUntilSubscriber, this.notifier);
                return notifierSubscription && !takeUntilSubscriber.seenValue ? (takeUntilSubscriber.add(notifierSubscription), 
                source.subscribe(takeUntilSubscriber)) : takeUntilSubscriber;
            }, TakeUntilOperator;
        }(), takeUntil_TakeUntilSubscriber = function(_super) {
            function TakeUntilSubscriber(destination) {
                var _this = _super.call(this, destination) || this;
                return _this.seenValue = !1, _this;
            }
            return __extends(TakeUntilSubscriber, _super), TakeUntilSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.seenValue = !0, this.complete();
            }, TakeUntilSubscriber.prototype.notifyComplete = function() {}, TakeUntilSubscriber;
        }(OuterSubscriber_OuterSubscriber), QueueAction_QueueAction = function(_super) {
            function QueueAction(scheduler, work) {
                var _this = _super.call(this, scheduler, work) || this;
                return _this.scheduler = scheduler, _this.work = work, _this;
            }
            return __extends(QueueAction, _super), QueueAction.prototype.schedule = function(state, delay) {
                return void 0 === delay && (delay = 0), delay > 0 ? _super.prototype.schedule.call(this, state, delay) : (this.delay = delay, 
                this.state = state, this.scheduler.flush(this), this);
            }, QueueAction.prototype.execute = function(state, delay) {
                return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
            }, QueueAction.prototype.requestAsyncId = function(scheduler, id, delay) {
                return void 0 === delay && (delay = 0), null !== delay && delay > 0 || null === delay && this.delay > 0 ? _super.prototype.requestAsyncId.call(this, scheduler, id, delay) : scheduler.flush(this);
            }, QueueAction;
        }(AsyncAction_AsyncAction), queue = new (function(_super) {
            function QueueScheduler() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return __extends(QueueScheduler, _super), QueueScheduler;
        }(AsyncScheduler_AsyncScheduler))(QueueAction_QueueAction);
        NotificationKind || (NotificationKind = {});
        var Notification_Notification = function() {
            function Notification(kind, value, error) {
                this.kind = kind, this.value = value, this.error = error, this.hasValue = "N" === kind;
            }
            return Notification.prototype.observe = function(observer) {
                switch (this.kind) {
                  case "N":
                    return observer.next && observer.next(this.value);

                  case "E":
                    return observer.error && observer.error(this.error);

                  case "C":
                    return observer.complete && observer.complete();
                }
            }, Notification.prototype.do = function(next, error, complete) {
                switch (this.kind) {
                  case "N":
                    return next && next(this.value);

                  case "E":
                    return error && error(this.error);

                  case "C":
                    return complete && complete();
                }
            }, Notification.prototype.accept = function(nextOrObserver, error, complete) {
                return nextOrObserver && "function" == typeof nextOrObserver.next ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
            }, Notification.prototype.toObservable = function() {
                switch (this.kind) {
                  case "N":
                    return of(this.value);

                  case "E":
                    return throwError_throwError(this.error);

                  case "C":
                    return empty_empty();
                }
                throw new Error("unexpected notification kind value");
            }, Notification.createNext = function(value) {
                return void 0 !== value ? new Notification("N", value) : Notification.undefinedValueNotification;
            }, Notification.createError = function(err) {
                return new Notification("E", void 0, err);
            }, Notification.createComplete = function() {
                return Notification.completeNotification;
            }, Notification.completeNotification = new Notification("C"), Notification.undefinedValueNotification = new Notification("N", void 0), 
            Notification;
        }(), observeOn_ObserveOnSubscriber = function(_super) {
            function ObserveOnSubscriber(destination, scheduler, delay) {
                void 0 === delay && (delay = 0);
                var _this = _super.call(this, destination) || this;
                return _this.scheduler = scheduler, _this.delay = delay, _this;
            }
            return __extends(ObserveOnSubscriber, _super), ObserveOnSubscriber.dispatch = function(arg) {
                arg.notification.observe(arg.destination), this.unsubscribe();
            }, ObserveOnSubscriber.prototype.scheduleMessage = function(notification) {
                this.destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
            }, ObserveOnSubscriber.prototype._next = function(value) {
                this.scheduleMessage(Notification_Notification.createNext(value));
            }, ObserveOnSubscriber.prototype._error = function(err) {
                this.scheduleMessage(Notification_Notification.createError(err)), this.unsubscribe();
            }, ObserveOnSubscriber.prototype._complete = function() {
                this.scheduleMessage(Notification_Notification.createComplete()), this.unsubscribe();
            }, ObserveOnSubscriber;
        }(Subscriber_Subscriber), ObserveOnMessage = function() {
            return function(notification, destination) {
                this.notification = notification, this.destination = destination;
            };
        }(), ReplaySubject_ReplaySubject = function(_super) {
            function ReplaySubject(bufferSize, windowTime, scheduler) {
                void 0 === bufferSize && (bufferSize = Number.POSITIVE_INFINITY), void 0 === windowTime && (windowTime = Number.POSITIVE_INFINITY);
                var _this = _super.call(this) || this;
                return _this.scheduler = scheduler, _this._events = [], _this._infiniteTimeWindow = !1, 
                _this._bufferSize = bufferSize < 1 ? 1 : bufferSize, _this._windowTime = windowTime < 1 ? 1 : windowTime, 
                windowTime === Number.POSITIVE_INFINITY ? (_this._infiniteTimeWindow = !0, _this.next = _this.nextInfiniteTimeWindow) : _this.next = _this.nextTimeWindow, 
                _this;
            }
            return __extends(ReplaySubject, _super), ReplaySubject.prototype.nextInfiniteTimeWindow = function(value) {
                var _events = this._events;
                _events.push(value), _events.length > this._bufferSize && _events.shift(), _super.prototype.next.call(this, value);
            }, ReplaySubject.prototype.nextTimeWindow = function(value) {
                this._events.push(new ReplayEvent(this._getNow(), value)), this._trimBufferThenGetEvents(), 
                _super.prototype.next.call(this, value);
            }, ReplaySubject.prototype._subscribe = function(subscriber) {
                var subscription, _infiniteTimeWindow = this._infiniteTimeWindow, _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents(), scheduler = this.scheduler, len = _events.length;
                if (this.closed) throw new ObjectUnsubscribedError();
                if (this.isStopped || this.hasError ? subscription = Subscription_Subscription.EMPTY : (this.observers.push(subscriber), 
                subscription = new SubjectSubscription_SubjectSubscription(this, subscriber)), scheduler && subscriber.add(subscriber = new observeOn_ObserveOnSubscriber(subscriber, scheduler)), 
                _infiniteTimeWindow) for (var i = 0; i < len && !subscriber.closed; i++) subscriber.next(_events[i]); else for (i = 0; i < len && !subscriber.closed; i++) subscriber.next(_events[i].value);
                return this.hasError ? subscriber.error(this.thrownError) : this.isStopped && subscriber.complete(), 
                subscription;
            }, ReplaySubject.prototype._getNow = function() {
                return (this.scheduler || queue).now();
            }, ReplaySubject.prototype._trimBufferThenGetEvents = function() {
                for (var now = this._getNow(), _bufferSize = this._bufferSize, _windowTime = this._windowTime, _events = this._events, eventsCount = _events.length, spliceCount = 0; spliceCount < eventsCount && !(now - _events[spliceCount].time < _windowTime); ) spliceCount++;
                return eventsCount > _bufferSize && (spliceCount = Math.max(spliceCount, eventsCount - _bufferSize)), 
                spliceCount > 0 && _events.splice(0, spliceCount), _events;
            }, ReplaySubject;
        }(Subject_Subject), ReplayEvent = function() {
            return function(time, value) {
                this.time = time, this.value = value;
            };
        }(), scrolling_es5_ScrollDispatcher = function() {
            function ScrollDispatcher(_ngZone, _platform) {
                this._ngZone = _ngZone, this._platform = _platform, this._scrolled = new Subject_Subject(), 
                this._globalSubscription = null, this._scrolledCount = 0, this.scrollContainers = new Map();
            }
            return ScrollDispatcher.prototype.register = function(scrollable) {
                var _this = this, scrollSubscription = scrollable.elementScrolled().subscribe(function() {
                    return _this._scrolled.next(scrollable);
                });
                this.scrollContainers.set(scrollable, scrollSubscription);
            }, ScrollDispatcher.prototype.deregister = function(scrollable) {
                var scrollableReference = this.scrollContainers.get(scrollable);
                scrollableReference && (scrollableReference.unsubscribe(), this.scrollContainers.delete(scrollable));
            }, ScrollDispatcher.prototype.scrolled = function(auditTimeInMs) {
                var _this = this;
                return void 0 === auditTimeInMs && (auditTimeInMs = 20), this._platform.isBrowser ? Observable_Observable.create(function(observer) {
                    _this._globalSubscription || _this._addGlobalListener();
                    var subscription = auditTimeInMs > 0 ? _this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) : _this._scrolled.subscribe(observer);
                    return _this._scrolledCount++, function() {
                        subscription.unsubscribe(), _this._scrolledCount--, _this._scrolledCount || _this._removeGlobalListener();
                    };
                }) : of();
            }, ScrollDispatcher.prototype.ngOnDestroy = function() {
                var _this = this;
                this._removeGlobalListener(), this.scrollContainers.forEach(function(_, container) {
                    return _this.deregister(container);
                }), this._scrolled.complete();
            }, ScrollDispatcher.prototype.ancestorScrolled = function(elementRef, auditTimeInMs) {
                var ancestors = this.getAncestorScrollContainers(elementRef);
                return this.scrolled(auditTimeInMs).pipe(filter(function(target) {
                    return !target || ancestors.indexOf(target) > -1;
                }));
            }, ScrollDispatcher.prototype.getAncestorScrollContainers = function(elementRef) {
                var _this = this, scrollingContainers = [];
                return this.scrollContainers.forEach(function(_subscription, scrollable) {
                    _this._scrollableContainsElement(scrollable, elementRef) && scrollingContainers.push(scrollable);
                }), scrollingContainers;
            }, ScrollDispatcher.prototype._scrollableContainsElement = function(scrollable, elementRef) {
                var element = elementRef.nativeElement, scrollableElement = scrollable.getElementRef().nativeElement;
                do {
                    if (element == scrollableElement) return !0;
                } while (element = element.parentElement);
                return !1;
            }, ScrollDispatcher.prototype._addGlobalListener = function() {
                var _this = this;
                this._globalSubscription = this._ngZone.runOutsideAngular(function() {
                    return fromEvent(window.document, "scroll").subscribe(function() {
                        return _this._scrolled.next();
                    });
                });
            }, ScrollDispatcher.prototype._removeGlobalListener = function() {
                this._globalSubscription && (this._globalSubscription.unsubscribe(), this._globalSubscription = null);
            }, ScrollDispatcher.ngInjectableDef = defineInjectable({
                factory: function() {
                    return new ScrollDispatcher(inject(NgZone), inject(platform_es5_Platform));
                },
                token: ScrollDispatcher,
                providedIn: "root"
            }), ScrollDispatcher.ngInjectableDef = defineInjectable({
                token: ScrollDispatcher,
                factory: function(t) {
                    return new (t || ScrollDispatcher)(inject(NgZone), inject(platform_es5_Platform));
                },
                providedIn: "root"
            }), ScrollDispatcher;
        }(), scrolling_es5_CdkScrollable = function() {
            function CdkScrollable(elementRef, scrollDispatcher, ngZone, dir) {
                var _this = this;
                this.elementRef = elementRef, this.scrollDispatcher = scrollDispatcher, this.ngZone = ngZone, 
                this.dir = dir, this._destroyed = new Subject_Subject(), this._elementScrolled = Observable_Observable.create(function(observer) {
                    return _this.ngZone.runOutsideAngular(function() {
                        return fromEvent(_this.elementRef.nativeElement, "scroll").pipe(takeUntil(_this._destroyed)).subscribe(observer);
                    });
                });
            }
            return CdkScrollable.prototype.ngOnInit = function() {
                this.scrollDispatcher.register(this);
            }, CdkScrollable.prototype.ngOnDestroy = function() {
                this.scrollDispatcher.deregister(this), this._destroyed.next(), this._destroyed.complete();
            }, CdkScrollable.prototype.elementScrolled = function() {
                return this._elementScrolled;
            }, CdkScrollable.prototype.getElementRef = function() {
                return this.elementRef;
            }, CdkScrollable.prototype.scrollTo = function(options) {
                var el = this.elementRef.nativeElement, isRtl = this.dir && "rtl" == this.dir.value;
                options.left = null == options.left ? isRtl ? options.end : options.start : options.left, 
                options.right = null == options.right ? isRtl ? options.start : options.end : options.right, 
                null != options.bottom && (options.top = el.scrollHeight - el.clientHeight - options.bottom), 
                isRtl && getRtlScrollAxisType() != RtlScrollAxisType.NORMAL ? (null != options.left && (options.right = el.scrollWidth - el.clientWidth - options.left), 
                getRtlScrollAxisType() == RtlScrollAxisType.INVERTED ? options.left = options.right : getRtlScrollAxisType() == RtlScrollAxisType.NEGATED && (options.left = options.right ? -options.right : options.right)) : null != options.right && (options.left = el.scrollWidth - el.clientWidth - options.right), 
                this._applyScrollToOptions(options);
            }, CdkScrollable.prototype._applyScrollToOptions = function(options) {
                var el = this.elementRef.nativeElement;
                "object" == typeof document && "scrollBehavior" in document.documentElement.style ? el.scrollTo(options) : (null != options.top && (el.scrollTop = options.top), 
                null != options.left && (el.scrollLeft = options.left));
            }, CdkScrollable.prototype.measureScrollOffset = function(from) {
                var el = this.elementRef.nativeElement;
                if ("top" == from) return el.scrollTop;
                if ("bottom" == from) return el.scrollHeight - el.clientHeight - el.scrollTop;
                var isRtl = this.dir && "rtl" == this.dir.value;
                return "start" == from ? from = isRtl ? "right" : "left" : "end" == from && (from = isRtl ? "left" : "right"), 
                isRtl && getRtlScrollAxisType() == RtlScrollAxisType.INVERTED ? "left" == from ? el.scrollWidth - el.clientWidth - el.scrollLeft : el.scrollLeft : isRtl && getRtlScrollAxisType() == RtlScrollAxisType.NEGATED ? "left" == from ? el.scrollLeft + el.scrollWidth - el.clientWidth : -el.scrollLeft : "left" == from ? el.scrollLeft : el.scrollWidth - el.clientWidth - el.scrollLeft;
            }, CdkScrollable.ngDirectiveDef = defineDirective({
                type: CdkScrollable,
                selectors: [ [ "", "cdk-scrollable", "" ], [ "", "cdkScrollable", "" ] ],
                factory: function(t) {
                    return new (t || CdkScrollable)(directiveInject(ElementRef), directiveInject(scrolling_es5_ScrollDispatcher), directiveInject(NgZone), directiveInject(bidi_es5_Directionality, 8));
                }
            }), CdkScrollable;
        }(), scrolling_es5_ScrollingModule = function() {
            function ScrollingModule() {}
            return ScrollingModule.ngModuleDef = defineNgModule({
                type: ScrollingModule
            }), ScrollingModule.ngInjectorDef = defineInjector({
                factory: function(t) {
                    return new (t || ScrollingModule)();
                },
                imports: [ [ bidi_es5_BidiModule, platform_es5_PlatformModule ], bidi_es5_BidiModule ]
            }), ScrollingModule;
        }();
        const sidenav_es5_c0 = [ 1, "mat-drawer-content" ], sidenav_es5_c1 = [ "margin-left", "margin-right" ], sidenav_es5_c2 = [], sidenav_es5_c3 = [ "tabIndex", "-1", 1, "mat-drawer" ], sidenav_es5_c4 = [ "mat-drawer-end", "mat-drawer-over", "mat-drawer-push", "mat-drawer-side" ], sidenav_es5_c5 = [ 1, "mat-drawer-inner-container" ], sidenav_es5_c6 = [ 1, "mat-drawer-container" ], sidenav_es5_c7 = [ "mat-drawer-container-explicit-backdrop" ], sidenav_es5_c8 = [ "class", "mat-drawer-backdrop", 3, "mat-drawer-shown", "click", 4, "ngIf" ], sidenav_es5_c9 = [ 4, "ngIf" ], sidenav_es5_c10 = [ 1, "mat-drawer-backdrop", 3, "click" ], sidenav_es5_c11 = [ "mat-drawer-shown" ];
        function MatDrawerContainer_div_0_Template(rf, ctx) {
            if (1 & rf) {
                const _r207 = getCurrentView();
                elementStart(0, "div", sidenav_es5_c10), elementStyling(sidenav_es5_c11), listener("click", function($event) {
                    return restoreView(_r207), nextContext()._onBackdropClicked();
                }), elementEnd();
            }
            2 & rf && (elementClassProp(0, 0, nextContext()._isShowingBackdrop()), elementStylingApply(0));
        }
        function MatDrawerContainer_mat_drawer_content_3_Template(rf, ctx) {
            1 & rf && (elementStart(0, "mat-drawer-content"), projection(1), elementEnd());
        }
        const sidenav_es5_c12 = [ [ [ "mat-drawer" ] ], [ [ "mat-drawer-content" ] ] ], sidenav_es5_c13 = [ "mat-drawer", "mat-drawer-content" ], sidenav_es5_c14 = [ 1, "mat-drawer-content", "mat-sidenav-content" ], sidenav_es5_c15 = [ "tabIndex", "-1", 1, "mat-drawer", "mat-sidenav" ], sidenav_es5_c16 = [ "mat-drawer-end", "mat-drawer-over", "mat-drawer-push", "mat-drawer-side", "mat-sidenav-fixed" ], _c17 = [ "top", "bottom" ], _c18 = [ 1, "mat-drawer-container", "mat-sidenav-container" ], _c19 = [ "cdkScrollable", "", 4, "ngIf" ];
        function MatSidenavContainer_div_0_Template(rf, ctx) {
            if (1 & rf) {
                const _r211 = getCurrentView();
                elementStart(0, "div", sidenav_es5_c10), elementStyling(sidenav_es5_c11), listener("click", function($event) {
                    return restoreView(_r211), nextContext()._onBackdropClicked();
                }), elementEnd();
            }
            2 & rf && (elementClassProp(0, 0, nextContext()._isShowingBackdrop()), elementStylingApply(0));
        }
        const _c20 = [ "cdkScrollable", "" ];
        function MatSidenavContainer_mat_sidenav_content_3_Template(rf, ctx) {
            1 & rf && (elementStart(0, "mat-sidenav-content", _c20), projection(1), elementEnd());
        }
        const _c21 = [ [ [ "mat-sidenav" ] ], [ [ "mat-sidenav-content" ] ] ], _c22 = [ "mat-sidenav", "mat-sidenav-content" ];
        var matDrawerAnimations = {
            transformDrawer: trigger("transform", [ state("open, open-instant", animations_style({
                transform: "none",
                visibility: "visible"
            })), state("void", animations_style({
                "box-shadow": "none",
                visibility: "hidden"
            })), transition("void => open-instant", animate("0ms")), transition("void <=> open, open-instant => void", animate("400ms cubic-bezier(0.25, 0.8, 0.25, 1)")) ])
        };
        function throwMatDuplicatedDrawerError(position) {
            throw Error("A drawer was already declared for 'position=\"" + position + "\"'");
        }
        var MAT_DRAWER_DEFAULT_AUTOSIZE = new InjectionToken("MAT_DRAWER_DEFAULT_AUTOSIZE", {
            providedIn: "root",
            factory: function() {
                return !1;
            }
        }), sidenav_es5_MatDrawerContent = function(_super) {
            function MatDrawerContent(_changeDetectorRef, _container, elementRef, scrollDispatcher, ngZone) {
                var _this = _super.call(this, elementRef, scrollDispatcher, ngZone) || this;
                return _this._changeDetectorRef = _changeDetectorRef, _this._container = _container, 
                _this;
            }
            return __extends(MatDrawerContent, _super), MatDrawerContent.prototype.ngAfterContentInit = function() {
                var _this = this;
                this._container._contentMarginChanges.subscribe(function() {
                    _this._changeDetectorRef.markForCheck();
                });
            }, MatDrawerContent.ngComponentDef = defineComponent({
                type: MatDrawerContent,
                selectors: [ [ "mat-drawer-content" ] ],
                factory: function(t) {
                    return new (t || MatDrawerContent)(directiveInject(ChangeDetectorRef), directiveInject(forwardRef(function() {
                        return sidenav_es5_MatDrawerContainer;
                    })), directiveInject(ElementRef), directiveInject(scrolling_es5_ScrollDispatcher), directiveInject(NgZone));
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (elementHostAttrs(sidenav_es5_c0), elementHostStyling(null, sidenav_es5_c1)), 
                    2 & rf && (elementHostStyleProp(0, ctx._container._contentMargins.left, "px"), elementHostStyleProp(1, ctx._container._contentMargins.right, "px"), 
                    elementHostStylingApply());
                },
                features: [ InheritDefinitionFeature ],
                ngContentSelectors: sidenav_es5_c2,
                consts: 1,
                vars: 0,
                template: function(rf, ctx) {
                    1 & rf && (projectionDef(), projection(0));
                },
                encapsulation: 2,
                changeDetection: 0
            }), MatDrawerContent;
        }(scrolling_es5_CdkScrollable), sidenav_es5_MatDrawer = function() {
            function MatDrawer(_elementRef, _focusTrapFactory, _focusMonitor, _platform, _ngZone, _doc) {
                var _this = this;
                this._elementRef = _elementRef, this._focusTrapFactory = _focusTrapFactory, this._focusMonitor = _focusMonitor, 
                this._platform = _platform, this._ngZone = _ngZone, this._doc = _doc, this._elementFocusedBeforeDrawerWasOpened = null, 
                this._enableAnimations = !1, this._position = "start", this._mode = "over", this._disableClose = !1, 
                this._autoFocus = !0, this._animationStarted = new core_EventEmitter(), this._animationState = "void", 
                this.openedChange = new core_EventEmitter(!0), this.onPositionChanged = new core_EventEmitter(), 
                this._modeChanged = new Subject_Subject(), this._opened = !1, this.openedChange.subscribe(function(opened) {
                    opened ? (_this._doc && (_this._elementFocusedBeforeDrawerWasOpened = _this._doc.activeElement), 
                    _this._isFocusTrapEnabled && _this._focusTrap && _this._trapFocus()) : _this._restoreFocus();
                }), this._ngZone.runOutsideAngular(function() {
                    fromEvent(_this._elementRef.nativeElement, "keydown").pipe(filter(function(event) {
                        return event.keyCode === ESCAPE && !_this.disableClose;
                    })).subscribe(function(event) {
                        return _this._ngZone.run(function() {
                            _this.close(), event.stopPropagation();
                        });
                    });
                });
            }
            return Object.defineProperty(MatDrawer.prototype, "position", {
                get: function() {
                    return this._position;
                },
                set: function(value) {
                    (value = "end" === value ? "end" : "start") != this._position && (this._position = value, 
                    this.onPositionChanged.emit());
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(MatDrawer.prototype, "mode", {
                get: function() {
                    return this._mode;
                },
                set: function(value) {
                    this._mode = value, this._modeChanged.next();
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(MatDrawer.prototype, "disableClose", {
                get: function() {
                    return this._disableClose;
                },
                set: function(value) {
                    this._disableClose = coerceBooleanProperty(value);
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(MatDrawer.prototype, "autoFocus", {
                get: function() {
                    return this._autoFocus;
                },
                set: function(value) {
                    this._autoFocus = coerceBooleanProperty(value);
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(MatDrawer.prototype, "_openedStream", {
                get: function() {
                    return this.openedChange.pipe(filter(function(o) {
                        return o;
                    }), map_map(function() {}));
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(MatDrawer.prototype, "openedStart", {
                get: function() {
                    return this._animationStarted.pipe(filter(function(e) {
                        return e.fromState !== e.toState && 0 === e.toState.indexOf("open");
                    }), map_map(function() {}));
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(MatDrawer.prototype, "_closedStream", {
                get: function() {
                    return this.openedChange.pipe(filter(function(o) {
                        return !o;
                    }), map_map(function() {}));
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(MatDrawer.prototype, "closedStart", {
                get: function() {
                    return this._animationStarted.pipe(filter(function(e) {
                        return e.fromState !== e.toState && "void" === e.toState;
                    }), map_map(function() {}));
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(MatDrawer.prototype, "_isFocusTrapEnabled", {
                get: function() {
                    return this.opened && "side" !== this.mode;
                },
                enumerable: !0,
                configurable: !0
            }), MatDrawer.prototype._trapFocus = function() {
                var _this = this;
                this.autoFocus && this._focusTrap.focusInitialElementWhenReady().then(function(hasMovedFocus) {
                    hasMovedFocus || "function" != typeof _this._elementRef.nativeElement.focus || _this._elementRef.nativeElement.focus();
                });
            }, MatDrawer.prototype._restoreFocus = function() {
                if (this.autoFocus) {
                    var activeEl = this._doc && this._doc.activeElement;
                    activeEl && this._elementRef.nativeElement.contains(activeEl) && (this._elementFocusedBeforeDrawerWasOpened instanceof HTMLElement ? this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened, this._openedVia) : this._elementRef.nativeElement.blur()), 
                    this._elementFocusedBeforeDrawerWasOpened = null, this._openedVia = null;
                }
            }, MatDrawer.prototype.ngAfterContentInit = function() {
                this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement), 
                this._focusTrap.enabled = this._isFocusTrapEnabled;
            }, MatDrawer.prototype.ngAfterContentChecked = function() {
                this._platform.isBrowser && (this._enableAnimations = !0);
            }, MatDrawer.prototype.ngOnDestroy = function() {
                this._focusTrap && this._focusTrap.destroy();
            }, Object.defineProperty(MatDrawer.prototype, "opened", {
                get: function() {
                    return this._opened;
                },
                set: function(value) {
                    this.toggle(coerceBooleanProperty(value));
                },
                enumerable: !0,
                configurable: !0
            }), MatDrawer.prototype.open = function(openedVia) {
                return this.toggle(!0, openedVia);
            }, MatDrawer.prototype.close = function() {
                return this.toggle(!1);
            }, MatDrawer.prototype.toggle = function(isOpen, openedVia) {
                var _this = this;
                return void 0 === isOpen && (isOpen = !this.opened), void 0 === openedVia && (openedVia = "program"), 
                this._opened = isOpen, isOpen ? (this._animationState = this._enableAnimations ? "open" : "open-instant", 
                this._openedVia = openedVia) : (this._animationState = "void", this._restoreFocus()), 
                this._focusTrap && (this._focusTrap.enabled = this._isFocusTrapEnabled), new Promise(function(resolve) {
                    _this.openedChange.pipe(take(1)).subscribe(function(open) {
                        return resolve(open ? "open" : "close");
                    });
                });
            }, MatDrawer.prototype._onAnimationStart = function(event) {
                this._animationStarted.emit(event);
            }, MatDrawer.prototype._onAnimationEnd = function(event) {
                var fromState = event.fromState, toState = event.toState;
                (0 === toState.indexOf("open") && "void" === fromState || "void" === toState && 0 === fromState.indexOf("open")) && this.openedChange.emit(this._opened);
            }, Object.defineProperty(MatDrawer.prototype, "_width", {
                get: function() {
                    return this._elementRef.nativeElement && this._elementRef.nativeElement.offsetWidth || 0;
                },
                enumerable: !0,
                configurable: !0
            }), MatDrawer.ngComponentDef = defineComponent({
                type: MatDrawer,
                selectors: [ [ "mat-drawer" ] ],
                factory: function(t) {
                    return new (t || MatDrawer)(directiveInject(ElementRef), directiveInject(a11y_es5_FocusTrapFactory), directiveInject(a11y_es5_FocusMonitor), directiveInject(platform_es5_Platform), directiveInject(NgZone), directiveInject(DOCUMENT, 8));
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (allocHostVars(2), componentHostSyntheticListener("@transform.start", function($event) {
                        return ctx._onAnimationStart($event);
                    }), componentHostSyntheticListener("@transform.done", function($event) {
                        return ctx._onAnimationEnd($event);
                    }), elementHostAttrs(sidenav_es5_c3), elementHostStyling(sidenav_es5_c4)), 2 & rf && (componentHostSyntheticProperty(elIndex, "@transform", bind(ctx._animationState), null, !0), 
                    elementAttribute(elIndex, "align", bind(null)), elementHostClassProp(0, "end" === ctx.position), 
                    elementHostClassProp(1, "over" === ctx.mode), elementHostClassProp(2, "push" === ctx.mode), 
                    elementHostClassProp(3, "side" === ctx.mode), elementHostStylingApply());
                },
                inputs: {
                    position: "position",
                    mode: "mode",
                    disableClose: "disableClose",
                    autoFocus: "autoFocus",
                    opened: "opened"
                },
                outputs: {
                    openedChange: "openedChange",
                    onPositionChanged: "positionChanged",
                    _openedStream: "opened",
                    openedStart: "openedStart",
                    _closedStream: "closed",
                    closedStart: "closedStart"
                },
                exportAs: [ "matDrawer" ],
                ngContentSelectors: sidenav_es5_c2,
                consts: 2,
                vars: 0,
                template: function(rf, ctx) {
                    1 & rf && (projectionDef(), elementStart(0, "div", sidenav_es5_c5), projection(1), 
                    elementEnd());
                },
                encapsulation: 2,
                data: {
                    animation: [ matDrawerAnimations.transformDrawer ]
                },
                changeDetection: 0
            }), MatDrawer;
        }(), sidenav_es5_MatDrawerContainer = function() {
            function MatDrawerContainer(_dir, _element, _ngZone, _changeDetectorRef, defaultAutosize, _animationMode) {
                void 0 === defaultAutosize && (defaultAutosize = !1);
                var _this = this;
                this._dir = _dir, this._element = _element, this._ngZone = _ngZone, this._changeDetectorRef = _changeDetectorRef, 
                this._animationMode = _animationMode, this.backdropClick = new core_EventEmitter(), 
                this._destroyed = new Subject_Subject(), this._doCheckSubject = new Subject_Subject(), 
                this._contentMargins = {
                    left: null,
                    right: null
                }, this._contentMarginChanges = new Subject_Subject(), _dir && _dir.change.pipe(takeUntil(this._destroyed)).subscribe(function() {
                    _this._validateDrawers(), _this._updateContentMargins();
                }), this._autosize = defaultAutosize;
            }
            return Object.defineProperty(MatDrawerContainer.prototype, "start", {
                get: function() {
                    return this._start;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(MatDrawerContainer.prototype, "end", {
                get: function() {
                    return this._end;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(MatDrawerContainer.prototype, "autosize", {
                get: function() {
                    return this._autosize;
                },
                set: function(value) {
                    this._autosize = coerceBooleanProperty(value);
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(MatDrawerContainer.prototype, "hasBackdrop", {
                get: function() {
                    return null == this._backdropOverride ? !this._start || "side" !== this._start.mode || !this._end || "side" !== this._end.mode : this._backdropOverride;
                },
                set: function(value) {
                    this._backdropOverride = null == value ? null : coerceBooleanProperty(value);
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(MatDrawerContainer.prototype, "scrollable", {
                get: function() {
                    return this._userContent || this._content;
                },
                enumerable: !0,
                configurable: !0
            }), MatDrawerContainer.prototype.ngAfterContentInit = function() {
                var _this = this;
                this._drawers.changes.pipe(function() {
                    for (var array = [], _i = 0; _i < arguments.length; _i++) array[_i] = arguments[_i];
                    return function(source) {
                        var scheduler = array[array.length - 1];
                        isScheduler(scheduler) ? array.pop() : scheduler = null;
                        var len = array.length;
                        return concat(1 !== len || scheduler ? len > 0 ? fromArray(array, scheduler) : empty_empty(scheduler) : scalar(array[0]), source);
                    };
                }(null)).subscribe(function() {
                    _this._validateDrawers(), _this._drawers.forEach(function(drawer) {
                        _this._watchDrawerToggle(drawer), _this._watchDrawerPosition(drawer), _this._watchDrawerMode(drawer);
                    }), (!_this._drawers.length || _this._isDrawerOpen(_this._start) || _this._isDrawerOpen(_this._end)) && _this._updateContentMargins(), 
                    _this._changeDetectorRef.markForCheck();
                }), this._doCheckSubject.pipe(debounceTime(10), takeUntil(this._destroyed)).subscribe(function() {
                    return _this._updateContentMargins();
                });
            }, MatDrawerContainer.prototype.ngOnDestroy = function() {
                this._doCheckSubject.complete(), this._destroyed.next(), this._destroyed.complete();
            }, MatDrawerContainer.prototype.open = function() {
                this._drawers.forEach(function(drawer) {
                    return drawer.open();
                });
            }, MatDrawerContainer.prototype.close = function() {
                this._drawers.forEach(function(drawer) {
                    return drawer.close();
                });
            }, MatDrawerContainer.prototype.ngDoCheck = function() {
                var _this = this;
                this._autosize && this._isPushed() && this._ngZone.runOutsideAngular(function() {
                    return _this._doCheckSubject.next();
                });
            }, MatDrawerContainer.prototype._watchDrawerToggle = function(drawer) {
                var _this = this;
                drawer._animationStarted.pipe(takeUntil(this._drawers.changes), filter(function(event) {
                    return event.fromState !== event.toState;
                })).subscribe(function(event) {
                    "open-instant" !== event.toState && "NoopAnimations" !== _this._animationMode && _this._element.nativeElement.classList.add("mat-drawer-transition"), 
                    _this._updateContentMargins(), _this._changeDetectorRef.markForCheck();
                }), "side" !== drawer.mode && drawer.openedChange.pipe(takeUntil(this._drawers.changes)).subscribe(function() {
                    return _this._setContainerClass(drawer.opened);
                });
            }, MatDrawerContainer.prototype._watchDrawerPosition = function(drawer) {
                var _this = this;
                drawer && drawer.onPositionChanged.pipe(takeUntil(this._drawers.changes)).subscribe(function() {
                    _this._ngZone.onMicrotaskEmpty.asObservable().pipe(take(1)).subscribe(function() {
                        _this._validateDrawers();
                    });
                });
            }, MatDrawerContainer.prototype._watchDrawerMode = function(drawer) {
                var _this = this;
                drawer && drawer._modeChanged.pipe(takeUntil(merge(this._drawers.changes, this._destroyed))).subscribe(function() {
                    _this._updateContentMargins(), _this._changeDetectorRef.markForCheck();
                });
            }, MatDrawerContainer.prototype._setContainerClass = function(isAdd) {
                isAdd ? this._element.nativeElement.classList.add("mat-drawer-opened") : this._element.nativeElement.classList.remove("mat-drawer-opened");
            }, MatDrawerContainer.prototype._validateDrawers = function() {
                var _this = this;
                this._start = this._end = null, this._drawers.forEach(function(drawer) {
                    "end" == drawer.position ? (null != _this._end && throwMatDuplicatedDrawerError("end"), 
                    _this._end = drawer) : (null != _this._start && throwMatDuplicatedDrawerError("start"), 
                    _this._start = drawer);
                }), this._right = this._left = null, this._dir && "rtl" === this._dir.value ? (this._left = this._end, 
                this._right = this._start) : (this._left = this._start, this._right = this._end);
            }, MatDrawerContainer.prototype._isPushed = function() {
                return this._isDrawerOpen(this._start) && "over" != this._start.mode || this._isDrawerOpen(this._end) && "over" != this._end.mode;
            }, MatDrawerContainer.prototype._onBackdropClicked = function() {
                this.backdropClick.emit(), this._closeModalDrawer();
            }, MatDrawerContainer.prototype._closeModalDrawer = function() {
                var _this = this;
                [ this._start, this._end ].filter(function(drawer) {
                    return drawer && !drawer.disableClose && _this._canHaveBackdrop(drawer);
                }).forEach(function(drawer) {
                    return drawer.close();
                });
            }, MatDrawerContainer.prototype._isShowingBackdrop = function() {
                return this._isDrawerOpen(this._start) && this._canHaveBackdrop(this._start) || this._isDrawerOpen(this._end) && this._canHaveBackdrop(this._end);
            }, MatDrawerContainer.prototype._canHaveBackdrop = function(drawer) {
                return "side" !== drawer.mode || !!this._backdropOverride;
            }, MatDrawerContainer.prototype._isDrawerOpen = function(drawer) {
                return null != drawer && drawer.opened;
            }, MatDrawerContainer.prototype._updateContentMargins = function() {
                var _this = this, left = 0, right = 0;
                if (this._left && this._left.opened && ("side" == this._left.mode ? left += this._left._width : "push" == this._left.mode && (left += width = this._left._width, 
                right -= width)), this._right && this._right.opened) if ("side" == this._right.mode) right += this._right._width; else if ("push" == this._right.mode) {
                    var width;
                    right += width = this._right._width, left -= width;
                }
                right = right || null, (left = left || null) === this._contentMargins.left && right === this._contentMargins.right || (this._contentMargins = {
                    left: left,
                    right: right
                }, this._ngZone.run(function() {
                    return _this._contentMarginChanges.next(_this._contentMargins);
                }));
            }, MatDrawerContainer.ngComponentDef = defineComponent({
                type: MatDrawerContainer,
                selectors: [ [ "mat-drawer-container" ] ],
                factory: function(t) {
                    return new (t || MatDrawerContainer)(directiveInject(bidi_es5_Directionality, 8), directiveInject(ElementRef), directiveInject(NgZone), directiveInject(ChangeDetectorRef), directiveInject(MAT_DRAWER_DEFAULT_AUTOSIZE), directiveInject(ANIMATION_MODULE_TYPE, 8));
                },
                contentQueries: function(rf, ctx, dirIndex) {
                    var _t;
                    1 & rf && (contentQuery(dirIndex, sidenav_es5_MatDrawerContent, !0, null), contentQuery(dirIndex, sidenav_es5_MatDrawer, !1, null)), 
                    2 & rf && (queryRefresh(_t = loadContentQuery()) && (ctx._content = _t.first), queryRefresh(_t = loadContentQuery()) && (ctx._drawers = _t));
                },
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && viewQuery(sidenav_es5_MatDrawerContent, !0, null), 2 & rf && queryRefresh(_t = loadViewQuery()) && (ctx._userContent = _t.first);
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (elementHostAttrs(sidenav_es5_c6), elementHostStyling(sidenav_es5_c7)), 
                    2 & rf && (elementHostClassProp(0, ctx._backdropOverride), elementHostStylingApply());
                },
                inputs: {
                    autosize: "autosize",
                    hasBackdrop: "hasBackdrop"
                },
                outputs: {
                    backdropClick: "backdropClick"
                },
                exportAs: [ "matDrawerContainer" ],
                ngContentSelectors: sidenav_es5_c13,
                consts: 4,
                vars: 2,
                template: function(rf, ctx) {
                    1 & rf && (projectionDef(sidenav_es5_c12, sidenav_es5_c13), template(0, MatDrawerContainer_div_0_Template, 1, 0, "div", sidenav_es5_c8), 
                    projection(1, 1), projection(2, 2), template(3, MatDrawerContainer_mat_drawer_content_3_Template, 2, 0, "mat-drawer-content", sidenav_es5_c9)), 
                    2 & rf && (core_select(0), elementProperty(0, "ngIf", bind(ctx.hasBackdrop)), core_select(3), 
                    elementProperty(3, "ngIf", bind(!ctx._content)));
                },
                directives: [ common_NgIf, sidenav_es5_MatDrawerContent ],
                styles: [ ".mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-opened{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:.4s;transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-property:background-color,visibility}@media screen and (-ms-high-contrast:active){.mat-drawer-backdrop{opacity:.5}}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:.4s;transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%,0,0)}@media screen and (-ms-high-contrast:active){.mat-drawer,[dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}}@media screen and (-ms-high-contrast:active){.mat-drawer.mat-drawer-end,[dir=rtl] .mat-drawer{border-left:solid 1px currentColor;border-right:none}}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%,0,0)}[dir=rtl] .mat-drawer{transform:translate3d(100%,0,0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%,0,0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}" ],
                encapsulation: 2,
                changeDetection: 0
            }), MatDrawerContainer;
        }(), sidenav_es5_MatSidenavContent = function(_super) {
            function MatSidenavContent(changeDetectorRef, container, elementRef, scrollDispatcher, ngZone) {
                return _super.call(this, changeDetectorRef, container, elementRef, scrollDispatcher, ngZone) || this;
            }
            return __extends(MatSidenavContent, _super), MatSidenavContent.ngComponentDef = defineComponent({
                type: MatSidenavContent,
                selectors: [ [ "mat-sidenav-content" ] ],
                factory: function(t) {
                    return new (t || MatSidenavContent)(directiveInject(ChangeDetectorRef), directiveInject(forwardRef(function() {
                        return sidenav_es5_MatSidenavContainer;
                    })), directiveInject(ElementRef), directiveInject(scrolling_es5_ScrollDispatcher), directiveInject(NgZone));
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (elementHostAttrs(sidenav_es5_c14), elementHostStyling(null, sidenav_es5_c1)), 
                    2 & rf && (elementHostStyleProp(0, ctx._container._contentMargins.left, "px"), elementHostStyleProp(1, ctx._container._contentMargins.right, "px"), 
                    elementHostStylingApply());
                },
                features: [ InheritDefinitionFeature ],
                ngContentSelectors: sidenav_es5_c2,
                consts: 1,
                vars: 0,
                template: function(rf, ctx) {
                    1 & rf && (projectionDef(), projection(0));
                },
                encapsulation: 2,
                changeDetection: 0
            }), MatSidenavContent;
        }(sidenav_es5_MatDrawerContent), sidenav_es5_MatSidenav = function(_super) {
            function MatSidenav() {
                var _this = null !== _super && _super.apply(this, arguments) || this;
                return _this._fixedInViewport = !1, _this._fixedTopGap = 0, _this._fixedBottomGap = 0, 
                _this;
            }
            __extends(MatSidenav, _super), Object.defineProperty(MatSidenav.prototype, "fixedInViewport", {
                get: function() {
                    return this._fixedInViewport;
                },
                set: function(value) {
                    this._fixedInViewport = coerceBooleanProperty(value);
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(MatSidenav.prototype, "fixedTopGap", {
                get: function() {
                    return this._fixedTopGap;
                },
                set: function(value) {
                    this._fixedTopGap = coerceNumberProperty(value);
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(MatSidenav.prototype, "fixedBottomGap", {
                get: function() {
                    return this._fixedBottomGap;
                },
                set: function(value) {
                    this._fixedBottomGap = coerceNumberProperty(value);
                },
                enumerable: !0,
                configurable: !0
            }), MatSidenav.ngComponentDef = defineComponent({
                type: MatSidenav,
                selectors: [ [ "mat-sidenav" ] ],
                factory: function(t) {
                    return \u0275MatSidenav_BaseFactory(t || MatSidenav);
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (allocHostVars(2), componentHostSyntheticListener("@transform.start", function($event) {
                        return ctx._onAnimationStart($event);
                    }), componentHostSyntheticListener("@transform.done", function($event) {
                        return ctx._onAnimationEnd($event);
                    }), elementHostAttrs(sidenav_es5_c15), elementHostStyling(sidenav_es5_c16, _c17)), 
                    2 & rf && (componentHostSyntheticProperty(elIndex, "@transform", bind(ctx._animationState), null, !0), 
                    elementAttribute(elIndex, "align", bind(null)), elementHostStyleProp(0, ctx.fixedInViewport ? ctx.fixedTopGap : null, "px"), 
                    elementHostStyleProp(1, ctx.fixedInViewport ? ctx.fixedBottomGap : null, "px"), 
                    elementHostClassProp(0, "end" === ctx.position), elementHostClassProp(1, "over" === ctx.mode), 
                    elementHostClassProp(2, "push" === ctx.mode), elementHostClassProp(3, "side" === ctx.mode), 
                    elementHostClassProp(4, ctx.fixedInViewport), elementHostStylingApply());
                },
                inputs: {
                    fixedInViewport: "fixedInViewport",
                    fixedTopGap: "fixedTopGap",
                    fixedBottomGap: "fixedBottomGap"
                },
                exportAs: [ "matSidenav" ],
                features: [ InheritDefinitionFeature ],
                ngContentSelectors: sidenav_es5_c2,
                consts: 2,
                vars: 0,
                template: function(rf, ctx) {
                    1 & rf && (projectionDef(), elementStart(0, "div", sidenav_es5_c5), projection(1), 
                    elementEnd());
                },
                encapsulation: 2,
                data: {
                    animation: [ matDrawerAnimations.transformDrawer ]
                },
                changeDetection: 0
            });
            const \u0275MatSidenav_BaseFactory = getInheritedFactory(MatSidenav);
            return MatSidenav;
        }(sidenav_es5_MatDrawer), sidenav_es5_MatSidenavContainer = function(_super) {
            function MatSidenavContainer() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            __extends(MatSidenavContainer, _super), MatSidenavContainer.ngComponentDef = defineComponent({
                type: MatSidenavContainer,
                selectors: [ [ "mat-sidenav-container" ] ],
                factory: function(t) {
                    return \u0275MatSidenavContainer_BaseFactory(t || MatSidenavContainer);
                },
                contentQueries: function(rf, ctx, dirIndex) {
                    var _t;
                    1 & rf && (contentQuery(dirIndex, sidenav_es5_MatSidenavContent, !0, null), contentQuery(dirIndex, sidenav_es5_MatSidenav, !1, null)), 
                    2 & rf && (queryRefresh(_t = loadContentQuery()) && (ctx._content = _t.first), queryRefresh(_t = loadContentQuery()) && (ctx._drawers = _t));
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (elementHostAttrs(_c18), elementHostStyling(sidenav_es5_c7)), 2 & rf && (elementHostClassProp(0, ctx._backdropOverride), 
                    elementHostStylingApply());
                },
                exportAs: [ "matSidenavContainer" ],
                features: [ InheritDefinitionFeature ],
                ngContentSelectors: _c22,
                consts: 4,
                vars: 2,
                template: function(rf, ctx) {
                    1 & rf && (projectionDef(_c21, _c22), template(0, MatSidenavContainer_div_0_Template, 1, 0, "div", sidenav_es5_c8), 
                    projection(1, 1), projection(2, 2), template(3, MatSidenavContainer_mat_sidenav_content_3_Template, 2, 0, "mat-sidenav-content", _c19)), 
                    2 & rf && (core_select(0), elementProperty(0, "ngIf", bind(ctx.hasBackdrop)), core_select(3), 
                    elementProperty(3, "ngIf", bind(!ctx._content)));
                },
                directives: [ common_NgIf, scrolling_es5_CdkScrollable, sidenav_es5_MatSidenavContent ],
                styles: [ ".mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-opened{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:.4s;transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-property:background-color,visibility}@media screen and (-ms-high-contrast:active){.mat-drawer-backdrop{opacity:.5}}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:.4s;transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%,0,0)}@media screen and (-ms-high-contrast:active){.mat-drawer,[dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}}@media screen and (-ms-high-contrast:active){.mat-drawer.mat-drawer-end,[dir=rtl] .mat-drawer{border-left:solid 1px currentColor;border-right:none}}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%,0,0)}[dir=rtl] .mat-drawer{transform:translate3d(100%,0,0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%,0,0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}" ],
                encapsulation: 2,
                changeDetection: 0
            });
            const \u0275MatSidenavContainer_BaseFactory = getInheritedFactory(MatSidenavContainer);
            return MatSidenavContainer;
        }(sidenav_es5_MatDrawerContainer), sidenav_es5_MatSidenavModule = function() {
            function MatSidenavModule() {}
            return MatSidenavModule.ngModuleDef = defineNgModule({
                type: MatSidenavModule
            }), MatSidenavModule.ngInjectorDef = defineInjector({
                factory: function(t) {
                    return new (t || MatSidenavModule)();
                },
                imports: [ [ common_CommonModule, core_es5_MatCommonModule, scrolling_es5_ScrollingModule, platform_es5_PlatformModule ], core_es5_MatCommonModule ]
            }), MatSidenavModule;
        }();
        const toolbar_es5_c0 = [ 1, "mat-toolbar-row" ], toolbar_es5_c1 = [ 1, "mat-toolbar" ], toolbar_es5_c2 = [ "mat-toolbar-multiple-rows", "mat-toolbar-single-row" ], toolbar_es5_c3 = [ [ [ "mat-toolbar-row" ] ] ], toolbar_es5_c4 = [ "mat-toolbar-row" ];
        var _MatToolbarMixinBase = mixinColor(function() {
            return function(_elementRef) {
                this._elementRef = _elementRef;
            };
        }()), toolbar_es5_MatToolbarRow = function() {
            function MatToolbarRow() {}
            return MatToolbarRow.ngDirectiveDef = defineDirective({
                type: MatToolbarRow,
                selectors: [ [ "mat-toolbar-row" ] ],
                factory: function(t) {
                    return new (t || MatToolbarRow)();
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && elementHostAttrs(toolbar_es5_c0);
                },
                exportAs: [ "matToolbarRow" ]
            }), MatToolbarRow;
        }(), toolbar_es5_MatToolbar = function(_super) {
            function MatToolbar(elementRef, _platform, document) {
                var _this = _super.call(this, elementRef) || this;
                return _this._platform = _platform, _this._document = document, _this;
            }
            return __extends(MatToolbar, _super), MatToolbar.prototype.ngAfterViewInit = function() {
                var _this = this;
                isDevMode() && this._platform.isBrowser && (this._checkToolbarMixedModes(), this._toolbarRows.changes.subscribe(function() {
                    return _this._checkToolbarMixedModes();
                }));
            }, MatToolbar.prototype._checkToolbarMixedModes = function() {
                var _this = this;
                this._toolbarRows.length && Array.from(this._elementRef.nativeElement.childNodes).filter(function(node) {
                    return !(node.classList && node.classList.contains("mat-toolbar-row"));
                }).filter(function(node) {
                    return node.nodeType !== (_this._document ? _this._document.COMMENT_NODE : 8);
                }).some(function(node) {
                    return !(!node.textContent || !node.textContent.trim());
                }) && function() {
                    throw Error("MatToolbar: Attempting to combine different toolbar modes. Either specify multiple `<mat-toolbar-row>` elements explicitly or just place content inside of a `<mat-toolbar>` for a single row.");
                }();
            }, MatToolbar.ngComponentDef = defineComponent({
                type: MatToolbar,
                selectors: [ [ "mat-toolbar" ] ],
                factory: function(t) {
                    return new (t || MatToolbar)(directiveInject(ElementRef), directiveInject(platform_es5_Platform), directiveInject(DOCUMENT));
                },
                contentQueries: function(rf, ctx, dirIndex) {
                    var _t;
                    1 & rf && contentQuery(dirIndex, toolbar_es5_MatToolbarRow, !1, null), 2 & rf && queryRefresh(_t = loadContentQuery()) && (ctx._toolbarRows = _t);
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (elementHostAttrs(toolbar_es5_c1), elementHostStyling(toolbar_es5_c2)), 
                    2 & rf && (elementHostClassProp(0, ctx._toolbarRows.length > 0), elementHostClassProp(1, 0 === ctx._toolbarRows.length), 
                    elementHostStylingApply());
                },
                inputs: {
                    color: "color"
                },
                exportAs: [ "matToolbar" ],
                features: [ InheritDefinitionFeature ],
                ngContentSelectors: toolbar_es5_c4,
                consts: 2,
                vars: 0,
                template: function(rf, ctx) {
                    1 & rf && (projectionDef(toolbar_es5_c3, toolbar_es5_c4), projection(0), projection(1, 1));
                },
                styles: [ "@media screen and (-ms-high-contrast:active){.mat-toolbar{outline:solid 1px}}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}.mat-toolbar-multiple-rows{min-height:64px}.mat-toolbar-row,.mat-toolbar-single-row{height:64px}@media (max-width:599px){.mat-toolbar-multiple-rows{min-height:56px}.mat-toolbar-row,.mat-toolbar-single-row{height:56px}}" ],
                encapsulation: 2,
                changeDetection: 0
            }), MatToolbar;
        }(_MatToolbarMixinBase), toolbar_es5_MatToolbarModule = function() {
            function MatToolbarModule() {}
            return MatToolbarModule.ngModuleDef = defineNgModule({
                type: MatToolbarModule
            }), MatToolbarModule.ngInjectorDef = defineInjector({
                factory: function(t) {
                    return new (t || MatToolbarModule)();
                },
                imports: [ [ core_es5_MatCommonModule ], core_es5_MatCommonModule ]
            }), MatToolbarModule;
        }(), CurrentDateToken = new InjectionToken("CurrentDate");
        function currentDateProvider() {
            return new Date();
        }
        var WindowToken = new InjectionToken("Window");
        function windowProvider() {
            return window;
        }
        var notification_component_c0 = [ 1, "content", 3, "click" ], notification_component_c1 = [ "mat-icon-button", "", "aria-label", "Close", 1, "close-button", 3, "click" ], notification_component_c2 = [ "svgIcon", "close", "aria-label", "Dismiss notification" ], notification_component_c3 = [], notification_component_NotificationComponent = function() {
            function NotificationComponent(window, currentDate) {
                this.window = window, this.currentDate = currentDate, this.dismissed = new core_EventEmitter();
            }
            return Object.defineProperty(NotificationComponent.prototype, "localStorage", {
                get: function() {
                    return this.window.localStorage;
                },
                enumerable: !0,
                configurable: !0
            }), NotificationComponent.prototype.ngOnInit = function() {
                var previouslyHidden = "hide" === this.localStorage.getItem("aio-notification/" + this.notificationId), expired = this.currentDate > new Date(this.expirationDate);
                this.showNotification = previouslyHidden || expired ? "hide" : "show";
            }, NotificationComponent.prototype.contentClick = function() {
                this.dismissOnContentClick && this.dismiss();
            }, NotificationComponent.prototype.dismiss = function() {
                this.localStorage.setItem("aio-notification/" + this.notificationId, "hide"), this.showNotification = "hide", 
                this.dismissed.next();
            }, NotificationComponent.ngComponentDef = defineComponent({
                type: NotificationComponent,
                selectors: [ [ "aio-notification" ] ],
                factory: function(t) {
                    return new (t || NotificationComponent)(directiveInject(WindowToken), directiveInject(CurrentDateToken));
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && allocHostVars(1), 2 & rf && componentHostSyntheticProperty(elIndex, "@hideAnimation", bind(ctx.showNotification), null, !0);
                },
                inputs: {
                    dismissOnContentClick: "dismissOnContentClick",
                    notificationId: "notificationId",
                    expirationDate: "expirationDate"
                },
                outputs: {
                    dismissed: "dismissed"
                },
                ngContentSelectors: notification_component_c3,
                consts: 4,
                vars: 0,
                template: function(rf, ctx) {
                    1 & rf && (projectionDef(), elementStart(0, "span", notification_component_c0), 
                    listener("click", function($event) {
                        return ctx.contentClick();
                    }), projection(1), elementEnd(), elementStart(2, "button", notification_component_c1), 
                    listener("click", function($event) {
                        return ctx.dismiss();
                    }), core_element(3, "mat-icon", notification_component_c2), elementEnd());
                },
                directives: [ button_es5_MatButton, icon_es5_MatIcon ],
                encapsulation: 2,
                data: {
                    animation: [ trigger("hideAnimation", [ state("show", animations_style({
                        height: "*"
                    })), state("hide", animations_style({
                        height: 0
                    })), transition("show => hide", animate(250)) ]) ]
                }
            }), NotificationComponent;
        }();
        trigger("hideAnimation", [ state("show", animations_style({
            height: "*"
        })), state("hide", animations_style({
            height: 0
        })), transition("show => hide", animate(250)) ]);
        var ga_service_GaService = function() {
            function GaService(window) {
                this.window = window, this.ga("create", environment.gaId, "auto");
            }
            return GaService.prototype.locationChanged = function(url) {
                this.sendPage(url);
            }, GaService.prototype.sendPage = function(url) {
                url !== this.previousUrl && (this.previousUrl = url, this.ga("set", "page", "/" + url), 
                this.ga("send", "pageview"));
            }, GaService.prototype.sendEvent = function(source, action, label, value) {
                this.ga("send", "event", source, action, label, value);
            }, GaService.prototype.ga = function() {
                for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
                var gaFn = this.window.ga;
                gaFn && gaFn.apply(void 0, args);
            }, GaService.ngInjectableDef = defineInjectable({
                token: GaService,
                factory: function(t) {
                    return new (t || GaService)(inject(WindowToken));
                },
                providedIn: null
            }), GaService;
        }();
        function interval_dispatch(state) {
            var subscriber = state.subscriber, counter = state.counter, period = state.period;
            subscriber.next(counter), this.schedule({
                subscriber: subscriber,
                counter: counter + 1,
                period: period
            }, period);
        }
        function EmptyErrorImpl() {
            return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", 
            this;
        }
        EmptyErrorImpl.prototype = Object.create(Error.prototype);
        var EmptyError = EmptyErrorImpl, DefaultIfEmptyOperator = function() {
            function DefaultIfEmptyOperator(defaultValue) {
                this.defaultValue = defaultValue;
            }
            return DefaultIfEmptyOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new defaultIfEmpty_DefaultIfEmptySubscriber(subscriber, this.defaultValue));
            }, DefaultIfEmptyOperator;
        }(), defaultIfEmpty_DefaultIfEmptySubscriber = function(_super) {
            function DefaultIfEmptySubscriber(destination, defaultValue) {
                var _this = _super.call(this, destination) || this;
                return _this.defaultValue = defaultValue, _this.isEmpty = !0, _this;
            }
            return __extends(DefaultIfEmptySubscriber, _super), DefaultIfEmptySubscriber.prototype._next = function(value) {
                this.isEmpty = !1, this.destination.next(value);
            }, DefaultIfEmptySubscriber.prototype._complete = function() {
                this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete();
            }, DefaultIfEmptySubscriber;
        }(Subscriber_Subscriber), throwIfEmpty = function(errorFactory) {
            return void 0 === errorFactory && (errorFactory = defaultErrorFactory), tap({
                hasValue: !1,
                next: function() {
                    this.hasValue = !0;
                },
                complete: function() {
                    if (!this.hasValue) throw errorFactory();
                }
            });
        };
        function defaultErrorFactory() {
            return new EmptyError();
        }
        function first_first(predicate, defaultValue) {
            var hasDefaultValue = arguments.length >= 2;
            return function(source) {
                return source.pipe(predicate ? filter(function(v, i) {
                    return predicate(v, i, source);
                }) : identity, take(1), hasDefaultValue ? function(defaultValue) {
                    return void 0 === defaultValue && (defaultValue = null), function(source) {
                        return source.lift(new DefaultIfEmptyOperator(defaultValue));
                    };
                }(defaultValue) : throwIfEmpty(function() {
                    return new EmptyError();
                }));
            };
        }
        var logger_service_Logger = function() {
            function Logger(errorHandler) {
                this.errorHandler = errorHandler;
            }
            return Logger.prototype.log = function(value) {
                for (var rest = [], _i = 1; _i < arguments.length; _i++) rest[_i - 1] = arguments[_i];
                environment.production || console.log.apply(console, [ value ].concat(rest));
            }, Logger.prototype.error = function(error) {
                this.errorHandler.handleError(error);
            }, Logger.prototype.warn = function(value) {
                for (var rest = [], _i = 1; _i < arguments.length; _i++) rest[_i - 1] = arguments[_i];
                console.warn.apply(console, [ value ].concat(rest));
            }, Logger.ngInjectableDef = defineInjectable({
                token: Logger,
                factory: function(t) {
                    return new (t || Logger)(inject(ErrorHandler));
                },
                providedIn: null
            }), Logger;
        }(), sw_updates_service_SwUpdatesService = function() {
            function SwUpdatesService(appRef, logger, swu) {
                var period, scheduler, _this = this;
                this.logger = logger, this.swu = swu, this.checkInterval = 216e5, this.onDestroy = new Subject_Subject(), 
                swu.isEnabled ? (concat(appRef.isStable.pipe(first_first(function(v) {
                    return v;
                })), (period = this.checkInterval, void 0 === period && (period = 0), void 0 === scheduler && (scheduler = async_async), 
                (!isNumeric(period) || period < 0) && (period = 0), scheduler && "function" == typeof scheduler.schedule || (scheduler = async_async), 
                new Observable_Observable(function(subscriber) {
                    return subscriber.add(scheduler.schedule(interval_dispatch, period, {
                        subscriber: subscriber,
                        counter: 0,
                        period: period
                    })), subscriber;
                }))).pipe(tap(function() {
                    return _this.log("Checking for update...");
                }), takeUntil(this.onDestroy)).subscribe(function() {
                    return _this.swu.checkForUpdate();
                }), this.swu.available.pipe(tap(function(evt) {
                    return _this.log("Update available: " + JSON.stringify(evt));
                }), takeUntil(this.onDestroy)).subscribe(function() {
                    return _this.swu.activateUpdate();
                }), this.updateActivated = this.swu.activated.pipe(tap(function(evt) {
                    return _this.log("Update activated: " + JSON.stringify(evt));
                }), map_map(function(evt) {
                    return evt.current.hash;
                }), takeUntil(this.onDestroy))) : this.updateActivated = NEVER.pipe(takeUntil(this.onDestroy));
            }
            return SwUpdatesService.prototype.ngOnDestroy = function() {
                this.onDestroy.next();
            }, SwUpdatesService.prototype.log = function(message) {
                var timestamp = new Date().toISOString();
                this.logger.log("[SwUpdates - " + timestamp + "]: " + message);
            }, SwUpdatesService.ngInjectableDef = defineInjectable({
                token: SwUpdatesService,
                factory: function(t) {
                    return new (t || SwUpdatesService)(inject(core_ApplicationRef), inject(logger_service_Logger), inject(service_worker_SwUpdate));
                },
                providedIn: null
            }), SwUpdatesService;
        }(), location_service_LocationService = function() {
            function LocationService(gaService, location, platformLocation, swUpdates) {
                var _this = this;
                this.gaService = gaService, this.location = location, this.platformLocation = platformLocation, 
                this.urlParser = document.createElement("a"), this.urlSubject = new ReplaySubject_ReplaySubject(1), 
                this.swUpdateActivated = !1, this.currentUrl = this.urlSubject.pipe(map_map(function(url) {
                    return _this.stripSlashes(url);
                })), this.currentPath = this.currentUrl.pipe(map_map(function(url) {
                    return (url.match(/[^?#]*/) || [])[0];
                }), tap(function(path) {
                    return _this.gaService.locationChanged(path);
                })), this.urlSubject.next(location.path(!0)), this.location.subscribe(function(state) {
                    return _this.urlSubject.next(state.url || "");
                }), swUpdates.updateActivated.subscribe(function() {
                    return _this.swUpdateActivated = !0;
                });
            }
            return LocationService.prototype.go = function(url) {
                url && (url = this.stripSlashes(url), /^http/.test(url) || this.swUpdateActivated ? this.goExternal(url) : (this.location.go(url), 
                this.urlSubject.next(url)));
            }, LocationService.prototype.goExternal = function(url) {
                window.location.assign(url);
            }, LocationService.prototype.replace = function(url) {
                window.location.replace(url);
            }, LocationService.prototype.stripSlashes = function(url) {
                return url.replace(/^\/+/, "").replace(/\/+(\?|#|$)/, "$1");
            }, LocationService.prototype.search = function() {
                var search = {}, path = this.location.path(), q = path.indexOf("?");
                if (q > -1) try {
                    path.substr(q + 1).split("&").forEach(function(p) {
                        var pair = p.split("=");
                        pair[0] && (search[decodeURIComponent(pair[0])] = pair[1] && decodeURIComponent(pair[1]));
                    });
                } catch (e) {}
                return search;
            }, LocationService.prototype.setSearch = function(label, params) {
                var search = Object.keys(params).reduce(function(acc, key) {
                    var value = params[key];
                    return void 0 === value ? acc : acc += (acc ? "&" : "?") + encodeURIComponent(key) + "=" + encodeURIComponent(value);
                }, "");
                this.platformLocation.replaceState({}, label, this.platformLocation.pathname + search);
            }, LocationService.prototype.handleAnchorClick = function(anchor, button, ctrlKey, metaKey) {
                if (void 0 === button && (button = 0), void 0 === ctrlKey && (ctrlKey = !1), void 0 === metaKey && (metaKey = !1), 
                0 !== button || ctrlKey || metaKey) return !0;
                var anchorTarget = anchor.target;
                if (anchorTarget && "_self" !== anchorTarget) return !0;
                if (null != anchor.getAttribute("download")) return !0;
                var pathname = anchor.pathname, relativeUrl = pathname + anchor.search + anchor.hash;
                return this.urlParser.href = relativeUrl, anchor.href !== this.urlParser.href || !/\/[^\/.]*$/.test(pathname) || (this.go(relativeUrl), 
                !1);
            }, LocationService.ngInjectableDef = defineInjectable({
                token: LocationService,
                factory: function(t) {
                    return new (t || LocationService)(inject(ga_service_GaService), inject(common_Location), inject(PlatformLocation), inject(sw_updates_service_SwUpdatesService));
                },
                providedIn: null
            }), LocationService;
        }(), search_box_component_c0 = [ "searchBox" ], search_box_component_c1 = [ "type", "search", "aria-label", "search", "placeholder", "Search", 3, "input", "keyup", "focus", "click" ], search_box_component_c2 = [ "searchBox", "" ], search_box_component_SearchBoxComponent = function() {
            function SearchBoxComponent(locationService) {
                this.locationService = locationService, this.searchDebounce = 300, this.searchSubject = new Subject_Subject(), 
                this.onSearch = this.searchSubject.pipe(distinctUntilChanged(), debounceTime(this.searchDebounce)), 
                this.onFocus = new core_EventEmitter();
            }
            return SearchBoxComponent.prototype.ngOnInit = function() {
                var query = this.locationService.search().search;
                query && (this.query = query, this.doSearch());
            }, SearchBoxComponent.prototype.doSearch = function() {
                this.searchSubject.next(this.query);
            }, SearchBoxComponent.prototype.doFocus = function() {
                this.onFocus.emit(this.query);
            }, SearchBoxComponent.prototype.focus = function() {
                this.searchBox.nativeElement.focus();
            }, Object.defineProperty(SearchBoxComponent.prototype, "query", {
                get: function() {
                    return this.searchBox.nativeElement.value;
                },
                set: function(value) {
                    this.searchBox.nativeElement.value = value;
                },
                enumerable: !0,
                configurable: !0
            }), SearchBoxComponent.ngComponentDef = defineComponent({
                type: SearchBoxComponent,
                selectors: [ [ "aio-search-box" ] ],
                factory: function(t) {
                    return new (t || SearchBoxComponent)(directiveInject(location_service_LocationService));
                },
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && viewQuery(search_box_component_c0, !0, null), 2 & rf && queryRefresh(_t = loadViewQuery()) && (ctx.searchBox = _t.first);
                },
                outputs: {
                    onSearch: "onSearch",
                    onFocus: "onFocus"
                },
                consts: 2,
                vars: 0,
                template: function(rf, ctx) {
                    1 & rf && (elementStart(0, "input", search_box_component_c1, search_box_component_c2), 
                    listener("input", function($event) {
                        return ctx.doSearch();
                    }), listener("keyup", function($event) {
                        return ctx.doSearch();
                    }), listener("focus", function($event) {
                        return ctx.doFocus();
                    }), listener("click", function($event) {
                        return ctx.doSearch();
                    }), elementEnd());
                },
                encapsulation: 2
            }), SearchBoxComponent;
        }(), BehaviorSubject_BehaviorSubject = function(_super) {
            function BehaviorSubject(_value) {
                var _this = _super.call(this) || this;
                return _this._value = _value, _this;
            }
            return __extends(BehaviorSubject, _super), Object.defineProperty(BehaviorSubject.prototype, "value", {
                get: function() {
                    return this.getValue();
                },
                enumerable: !0,
                configurable: !0
            }), BehaviorSubject.prototype._subscribe = function(subscriber) {
                var subscription = _super.prototype._subscribe.call(this, subscriber);
                return subscription && !subscription.closed && subscriber.next(this._value), subscription;
            }, BehaviorSubject.prototype.getValue = function() {
                if (this.hasError) throw this.thrownError;
                if (this.closed) throw new ObjectUnsubscribedError();
                return this._value;
            }, BehaviorSubject.prototype.next = function(value) {
                _super.prototype.next.call(this, this._value = value);
            }, BehaviorSubject;
        }(Subject_Subject), NONE = {};
        function combineLatest() {
            for (var observables = [], _i = 0; _i < arguments.length; _i++) observables[_i] = arguments[_i];
            var resultSelector = null, scheduler = null;
            return isScheduler(observables[observables.length - 1]) && (scheduler = observables.pop()), 
            "function" == typeof observables[observables.length - 1] && (resultSelector = observables.pop()), 
            1 === observables.length && isArray(observables[0]) && (observables = observables[0]), 
            fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
        }
        var CombineLatestOperator = function() {
            function CombineLatestOperator(resultSelector) {
                this.resultSelector = resultSelector;
            }
            return CombineLatestOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new combineLatest_CombineLatestSubscriber(subscriber, this.resultSelector));
            }, CombineLatestOperator;
        }(), combineLatest_CombineLatestSubscriber = function(_super) {
            function CombineLatestSubscriber(destination, resultSelector) {
                var _this = _super.call(this, destination) || this;
                return _this.resultSelector = resultSelector, _this.active = 0, _this.values = [], 
                _this.observables = [], _this;
            }
            return __extends(CombineLatestSubscriber, _super), CombineLatestSubscriber.prototype._next = function(observable) {
                this.values.push(NONE), this.observables.push(observable);
            }, CombineLatestSubscriber.prototype._complete = function() {
                var observables = this.observables, len = observables.length;
                if (0 === len) this.destination.complete(); else {
                    this.active = len, this.toRespond = len;
                    for (var i = 0; i < len; i++) {
                        var observable = observables[i];
                        this.add(subscribeToResult(this, observable, observable, i));
                    }
                }
            }, CombineLatestSubscriber.prototype.notifyComplete = function(unused) {
                0 == (this.active -= 1) && this.destination.complete();
            }, CombineLatestSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                var values = this.values, toRespond = this.toRespond ? values[outerIndex] === NONE ? --this.toRespond : this.toRespond : 0;
                values[outerIndex] = innerValue, 0 === toRespond && (this.resultSelector ? this._tryResultSelector(values) : this.destination.next(values.slice()));
            }, CombineLatestSubscriber.prototype._tryResultSelector = function(values) {
                var result;
                try {
                    result = this.resultSelector.apply(this, values);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.next(result);
            }, CombineLatestSubscriber;
        }(OuterSubscriber_OuterSubscriber), deployment_service_Deployment = function() {
            function Deployment(location) {
                this.location = location, this.mode = this.location.search().mode || environment.mode;
            }
            return Deployment.ngInjectableDef = defineInjectable({
                token: Deployment,
                factory: function(t) {
                    return new (t || Deployment)(inject(location_service_LocationService));
                },
                providedIn: null
            }), Deployment;
        }(), AsyncSubject_AsyncSubject = function(_super) {
            function AsyncSubject() {
                var _this = null !== _super && _super.apply(this, arguments) || this;
                return _this.value = null, _this.hasNext = !1, _this.hasCompleted = !1, _this;
            }
            return __extends(AsyncSubject, _super), AsyncSubject.prototype._subscribe = function(subscriber) {
                return this.hasError ? (subscriber.error(this.thrownError), Subscription_Subscription.EMPTY) : this.hasCompleted && this.hasNext ? (subscriber.next(this.value), 
                subscriber.complete(), Subscription_Subscription.EMPTY) : _super.prototype._subscribe.call(this, subscriber);
            }, AsyncSubject.prototype.next = function(value) {
                this.hasCompleted || (this.value = value, this.hasNext = !0);
            }, AsyncSubject.prototype.error = function(error) {
                this.hasCompleted || _super.prototype.error.call(this, error);
            }, AsyncSubject.prototype.complete = function() {
                this.hasCompleted = !0, this.hasNext && _super.prototype.next.call(this, this.value), 
                _super.prototype.complete.call(this);
            }, AsyncSubject;
        }(Subject_Subject), document_service_DocumentService = function() {
            function DocumentService(logger, http, location) {
                var _this = this;
                this.logger = logger, this.http = http, this.cache = new Map(), this.currentDocument = location.currentPath.pipe(switchMap(function(path) {
                    return _this.getDocument(path);
                }));
            }
            return DocumentService.prototype.getDocument = function(url) {
                var id = url || "index";
                return this.logger.log("getting document", id), this.cache.has(id) || this.cache.set(id, this.fetchDocument(id)), 
                this.cache.get(id);
            }, DocumentService.prototype.fetchDocument = function(id) {
                var _this = this, requestPath = "generated/docs/" + id + ".json", subject = new AsyncSubject_AsyncSubject();
                return this.logger.log("fetching document from", requestPath), this.http.get(requestPath, {
                    responseType: "json"
                }).pipe(tap(function(data) {
                    if (!data || "object" != typeof data) throw _this.logger.log("received invalid data:", data), 
                    Error("Invalid data");
                }), catchError(function(error) {
                    return 404 === error.status ? _this.getFileNotFoundDoc(id) : _this.getErrorDoc(id, error);
                })).subscribe(subject), subject.asObservable();
            }, DocumentService.prototype.getFileNotFoundDoc = function(id) {
                return "file-not-found" !== id ? (this.logger.error(new Error("Document file not found at '" + id + "'")), 
                this.getDocument("file-not-found")) : of({
                    id: "file-not-found",
                    contents: "Document not found"
                });
            }, DocumentService.prototype.getErrorDoc = function(id, error) {
                return this.logger.error(new Error("Error fetching document '" + id + "': (" + error.message + ")")), 
                this.cache.delete(id), of({
                    id: "fetching-error",
                    contents: (path = id, '\n  <div class="nf-container l-flex-wrap flex-center">\n    <div class="nf-icon material-icons">error_outline</div>\n    <div class="nf-response l-flex-wrap">\n      <h1 class="no-toc">Request for document failed.</h1>\n      <p>\n        We are unable to retrieve the "' + path + '" page at this time.\n        Please check your connection and try again later.\n      </p>\n    </div>\n  </div>\n')
                });
                var path;
            }, DocumentService.ngInjectableDef = defineInjectable({
                token: DocumentService,
                factory: function(t) {
                    return new (t || DocumentService)(inject(logger_service_Logger), inject(http_HttpClient), inject(location_service_LocationService));
                },
                providedIn: null
            }), DocumentService;
        }();
        function publishLast() {
            return function(source) {
                return multicast(new AsyncSubject_AsyncSubject())(source);
            };
        }
        function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
            selectorOrScheduler && "function" != typeof selectorOrScheduler && (scheduler = selectorOrScheduler);
            var selector = "function" == typeof selectorOrScheduler ? selectorOrScheduler : void 0, subject = new ReplaySubject_ReplaySubject(bufferSize, windowTime, scheduler);
            return function(source) {
                return multicast(function() {
                    return subject;
                }, selector)(source);
            };
        }
        var navigation_service_NavigationService = function() {
            function NavigationService(http, location) {
                this.http = http, this.location = location;
                var navigationInfo = this.fetchNavigationInfo();
                this.navigationViews = this.getNavigationViews(navigationInfo), this.currentNodes = this.getCurrentNodes(this.navigationViews), 
                this.versionInfo = this.getVersionInfo(navigationInfo);
            }
            return NavigationService.prototype.fetchNavigationInfo = function() {
                var navigationInfo = this.http.get("generated/navigation.json").pipe(publishLast());
                return navigationInfo.connect(), navigationInfo;
            }, NavigationService.prototype.getVersionInfo = function(navigationInfo) {
                var versionInfo = navigationInfo.pipe(map_map(function(response) {
                    return response.__versionInfo;
                }), publishLast());
                return versionInfo.connect(), versionInfo;
            }, NavigationService.prototype.getNavigationViews = function(navigationInfo) {
                var navigationViews = navigationInfo.pipe(map_map(function(response) {
                    var views = Object.assign({}, response);
                    return Object.keys(views).forEach(function(key) {
                        "_" === key[0] && delete views[key];
                    }), views;
                }), publishLast());
                return navigationViews.connect(), navigationViews;
            }, NavigationService.prototype.getCurrentNodes = function(navigationViews) {
                var _this = this, currentNodes = combineLatest(navigationViews.pipe(map_map(function(views) {
                    return _this.computeUrlToNavNodesMap(views);
                })), this.location.currentPath).pipe(map_map(function(result) {
                    return {
                        navMap: result[0],
                        url: result[1]
                    };
                }), map_map(function(result) {
                    var matchSpecialUrls = /^api/.exec(result.url);
                    return matchSpecialUrls && (result.url = matchSpecialUrls[0]), result.navMap.get(result.url) || {
                        "": {
                            view: "",
                            url: result.url,
                            nodes: []
                        }
                    };
                }), publishReplay(1));
                return currentNodes.connect(), currentNodes;
            }, NavigationService.prototype.computeUrlToNavNodesMap = function(navigation) {
                var _this = this, navMap = new Map();
                return Object.keys(navigation).forEach(function(view) {
                    return navigation[view].forEach(function(node) {
                        return _this.walkNodes(view, navMap, node);
                    });
                }), navMap;
            }, NavigationService.prototype.ensureHasTooltip = function(node) {
                var title = node.title;
                null == node.tooltip && title && (node.tooltip = title + (/[a-zA-Z0-9]$/.test(title) ? "." : ""));
            }, NavigationService.prototype.walkNodes = function(view, navMap, node, ancestors) {
                var _this = this;
                void 0 === ancestors && (ancestors = []);
                var nodes = [ node ].concat(ancestors), url = node.url;
                if (this.ensureHasTooltip(node), url) {
                    var cleanedUrl = url.replace(/\/$/, "");
                    navMap.has(cleanedUrl) || navMap.set(cleanedUrl, {}), navMap.get(cleanedUrl)[view] = {
                        url: url,
                        view: view,
                        nodes: nodes
                    };
                }
                node.children && node.children.forEach(function(child) {
                    return _this.walkNodes(view, navMap, child, nodes);
                });
            }, NavigationService.ngInjectableDef = defineInjectable({
                token: NavigationService,
                factory: function(t) {
                    return new (t || NavigationService)(inject(http_HttpClient), inject(location_service_LocationService));
                },
                providedIn: null
            }), NavigationService;
        }(), scroll_service_ScrollService = function() {
            function ScrollService(document, platformLocation, viewportScroller, location) {
                var _this = this;
                this.document = document, this.platformLocation = platformLocation, this.viewportScroller = viewportScroller, 
                this.location = location, this.poppedStateScrollPosition = null, this.supportManualScrollRestoration = !!window && "scrollTo" in window && "scrollX" in window && "scrollY" in window && !!history && "scrollRestoration" in history, 
                fromEvent(window, "resize").subscribe(function() {
                    return _this._topOffset = null;
                }), fromEvent(window, "scroll").pipe(debounceTime(250)).subscribe(function() {
                    return _this.updateScrollPositionInHistory();
                }), this.supportManualScrollRestoration && (history.scrollRestoration = "manual", 
                this.location.subscribe(function(event) {
                    "hashchange" === event.type ? _this.scrollToPosition() : (_this.removeStoredScrollPosition(), 
                    _this.poppedStateScrollPosition = event.state ? event.state.scrollPosition : null);
                }));
            }
            return Object.defineProperty(ScrollService.prototype, "topOffset", {
                get: function() {
                    if (!this._topOffset) {
                        var toolbar_1 = this.document.querySelector(".app-toolbar");
                        this._topOffset = (toolbar_1 && toolbar_1.clientHeight || 0) + 16;
                    }
                    return this._topOffset;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(ScrollService.prototype, "topOfPageElement", {
                get: function() {
                    return this._topOfPageElement || (this._topOfPageElement = this.document.getElementById("top-of-page") || this.document.body), 
                    this._topOfPageElement;
                },
                enumerable: !0,
                configurable: !0
            }), ScrollService.prototype.scroll = function() {
                var hash = this.getCurrentHash(), element = hash ? this.document.getElementById(hash) : this.topOfPageElement;
                this.scrollToElement(element);
            }, ScrollService.prototype.isLocationWithHash = function() {
                return !!this.getCurrentHash();
            }, ScrollService.prototype.scrollAfterRender = function(delay) {
                var _this = this, storedScrollPosition = this.getStoredScrollPosition();
                storedScrollPosition ? this.viewportScroller.scrollToPosition(storedScrollPosition) : this.needToFixScrollPosition() ? this.scrollToPosition() : this.isLocationWithHash() ? setTimeout(function() {
                    return _this.scroll();
                }, delay) : this.scrollToTop();
            }, ScrollService.prototype.scrollToElement = function(element) {
                element && (element.scrollIntoView(), window && window.scrollBy && (window.scrollBy(0, element.getBoundingClientRect().top - this.topOffset), 
                window.pageYOffset < 20 && window.scrollBy(0, -window.pageYOffset)));
            }, ScrollService.prototype.scrollToTop = function() {
                this.scrollToElement(this.topOfPageElement);
            }, ScrollService.prototype.scrollToPosition = function() {
                this.poppedStateScrollPosition && (this.viewportScroller.scrollToPosition(this.poppedStateScrollPosition), 
                this.poppedStateScrollPosition = null);
            }, ScrollService.prototype.updateScrollPositionInHistory = function() {
                if (this.supportManualScrollRestoration) {
                    var currentScrollPosition = this.viewportScroller.getScrollPosition();
                    this.location.replaceState(this.location.path(!0), void 0, {
                        scrollPosition: currentScrollPosition
                    }), window.sessionStorage.setItem("scrollPosition", currentScrollPosition.join(","));
                }
            }, ScrollService.prototype.getStoredScrollPosition = function() {
                var position = window.sessionStorage.getItem("scrollPosition");
                if (!position) return null;
                var _a = position.split(",");
                return [ +_a[0], +_a[1] ];
            }, ScrollService.prototype.removeStoredScrollPosition = function() {
                window.sessionStorage.removeItem("scrollPosition");
            }, ScrollService.prototype.needToFixScrollPosition = function() {
                return this.supportManualScrollRestoration && !!this.poppedStateScrollPosition;
            }, ScrollService.prototype.getCurrentHash = function() {
                return decodeURIComponent(this.platformLocation.hash.replace(/^#/, ""));
            }, ScrollService.ngInjectableDef = defineInjectable({
                token: ScrollService,
                factory: function(t) {
                    return new (t || ScrollService)(inject(DOCUMENT), inject(PlatformLocation), inject(common_ViewportScroller), inject(common_Location));
                },
                providedIn: null
            }), ScrollService;
        }(), RaceOperator = function() {
            function RaceOperator() {}
            return RaceOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new race_RaceSubscriber(subscriber));
            }, RaceOperator;
        }(), race_RaceSubscriber = function(_super) {
            function RaceSubscriber(destination) {
                var _this = _super.call(this, destination) || this;
                return _this.hasFirst = !1, _this.observables = [], _this.subscriptions = [], _this;
            }
            return __extends(RaceSubscriber, _super), RaceSubscriber.prototype._next = function(observable) {
                this.observables.push(observable);
            }, RaceSubscriber.prototype._complete = function() {
                var observables = this.observables, len = observables.length;
                if (0 === len) this.destination.complete(); else {
                    for (var i = 0; i < len && !this.hasFirst; i++) {
                        var observable = observables[i], subscription = subscribeToResult(this, observable, observable, i);
                        this.subscriptions && this.subscriptions.push(subscription), this.add(subscription);
                    }
                    this.observables = null;
                }
            }, RaceSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                if (!this.hasFirst) {
                    this.hasFirst = !0;
                    for (var i = 0; i < this.subscriptions.length; i++) if (i !== outerIndex) {
                        var subscription = this.subscriptions[i];
                        subscription.unsubscribe(), this.remove(subscription);
                    }
                    this.subscriptions = null;
                }
                this.destination.next(innerValue);
            }, RaceSubscriber;
        }(OuterSubscriber_OuterSubscriber), web_worker_WebWorkerClient = function() {
            function WebWorkerClient(worker, zone) {
                this.worker = worker, this.zone = zone, this.nextId = 0;
            }
            return WebWorkerClient.create = function(workerUrl, zone) {
                return new WebWorkerClient(new Worker(workerUrl), zone);
            }, WebWorkerClient.prototype.sendMessage = function(type, payload) {
                var _this = this;
                return new Observable_Observable(function(subscriber) {
                    var id = _this.nextId++, handleMessage = function(response) {
                        var _a = response.data, responsePayload = _a.payload;
                        type === _a.type && id === _a.id && _this.zone.run(function() {
                            subscriber.next(responsePayload), subscriber.complete();
                        });
                    }, handleError = function(error) {
                        _this.zone.run(function() {
                            return subscriber.error(error);
                        });
                    };
                    return _this.worker.addEventListener("message", handleMessage), _this.worker.addEventListener("error", handleError), 
                    _this.worker.postMessage({
                        type: type,
                        id: id,
                        payload: payload
                    }), function() {
                        _this.worker.removeEventListener("message", handleMessage), _this.worker.removeEventListener("error", handleError);
                    };
                });
            }, WebWorkerClient;
        }(), search_service_SearchService = function() {
            function SearchService(zone) {
                this.zone = zone, this.searchesSubject = new ReplaySubject_ReplaySubject(1);
            }
            return SearchService.prototype.initWorker = function(workerUrl, initDelay) {
                var _this = this, ready = this.ready = function() {
                    for (var observables = [], _i = 0; _i < arguments.length; _i++) observables[_i] = arguments[_i];
                    if (1 === observables.length) {
                        if (!isArray(observables[0])) return observables[0];
                        observables = observables[0];
                    }
                    return fromArray(observables, void 0).lift(new RaceOperator());
                }(timer(initDelay), this.searchesSubject.asObservable().pipe(first_first())).pipe(concatMap(function() {
                    return _this.worker = web_worker_WebWorkerClient.create(workerUrl, _this.zone), 
                    _this.worker.sendMessage("load-index");
                }), publishReplay(1));
                return ready.connect(), ready;
            }, SearchService.prototype.search = function(query) {
                var _this = this;
                return this.searchesSubject.next(query), this.ready.pipe(concatMap(function() {
                    return _this.worker.sendMessage("query-index", query);
                }));
            }, SearchService.ngInjectableDef = defineInjectable({
                token: SearchService,
                factory: function(t) {
                    return new (t || SearchService)(inject(NgZone));
                },
                providedIn: null
            }), SearchService;
        }(), ScrollSpiedElement = function() {
            function ScrollSpiedElement(element, index) {
                this.element = element, this.index = index, this.top = 0;
            }
            return ScrollSpiedElement.prototype.calculateTop = function(scrollTop, topOffset) {
                this.top = scrollTop + this.element.getBoundingClientRect().top - topOffset;
            }, ScrollSpiedElement;
        }(), scroll_spy_service_ScrollSpiedElementGroup = function() {
            function ScrollSpiedElementGroup(elements) {
                this.activeScrollItem = new ReplaySubject_ReplaySubject(1), this.spiedElements = elements.map(function(elem, i) {
                    return new ScrollSpiedElement(elem, i);
                });
            }
            return ScrollSpiedElementGroup.prototype.calibrate = function(scrollTop, topOffset) {
                this.spiedElements.forEach(function(spiedElem) {
                    return spiedElem.calculateTop(scrollTop, topOffset);
                }), this.spiedElements.sort(function(a, b) {
                    return b.top - a.top;
                });
            }, ScrollSpiedElementGroup.prototype.onScroll = function(scrollTop, maxScrollTop) {
                var activeItem;
                scrollTop + 1 >= maxScrollTop ? activeItem = this.spiedElements[0] : this.spiedElements.some(function(spiedElem) {
                    return spiedElem.top <= scrollTop && (activeItem = spiedElem, !0);
                }), this.activeScrollItem.next(activeItem || null);
            }, ScrollSpiedElementGroup;
        }(), scroll_spy_service_ScrollSpyService = function() {
            function ScrollSpyService(doc, scrollService) {
                this.doc = doc, this.scrollService = scrollService, this.spiedElementGroups = [], 
                this.onStopListening = new Subject_Subject(), this.resizeEvents = fromEvent(window, "resize").pipe(auditTime(300), takeUntil(this.onStopListening)), 
                this.scrollEvents = fromEvent(window, "scroll").pipe(auditTime(10), takeUntil(this.onStopListening));
            }
            return ScrollSpyService.prototype.spyOn = function(elements) {
                var _this = this;
                this.spiedElementGroups.length || (this.resizeEvents.subscribe(function() {
                    return _this.onResize();
                }), this.scrollEvents.subscribe(function() {
                    return _this.onScroll();
                }), this.onResize());
                var scrollTop = this.getScrollTop(), topOffset = this.getTopOffset(), maxScrollTop = this.lastMaxScrollTop, spiedGroup = new scroll_spy_service_ScrollSpiedElementGroup(elements);
                return spiedGroup.calibrate(scrollTop, topOffset), spiedGroup.onScroll(scrollTop, maxScrollTop), 
                this.spiedElementGroups.push(spiedGroup), {
                    active: spiedGroup.activeScrollItem.asObservable().pipe(distinctUntilChanged()),
                    unspy: function() {
                        return _this.unspy(spiedGroup);
                    }
                };
            }, ScrollSpyService.prototype.getContentHeight = function() {
                return this.doc.body.scrollHeight || Number.MAX_SAFE_INTEGER;
            }, ScrollSpyService.prototype.getScrollTop = function() {
                return window && window.pageYOffset || 0;
            }, ScrollSpyService.prototype.getTopOffset = function() {
                return this.scrollService.topOffset + 50;
            }, ScrollSpyService.prototype.getViewportHeight = function() {
                return this.doc.body.clientHeight || 0;
            }, ScrollSpyService.prototype.onResize = function() {
                var contentHeight = this.getContentHeight(), viewportHeight = this.getViewportHeight(), scrollTop = this.getScrollTop(), topOffset = this.getTopOffset();
                this.lastContentHeight = contentHeight, this.lastMaxScrollTop = contentHeight - viewportHeight, 
                this.spiedElementGroups.forEach(function(group) {
                    return group.calibrate(scrollTop, topOffset);
                });
            }, ScrollSpyService.prototype.onScroll = function() {
                this.lastContentHeight !== this.getContentHeight() && this.onResize();
                var scrollTop = this.getScrollTop(), maxScrollTop = this.lastMaxScrollTop;
                this.spiedElementGroups.forEach(function(group) {
                    return group.onScroll(scrollTop, maxScrollTop);
                });
            }, ScrollSpyService.prototype.unspy = function(spiedGroup) {
                spiedGroup.activeScrollItem.complete(), this.spiedElementGroups = this.spiedElementGroups.filter(function(group) {
                    return group !== spiedGroup;
                }), this.spiedElementGroups.length || this.onStopListening.next();
            }, ScrollSpyService.ngInjectableDef = defineInjectable({
                token: ScrollSpyService,
                factory: function(t) {
                    return new (t || ScrollSpyService)(inject(DOCUMENT), inject(scroll_service_ScrollService));
                },
                providedIn: null
            }), ScrollSpyService;
        }(), toc_service_TocService = function() {
            function TocService(document, domSanitizer, scrollSpyService) {
                this.document = document, this.domSanitizer = domSanitizer, this.scrollSpyService = scrollSpyService, 
                this.tocList = new ReplaySubject_ReplaySubject(1), this.activeItemIndex = new ReplaySubject_ReplaySubject(1), 
                this.scrollSpyInfo = null;
            }
            return TocService.prototype.genToc = function(docElement, docId) {
                var _this = this;
                if (void 0 === docId && (docId = ""), this.resetScrollSpyInfo(), docElement) {
                    var headings = this.findTocHeadings(docElement), idMap = new Map(), tocList = headings.map(function(heading) {
                        return {
                            content: _this.extractHeadingSafeHtml(heading),
                            href: docId + "#" + _this.getId(heading, idMap),
                            level: heading.tagName.toLowerCase(),
                            title: (heading.textContent || "").trim()
                        };
                    });
                    this.tocList.next(tocList), this.scrollSpyInfo = this.scrollSpyService.spyOn(headings), 
                    this.scrollSpyInfo.active.subscribe(function(item) {
                        return _this.activeItemIndex.next(item && item.index);
                    });
                } else this.tocList.next([]);
            }, TocService.prototype.reset = function() {
                this.resetScrollSpyInfo(), this.tocList.next([]);
            }, TocService.prototype.extractHeadingSafeHtml = function(heading) {
                var div = this.document.createElement("div");
                div.innerHTML = heading.innerHTML;
                for (var anchorLinks = div.querySelectorAll("a"), i = 0; i < anchorLinks.length; i++) {
                    var anchorLink = anchorLinks[i];
                    if (!anchorLink.classList.contains("header-link")) for (var parent_1 = anchorLink.parentNode; anchorLink.childNodes.length; ) parent_1.insertBefore(anchorLink.childNodes[0], anchorLink);
                    null !== anchorLink.parentNode && anchorLink.parentNode.removeChild(anchorLink);
                }
                return this.domSanitizer.bypassSecurityTrustHtml(div.innerHTML.trim());
            }, TocService.prototype.findTocHeadings = function(docElement) {
                var headings = docElement.querySelectorAll("h1,h2,h3");
                return Array.prototype.filter.call(headings, function(heading) {
                    return !/(?:no-toc|notoc)/i.test(heading.className);
                });
            }, TocService.prototype.resetScrollSpyInfo = function() {
                this.scrollSpyInfo && (this.scrollSpyInfo.unspy(), this.scrollSpyInfo = null), this.activeItemIndex.next(null);
            }, TocService.prototype.getId = function(h, idMap) {
                var id = h.id;
                return id ? addToMap(id) : (id = addToMap(id = (h.textContent || "").trim().toLowerCase().replace(/\W+/g, "-")), 
                h.id = id), id;
                function addToMap(key) {
                    var count = (idMap.get(key) || 0) + 1;
                    return idMap.set(key, count), 1 === count ? key : key + "-" + count;
                }
            }, TocService.ngInjectableDef = defineInjectable({
                token: TocService,
                factory: function(t) {
                    return new (t || TocService)(inject(DOCUMENT), inject(DomSanitizer), inject(scroll_spy_service_ScrollSpyService));
                },
                providedIn: null
            }), TocService;
        }(), nav_item_component_c0 = [ 4, "ngIf" ], nav_item_component_c1 = [ 1, "vertical-menu-item", 3, "href", "ngClass", "title" ];
        function NavItemComponent_div_0_Template(rf, ctx) {
            if (1 & rf && (elementStart(0, "div"), elementStart(1, "a", nav_item_component_c1), 
            core_text(2), elementEnd(), elementEnd()), 2 & rf) {
                var ctx_r30 = nextContext();
                core_select(1), elementProperty(1, "href", interpolation1("", ctx_r30.node.url, ""), sanitizeUrl), 
                elementProperty(1, "ngClass", bind(ctx_r30.classes)), elementProperty(1, "title", interpolation1("", ctx_r30.node.tooltip, "")), 
                core_select(2), textBinding(2, interpolation1(" ", ctx_r30.node.title, " "));
            }
        }
        var nav_item_component_c2 = [ "class", "vertical-menu-item heading", 3, "href", "ngClass", "title", "click", 4, "ngIf" ], nav_item_component_c3 = [ "type", "button", "class", "vertical-menu-item heading", 3, "ngClass", "title", "aria-pressed", "click", 4, "ngIf" ], nav_item_component_c4 = [ 1, "heading-children", 3, "ngClass" ], nav_item_component_c5 = [ 3, "level", "isWide", "isParentExpanded", "node", "selectedNodes", 4, "ngFor", "ngForOf" ], nav_item_component_c6 = [ 1, "vertical-menu-item", "heading", 3, "href", "ngClass", "title", "click" ], nav_item_component_c7 = [ "svgIcon", "keyboard_arrow_right", 1, "rotating-icon" ];
        function NavItemComponent_div_1_a_1_Template(rf, ctx) {
            if (1 & rf) {
                var _r36 = getCurrentView();
                elementStart(0, "a", nav_item_component_c6), listener("click", function($event) {
                    return restoreView(_r36), nextContext(2).headerClicked();
                }), core_text(1), core_element(2, "mat-icon", nav_item_component_c7), elementEnd();
            }
            if (2 & rf) {
                var ctx_r32 = nextContext(2);
                core_select(0), elementProperty(0, "href", interpolation1("", ctx_r32.node.url, ""), sanitizeUrl), 
                elementProperty(0, "ngClass", bind(ctx_r32.classes)), elementProperty(0, "title", interpolation1("", ctx_r32.node.tooltip, "")), 
                core_select(1), textBinding(1, interpolation1(" ", ctx_r32.node.title, " "));
            }
        }
        var nav_item_component_c8 = [ "type", "button", 1, "vertical-menu-item", "heading", 3, "ngClass", "title", "aria-pressed", "click" ];
        function NavItemComponent_div_1_button_2_Template(rf, ctx) {
            if (1 & rf) {
                var _r38 = getCurrentView();
                elementStart(0, "button", nav_item_component_c8), listener("click", function($event) {
                    return restoreView(_r38), nextContext(2).headerClicked();
                }), core_text(1), core_element(2, "mat-icon", nav_item_component_c7), elementEnd();
            }
            if (2 & rf) {
                var ctx_r33 = nextContext(2);
                core_select(0), elementProperty(0, "ngClass", bind(ctx_r33.classes)), elementProperty(0, "title", interpolation1("", ctx_r33.node.tooltip, "")), 
                elementAttribute(0, "aria-pressed", bind(ctx_r33.isExpanded)), core_select(1), textBinding(1, interpolation1(" ", ctx_r33.node.title, " "));
            }
        }
        var nav_item_component_c9 = [ 3, "level", "isWide", "isParentExpanded", "node", "selectedNodes" ];
        function NavItemComponent_div_1_aio_nav_item_4_Template(rf, ctx) {
            if (1 & rf && core_element(0, "aio-nav-item", nav_item_component_c9), 2 & rf) {
                var node_r39 = ctx.$implicit, ctx_r34 = nextContext(2);
                core_select(0), elementProperty(0, "level", bind(ctx_r34.level + 1)), elementProperty(0, "isWide", bind(ctx_r34.isWide)), 
                elementProperty(0, "isParentExpanded", bind(ctx_r34.isExpanded)), elementProperty(0, "node", bind(node_r39)), 
                elementProperty(0, "selectedNodes", bind(ctx_r34.selectedNodes));
            }
        }
        function NavItemComponent_div_1_Template(rf, ctx) {
            if (1 & rf && (elementStart(0, "div"), template(1, NavItemComponent_div_1_a_1_Template, 3, 4, "a", nav_item_component_c2), 
            template(2, NavItemComponent_div_1_button_2_Template, 3, 4, "button", nav_item_component_c3), 
            elementStart(3, "div", nav_item_component_c4), template(4, NavItemComponent_div_1_aio_nav_item_4_Template, 1, 5, "aio-nav-item", nav_item_component_c5), 
            elementEnd(), elementEnd()), 2 & rf) {
                var ctx_r31 = nextContext();
                core_select(1), elementProperty(1, "ngIf", bind(null != ctx_r31.node.url)), core_select(2), 
                elementProperty(2, "ngIf", bind(null == ctx_r31.node.url)), core_select(3), elementProperty(3, "ngClass", bind(ctx_r31.classes)), 
                core_select(4), elementProperty(4, "ngForOf", bind(ctx_r31.nodeChildren));
            }
        }
        var nav_item_component_NavItemComponent = function() {
            function NavItemComponent() {
                this.isWide = !1, this.level = 1, this.isParentExpanded = !0, this.isExpanded = !1, 
                this.isSelected = !1;
            }
            return NavItemComponent.prototype.ngOnChanges = function() {
                if (this.nodeChildren = this.node && this.node.children ? this.node.children.filter(function(n) {
                    return !n.hidden;
                }) : [], this.selectedNodes) {
                    var ix = this.selectedNodes.indexOf(this.node);
                    this.isSelected = -1 !== ix, this.isExpanded = this.isParentExpanded && (this.isSelected || this.isWide && this.isExpanded);
                } else this.isSelected = !1;
                this.setClasses();
            }, NavItemComponent.prototype.setClasses = function() {
                var _a;
                this.classes = ((_a = {})["level-" + this.level] = !0, _a.collapsed = !this.isExpanded, 
                _a.expanded = this.isExpanded, _a.selected = this.isSelected, _a);
            }, NavItemComponent.prototype.headerClicked = function() {
                this.isExpanded = !this.isExpanded, this.setClasses();
            }, NavItemComponent.ngComponentDef = defineComponent({
                type: NavItemComponent,
                selectors: [ [ "aio-nav-item" ] ],
                factory: function(t) {
                    return new (t || NavItemComponent)();
                },
                inputs: {
                    isWide: "isWide",
                    level: "level",
                    node: "node",
                    isParentExpanded: "isParentExpanded",
                    selectedNodes: "selectedNodes"
                },
                features: [ NgOnChangesFeature() ],
                consts: 2,
                vars: 2,
                template: function(rf, ctx) {
                    1 & rf && (template(0, NavItemComponent_div_0_Template, 3, 4, "div", nav_item_component_c0), 
                    template(1, NavItemComponent_div_1_Template, 5, 4, "div", nav_item_component_c0)), 
                    2 & rf && (core_select(0), elementProperty(0, "ngIf", bind(!ctx.node.children)), 
                    core_select(1), elementProperty(1, "ngIf", bind(ctx.node.children)));
                },
                directives: [ common_NgIf, common_NgClass, common_NgForOf, icon_es5_MatIcon, NavItemComponent ],
                encapsulation: 2
            }), NavItemComponent;
        }(), nav_menu_component_c0 = [ 3, "node", "selectedNodes", "isWide", 4, "ngFor", "ngForOf" ], nav_menu_component_c1 = [ 3, "node", "selectedNodes", "isWide" ];
        function NavMenuComponent_aio_nav_item_0_Template(rf, ctx) {
            if (1 & rf && core_element(0, "aio-nav-item", nav_menu_component_c1), 2 & rf) {
                var node_r29 = ctx.$implicit, ctx_r28 = nextContext();
                core_select(0), elementProperty(0, "node", bind(node_r29)), elementProperty(0, "selectedNodes", bind(null == ctx_r28.currentNode ? null : ctx_r28.currentNode.nodes)), 
                elementProperty(0, "isWide", bind(ctx_r28.isWide));
            }
        }
        var nav_menu_component_NavMenuComponent = function() {
            function NavMenuComponent() {
                this.isWide = !1;
            }
            return Object.defineProperty(NavMenuComponent.prototype, "filteredNodes", {
                get: function() {
                    return this.nodes ? this.nodes.filter(function(n) {
                        return !n.hidden;
                    }) : [];
                },
                enumerable: !0,
                configurable: !0
            }), NavMenuComponent.ngComponentDef = defineComponent({
                type: NavMenuComponent,
                selectors: [ [ "aio-nav-menu" ] ],
                factory: function(t) {
                    return new (t || NavMenuComponent)();
                },
                inputs: {
                    currentNode: "currentNode",
                    isWide: "isWide",
                    nodes: "nodes"
                },
                consts: 1,
                vars: 1,
                template: function(rf, ctx) {
                    1 & rf && template(0, NavMenuComponent_aio_nav_item_0_Template, 1, 3, "aio-nav-item", nav_menu_component_c0), 
                    2 & rf && (core_select(0), elementProperty(0, "ngForOf", bind(ctx.filteredNodes)));
                },
                directives: [ common_NgForOf, nav_item_component_NavItemComponent ],
                encapsulation: 2
            }), NavMenuComponent;
        }(), select_component_c0 = [ 1, "form-select-menu" ], select_component_c1 = [ 1, "form-select-button", 3, "disabled", "click" ], select_component_c2 = [ 3, "class", 4, "ngIf" ], select_component_c3 = [ "class", "form-select-dropdown", 4, "ngIf" ];
        function SelectComponent_span_4_Template(rf, ctx) {
            if (1 & rf && (elementStart(0, "span"), elementStyling(), elementEnd()), 2 & rf) {
                var ctx_r61 = nextContext();
                elementStylingMap(0, interpolation1("symbol ", null == ctx_r61.selected ? null : ctx_r61.selected.value, "")), 
                elementStylingApply(0);
            }
        }
        var select_component_c4 = [ 1, "form-select-dropdown" ], select_component_c5 = [ "role", "button", "tabindex", "0", 3, "selected", "click", "keydown.enter", "keydown.space", 4, "ngFor", "ngForOf" ], select_component_c6 = [ "role", "button", "tabindex", "0", 3, "click", "keydown.enter", "keydown.space" ];
        function SelectComponent_ul_6_li_1_span_1_Template(rf, ctx) {
            1 & rf && (elementStart(0, "span"), elementStyling(), elementEnd()), 2 & rf && (elementStylingMap(0, interpolation1("symbol ", nextContext().$implicit.value, "")), 
            elementStylingApply(0));
        }
        var select_component_c7 = [ "selected" ];
        function SelectComponent_ul_6_li_1_Template(rf, ctx) {
            if (1 & rf) {
                var _r69 = getCurrentView();
                elementStart(0, "li", select_component_c6), elementStyling(select_component_c7), 
                listener("click", function($event) {
                    restoreView(_r69);
                    var option_r64 = ctx.$implicit, i_r65 = ctx.index;
                    return nextContext(2).select(option_r64, i_r65);
                }), listener("keydown.enter", function($event) {
                    restoreView(_r69);
                    var option_r64 = ctx.$implicit, i_r65 = ctx.index;
                    return nextContext(2).select(option_r64, i_r65);
                }), listener("keydown.space", function($event) {
                    restoreView(_r69);
                    var option_r64 = ctx.$implicit, i_r65 = ctx.index;
                    return nextContext(2).select(option_r64, i_r65), $event.preventDefault();
                }), template(1, SelectComponent_ul_6_li_1_span_1_Template, 1, 1, "span", select_component_c2), 
                core_text(2), elementEnd();
            }
            if (2 & rf) {
                var option_r64 = ctx.$implicit, ctx_r63 = nextContext(2);
                elementClassProp(0, 0, option_r64 === ctx_r63.selected), elementStylingApply(0), 
                core_select(1), elementProperty(1, "ngIf", bind(ctx_r63.showSymbol)), core_select(2), 
                textBinding(2, interpolation1("", option_r64.title, " "));
            }
        }
        function SelectComponent_ul_6_Template(rf, ctx) {
            if (1 & rf && (elementStart(0, "ul", select_component_c4), template(1, SelectComponent_ul_6_li_1_Template, 3, 2, "li", select_component_c5), 
            elementEnd()), 2 & rf) {
                var ctx_r62 = nextContext();
                core_select(1), elementProperty(1, "ngForOf", bind(ctx_r62.options));
            }
        }
        var select_component_SelectComponent = function() {
            function SelectComponent(hostElement) {
                this.hostElement = hostElement, this.change = new core_EventEmitter(), this.showSymbol = !1, 
                this.showOptions = !1;
            }
            return SelectComponent.prototype.ngOnInit = function() {
                this.label = this.label || "";
            }, SelectComponent.prototype.toggleOptions = function() {
                this.showOptions = !this.showOptions;
            }, SelectComponent.prototype.hideOptions = function() {
                this.showOptions = !1;
            }, SelectComponent.prototype.select = function(option, index) {
                this.selected = option, this.change.emit({
                    option: option,
                    index: index
                }), this.hideOptions();
            }, SelectComponent.prototype.onClick = function(eventTarget) {
                this.hostElement.nativeElement.contains(eventTarget) || this.hideOptions();
            }, SelectComponent.prototype.onKeyDown = function() {
                this.hideOptions();
            }, SelectComponent.ngComponentDef = defineComponent({
                type: SelectComponent,
                selectors: [ [ "aio-select" ] ],
                factory: function(t) {
                    return new (t || SelectComponent)(directiveInject(ElementRef));
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (listener("click", function($event) {
                        return ctx.onClick($event.target);
                    }, !1, resolveDocument), listener("keydown.escape", function($event) {
                        return ctx.onKeyDown();
                    }, !1, resolveDocument));
                },
                inputs: {
                    selected: "selected",
                    options: "options",
                    showSymbol: "showSymbol",
                    label: "label",
                    disabled: "disabled"
                },
                outputs: {
                    change: "change"
                },
                consts: 7,
                vars: 5,
                template: function(rf, ctx) {
                    1 & rf && (elementStart(0, "div", select_component_c0), elementStart(1, "button", select_component_c1), 
                    listener("click", function($event) {
                        return ctx.toggleOptions();
                    }), elementStart(2, "strong"), core_text(3), elementEnd(), template(4, SelectComponent_span_4_Template, 1, 1, "span", select_component_c2), 
                    core_text(5), elementEnd(), template(6, SelectComponent_ul_6_Template, 2, 1, "ul", select_component_c3), 
                    elementEnd()), 2 & rf && (core_select(1), elementProperty(1, "disabled", bind(ctx.disabled)), 
                    core_select(3), textBinding(3, interpolation1("", ctx.label, "")), core_select(4), 
                    elementProperty(4, "ngIf", bind(ctx.showSymbol)), core_select(5), textBinding(5, interpolation1("", null == ctx.selected ? null : ctx.selected.title, " ")), 
                    core_select(6), elementProperty(6, "ngIf", bind(ctx.showOptions)));
                },
                directives: [ common_NgIf, common_NgForOf ],
                encapsulation: 2
            }), SelectComponent;
        }(), mode_banner_component_c0 = [ "class", "mode-banner", 4, "ngIf" ], mode_banner_component_c1 = [ 1, "mode-banner" ], mode_banner_component_c2 = [ "href", "https://angular.io/" ];
        function ModeBannerComponent_div_0_Template(rf, ctx) {
            if (1 & rf && (elementStart(0, "div", mode_banner_component_c1), core_text(1, " This is the "), 
            elementStart(2, "strong"), core_text(3), elementEnd(), core_text(4, " Please visit "), 
            elementStart(5, "a", mode_banner_component_c2), core_text(6, "angular.io"), elementEnd(), 
            core_text(7, " to see documentation for the current version of Angular. "), elementEnd()), 
            2 & rf) {
                var ctx_r21 = nextContext();
                core_select(3), textBinding(3, interpolation1("archived documentation for Angular v", null == ctx_r21.version ? null : ctx_r21.version.major, "."));
            }
        }
        var mode_banner_component_ModeBannerComponent = function() {
            function ModeBannerComponent() {}
            return ModeBannerComponent.ngComponentDef = defineComponent({
                type: ModeBannerComponent,
                selectors: [ [ "aio-mode-banner" ] ],
                factory: function(t) {
                    return new (t || ModeBannerComponent)();
                },
                inputs: {
                    mode: "mode",
                    version: "version"
                },
                consts: 1,
                vars: 1,
                template: function(rf, ctx) {
                    1 & rf && template(0, ModeBannerComponent_div_0_Template, 8, 1, "div", mode_banner_component_c0), 
                    2 & rf && (core_select(0), elementProperty(0, "ngIf", bind("archive" == ctx.mode)));
                },
                directives: [ common_NgIf ],
                encapsulation: 2
            }), ModeBannerComponent;
        }(), ELEMENT_MODULE_PATHS_TOKEN = new InjectionToken("aio/elements-map"), ELEMENT_MODULE_PATHS = new Map();
        [ {
            selector: "aio-announcement-bar",
            loadChildren: "./announcement-bar/announcement-bar.module#AnnouncementBarModule"
        }, {
            selector: "aio-api-list",
            loadChildren: "./api/api-list.module#ApiListModule"
        }, {
            selector: "aio-contributor-list",
            loadChildren: "./contributor/contributor-list.module#ContributorListModule"
        }, {
            selector: "aio-file-not-found-search",
            loadChildren: "./search/file-not-found-search.module#FileNotFoundSearchModule"
        }, {
            selector: "aio-resource-list",
            loadChildren: "./resource/resource-list.module#ResourceListModule"
        }, {
            selector: "aio-toc",
            loadChildren: "./toc/toc.module#TocModule"
        }, {
            selector: "code-example",
            loadChildren: "./code/code-example.module#CodeExampleModule"
        }, {
            selector: "code-tabs",
            loadChildren: "./code/code-tabs.module#CodeTabsModule"
        }, {
            selector: "live-example",
            loadChildren: "./live-example/live-example.module#LiveExampleModule"
        } ].forEach(function(route) {
            ELEMENT_MODULE_PATHS.set(route.selector, route.loadChildren);
        });
        var elProto = Element.prototype, elements_matches = elProto.matches || elProto.matchesSelector || elProto.mozMatchesSelector || elProto.msMatchesSelector || elProto.oMatchesSelector || elProto.webkitMatchesSelector, elements_scheduler = {
            schedule: function(taskFn, delay) {
                var id = setTimeout(taskFn, delay);
                return function() {
                    return clearTimeout(id);
                };
            },
            scheduleBeforeRender: function(taskFn) {
                if ("undefined" == typeof window) return elements_scheduler.schedule(taskFn, 0);
                if (void 0 === window.requestAnimationFrame) return elements_scheduler.schedule(taskFn, 16);
                var id = window.requestAnimationFrame(taskFn);
                return function() {
                    return window.cancelAnimationFrame(id);
                };
            }
        };
        function findMatchingIndex(node, selectors, defaultIndex) {
            var matchingIndex = defaultIndex;
            return function(node) {
                return !!node && node.nodeType === Node.ELEMENT_NODE;
            }(node) && selectors.some(function(selector, i) {
                return !("*" === selector || !function(element, selector) {
                    return elements_matches.call(node, selector);
                }(0, selector) || (matchingIndex = i, 0));
            }), matchingIndex;
        }
        var elements_ComponentNgElementStrategyFactory = function() {
            function ComponentNgElementStrategyFactory(component, injector) {
                this.component = component, this.injector = injector, this.componentFactory = injector.get(core_ComponentFactoryResolver).resolveComponentFactory(component);
            }
            return ComponentNgElementStrategyFactory.prototype.create = function(injector) {
                return new elements_ComponentNgElementStrategy(this.componentFactory, injector);
            }, ComponentNgElementStrategyFactory;
        }(), elements_ComponentNgElementStrategy = function() {
            function ComponentNgElementStrategy(componentFactory, injector) {
                this.componentFactory = componentFactory, this.injector = injector, this.inputChanges = null, 
                this.implementsOnChanges = !1, this.scheduledChangeDetectionFn = null, this.scheduledDestroyFn = null, 
                this.initialInputValues = new Map(), this.uninitializedInputs = new Set();
            }
            return ComponentNgElementStrategy.prototype.connect = function(element) {
                if (null !== this.scheduledDestroyFn) return this.scheduledDestroyFn(), void (this.scheduledDestroyFn = null);
                this.componentRef || this.initializeComponent(element);
            }, ComponentNgElementStrategy.prototype.disconnect = function() {
                var _this = this;
                this.componentRef && null === this.scheduledDestroyFn && (this.scheduledDestroyFn = elements_scheduler.schedule(function() {
                    _this.componentRef && (_this.componentRef.destroy(), _this.componentRef = null);
                }, 10));
            }, ComponentNgElementStrategy.prototype.getInputValue = function(property) {
                return this.componentRef ? this.componentRef.instance[property] : this.initialInputValues.get(property);
            }, ComponentNgElementStrategy.prototype.setInputValue = function(property, value) {
                var value1, value2;
                (value1 = value) === (value2 = this.getInputValue(property)) || value1 != value1 && value2 != value2 || (this.componentRef ? (this.recordInputChange(property, value), 
                this.componentRef.instance[property] = value, this.scheduleDetectChanges()) : this.initialInputValues.set(property, value));
            }, ComponentNgElementStrategy.prototype.initializeComponent = function(element) {
                var childInjector = Injector.create({
                    providers: [],
                    parent: this.injector
                }), projectableNodes = function(host, ngContentSelectors) {
                    var nodes = element.childNodes, projectableNodes = ngContentSelectors.map(function() {
                        return [];
                    }), wildcardIndex = -1;
                    ngContentSelectors.some(function(selector, i) {
                        return "*" === selector && (wildcardIndex = i, !0);
                    });
                    for (var i = 0, ii = nodes.length; i < ii; ++i) {
                        var node = nodes[i], ngContentIndex = findMatchingIndex(node, ngContentSelectors, wildcardIndex);
                        -1 !== ngContentIndex && projectableNodes[ngContentIndex].push(node);
                    }
                    return projectableNodes;
                }(0, this.componentFactory.ngContentSelectors);
                this.componentRef = this.componentFactory.create(childInjector, projectableNodes, element), 
                this.implementsOnChanges = "function" == typeof this.componentRef.instance.ngOnChanges, 
                this.initializeInputs(), this.initializeOutputs(), this.detectChanges(), this.injector.get(core_ApplicationRef).attachView(this.componentRef.hostView);
            }, ComponentNgElementStrategy.prototype.initializeInputs = function() {
                var _this = this;
                this.componentFactory.inputs.forEach(function(_a) {
                    var propName = _a.propName, initialValue = _this.initialInputValues.get(propName);
                    initialValue ? _this.setInputValue(propName, initialValue) : _this.uninitializedInputs.add(propName);
                }), this.initialInputValues.clear();
            }, ComponentNgElementStrategy.prototype.initializeOutputs = function() {
                var _this = this, eventEmitters = this.componentFactory.outputs.map(function(_a) {
                    var templateName = _a.templateName;
                    return _this.componentRef.instance[_a.propName].pipe(map_map(function(value) {
                        return {
                            name: templateName,
                            value: value
                        };
                    }));
                });
                this.events = merge.apply(void 0, __spread(eventEmitters));
            }, ComponentNgElementStrategy.prototype.callNgOnChanges = function() {
                if (this.implementsOnChanges && null !== this.inputChanges) {
                    var inputChanges = this.inputChanges;
                    this.inputChanges = null, this.componentRef.instance.ngOnChanges(inputChanges);
                }
            }, ComponentNgElementStrategy.prototype.scheduleDetectChanges = function() {
                var _this = this;
                this.scheduledChangeDetectionFn || (this.scheduledChangeDetectionFn = elements_scheduler.scheduleBeforeRender(function() {
                    _this.scheduledChangeDetectionFn = null, _this.detectChanges();
                }));
            }, ComponentNgElementStrategy.prototype.recordInputChange = function(property, currentValue) {
                if (!this.componentRef || this.implementsOnChanges) {
                    null === this.inputChanges && (this.inputChanges = {});
                    var pendingChange = this.inputChanges[property];
                    if (pendingChange) pendingChange.currentValue = currentValue; else {
                        var isFirstChange = this.uninitializedInputs.has(property);
                        this.uninitializedInputs.delete(property);
                        var previousValue = isFirstChange ? void 0 : this.getInputValue(property);
                        this.inputChanges[property] = new SimpleChange(previousValue, currentValue, isFirstChange);
                    }
                }
            }, ComponentNgElementStrategy.prototype.detectChanges = function() {
                this.componentRef && (this.callNgOnChanges(), this.componentRef.changeDetectorRef.detectChanges());
            }, ComponentNgElementStrategy;
        }(), elements_NgElement = function(_super) {
            function NgElement() {
                var _this = null !== _super && _super.apply(this, arguments) || this;
                return _this.ngElementEventsSubscription = null, _this;
            }
            return __extends(NgElement, _super), NgElement;
        }(HTMLElement), elements_loader_ElementsLoader = function() {
            function ElementsLoader(moduleFactoryLoader, moduleRef, elementModulePaths) {
                this.moduleFactoryLoader = moduleFactoryLoader, this.moduleRef = moduleRef, this.elementsLoading = new Map(), 
                this.elementsToLoad = new Map(elementModulePaths);
            }
            return ElementsLoader.prototype.loadContainedCustomElements = function(element) {
                var _this = this, unregisteredSelectors = Array.from(this.elementsToLoad.keys()).filter(function(s) {
                    return element.querySelector(s);
                });
                return unregisteredSelectors.length ? from_from(Promise.all(unregisteredSelectors.map(function(s) {
                    return _this.loadCustomElement(s);
                })).then(function() {})) : of(void 0);
            }, ElementsLoader.prototype.loadCustomElement = function(selector) {
                var _this = this;
                if (this.elementsLoading.has(selector)) return this.elementsLoading.get(selector);
                if (this.elementsToLoad.has(selector)) {
                    var modulePath = this.elementsToLoad.get(selector), loadedAndRegistered = this.moduleFactoryLoader.load(modulePath).then(function(elementModuleFactory) {
                        var component, config, inputs, strategyFactory, attributeToPropertyInputs, NgElementImpl, elementModuleRef = elementModuleFactory.create(_this.moduleRef.injector), CustomElement = (config = {
                            injector: elementModuleRef.injector
                        }, inputs = function(component, injector) {
                            return config.injector.get(core_ComponentFactoryResolver).resolveComponentFactory(component).inputs;
                        }(component = elementModuleRef.instance.customElementComponent), strategyFactory = config.strategyFactory || new elements_ComponentNgElementStrategyFactory(component, config.injector), 
                        attributeToPropertyInputs = function(inputs) {
                            var attributeToPropertyInputs = {};
                            return inputs.forEach(function(_a) {
                                var input, propName = _a.propName;
                                attributeToPropertyInputs[(input = _a.templateName, input.replace(/[A-Z]/g, function(char) {
                                    return "-" + char.toLowerCase();
                                }))] = propName;
                            }), attributeToPropertyInputs;
                        }(inputs), NgElementImpl = function(_super) {
                            function NgElementImpl(injector) {
                                var _this = _super.call(this) || this;
                                return _this.ngElementStrategy = strategyFactory.create(injector || config.injector), 
                                _this;
                            }
                            return __extends(NgElementImpl, _super), NgElementImpl.prototype.attributeChangedCallback = function(attrName, oldValue, newValue, namespace) {
                                this.ngElementStrategy || (this.ngElementStrategy = strategyFactory.create(config.injector)), 
                                this.ngElementStrategy.setInputValue(attributeToPropertyInputs[attrName], newValue);
                            }, NgElementImpl.prototype.connectedCallback = function() {
                                var _this = this;
                                this.ngElementStrategy || (this.ngElementStrategy = strategyFactory.create(config.injector)), 
                                this.ngElementStrategy.connect(this), this.ngElementEventsSubscription = this.ngElementStrategy.events.subscribe(function(e) {
                                    var customEvent = function(doc, name, detail) {
                                        if ("function" != typeof CustomEvent) {
                                            var event_1 = _this.ownerDocument.createEvent("CustomEvent");
                                            return event_1.initCustomEvent(name, !1, !1, detail), event_1;
                                        }
                                        return new CustomEvent(name, {
                                            bubbles: !1,
                                            cancelable: !1,
                                            detail: detail
                                        });
                                    }(0, e.name, e.value);
                                    _this.dispatchEvent(customEvent);
                                });
                            }, NgElementImpl.prototype.disconnectedCallback = function() {
                                this.ngElementStrategy && this.ngElementStrategy.disconnect(), this.ngElementEventsSubscription && (this.ngElementEventsSubscription.unsubscribe(), 
                                this.ngElementEventsSubscription = null);
                            }, NgElementImpl.observedAttributes = Object.keys(attributeToPropertyInputs), NgElementImpl;
                        }(elements_NgElement), inputs.map(function(_a) {
                            return _a.propName;
                        }).forEach(function(property) {
                            Object.defineProperty(NgElementImpl.prototype, property, {
                                get: function() {
                                    return this.ngElementStrategy.getInputValue(property);
                                },
                                set: function(newValue) {
                                    this.ngElementStrategy.setInputValue(property, newValue);
                                },
                                configurable: !0,
                                enumerable: !0
                            });
                        }), NgElementImpl);
                        return customElements.define(selector, CustomElement), customElements.whenDefined(selector);
                    }).then(function() {
                        _this.elementsLoading.delete(selector), _this.elementsToLoad.delete(selector);
                    }).catch(function(err) {
                        return _this.elementsLoading.delete(selector), Promise.reject(err);
                    });
                    return this.elementsLoading.set(selector, loadedAndRegistered), loadedAndRegistered;
                }
                return Promise.resolve();
            }, ElementsLoader.ngInjectableDef = defineInjectable({
                token: ElementsLoader,
                factory: function(t) {
                    return new (t || ElementsLoader)(inject(NgModuleFactoryLoader), inject(NgModuleRef), inject(ELEMENT_MODULE_PATHS_TOKEN));
                },
                providedIn: null
            }), ElementsLoader;
        }(), initialDocViewerElement = document.querySelector("aio-doc-viewer"), initialDocViewerContent = initialDocViewerElement ? initialDocViewerElement.innerHTML : "", doc_viewer_component_DocViewerComponent = function() {
            function DocViewerComponent(elementRef, logger, titleService, metaService, tocService, elementsLoader) {
                var _this = this;
                this.logger = logger, this.titleService = titleService, this.metaService = metaService, 
                this.tocService = tocService, this.elementsLoader = elementsLoader, this.void$ = of(void 0), 
                this.onDestroy$ = new core_EventEmitter(), this.docContents$ = new core_EventEmitter(), 
                this.currViewContainer = document.createElement("div"), this.nextViewContainer = document.createElement("div"), 
                this.docReady = new core_EventEmitter(), this.docRemoved = new core_EventEmitter(), 
                this.docInserted = new core_EventEmitter(), this.docRendered = new core_EventEmitter(), 
                this.hostElement = elementRef.nativeElement, this.hostElement.innerHTML = initialDocViewerContent, 
                this.hostElement.firstElementChild && (this.currViewContainer = this.hostElement.firstElementChild), 
                this.docContents$.pipe(switchMap(function(newDoc) {
                    return _this.render(newDoc);
                }), takeUntil(this.onDestroy$)).subscribe();
            }
            return Object.defineProperty(DocViewerComponent.prototype, "doc", {
                set: function(newDoc) {
                    newDoc && this.docContents$.emit(newDoc);
                },
                enumerable: !0,
                configurable: !0
            }), DocViewerComponent.prototype.ngOnDestroy = function() {
                this.onDestroy$.emit();
            }, DocViewerComponent.prototype.prepareTitleAndToc = function(targetElem, docId) {
                var _this = this, titleEl = targetElem.querySelector("h1"), needsToc = !!titleEl && !/no-?toc/i.test(titleEl.className), embeddedToc = targetElem.querySelector("aio-toc.embedded");
                return needsToc && !embeddedToc ? titleEl.insertAdjacentHTML("afterend", '<aio-toc class="embedded"></aio-toc>') : !needsToc && embeddedToc && null !== embeddedToc.parentNode && embeddedToc.parentNode.removeChild(embeddedToc), 
                function() {
                    _this.tocService.reset();
                    var title = "";
                    titleEl && (title = "string" == typeof titleEl.innerText ? titleEl.innerText : titleEl.textContent, 
                    needsToc && _this.tocService.genToc(targetElem, docId)), _this.titleService.setTitle(title ? "Angular - " + title : "Angular");
                };
            }, DocViewerComponent.prototype.render = function(doc) {
                var addTitleAndToc, _this = this;
                return this.setNoIndex("file-not-found" === doc.id || "fetching-error" === doc.id), 
                this.void$.pipe(tap(function() {
                    return _this.nextViewContainer.innerHTML = doc.contents || "";
                }), tap(function() {
                    return addTitleAndToc = _this.prepareTitleAndToc(_this.nextViewContainer, doc.id);
                }), switchMap(function() {
                    return _this.elementsLoader.loadContainedCustomElements(_this.nextViewContainer);
                }), tap(function() {
                    return _this.docReady.emit();
                }), switchMap(function() {
                    return _this.swapViews(addTitleAndToc);
                }), tap(function() {
                    return _this.docRendered.emit();
                }), catchError(function(err) {
                    var errorMessage = err instanceof Error ? err.stack : err;
                    return _this.logger.error(new Error("[DocViewer] Error preparing document '" + doc.id + "': " + errorMessage)), 
                    _this.nextViewContainer.innerHTML = "", _this.setNoIndex(!0), _this.void$;
                }));
            }, DocViewerComponent.prototype.setNoIndex = function(val) {
                val ? this.metaService.addTag({
                    name: "robots",
                    content: "noindex"
                }) : this.metaService.removeTag('name="robots"');
            }, DocViewerComponent.prototype.swapViews = function(onInsertedCb) {
                var _this = this;
                void 0 === onInsertedCb && (onInsertedCb = function() {});
                var raf$ = new Observable_Observable(function(subscriber) {
                    var rafId = requestAnimationFrame(function() {
                        subscriber.next(), subscriber.complete();
                    });
                    return function() {
                        return cancelAnimationFrame(rafId);
                    };
                }), animateProp = function(elem, prop, from, to, duration) {
                    void 0 === duration && (duration = 200);
                    var animationsDisabled = !DocViewerComponent.animationsEnabled || _this.hostElement.classList.contains("no-animations");
                    return "length" === prop || "parentRule" === prop ? _this.void$ : (elem.style.transition = "", 
                    animationsDisabled ? _this.void$.pipe(tap(function() {
                        return elem.style[prop] = to;
                    })) : _this.void$.pipe(switchMap(function() {
                        return raf$;
                    }), tap(function() {
                        return elem.style[prop] = from;
                    }), switchMap(function() {
                        return raf$;
                    }), tap(function() {
                        return elem.style.transition = "all " + duration + "ms ease-in-out";
                    }), switchMap(function() {
                        return raf$;
                    }), tap(function() {
                        return elem.style[prop] = to;
                    }), switchMap(function() {
                        return timer(function(elem) {
                            var cssValue = getComputedStyle(elem).transitionDuration || "";
                            return 1e3 * Number(cssValue.replace(/s$/, ""));
                        }(elem));
                    }), switchMap(function() {
                        return _this.void$;
                    })));
                }, done$ = this.void$;
                return this.currViewContainer.parentElement && (done$ = done$.pipe(switchMap(function() {
                    return animateProp(_this.currViewContainer, "opacity", "1", "0.1");
                }), tap(function() {
                    return _this.currViewContainer.parentElement.removeChild(_this.currViewContainer);
                }), tap(function() {
                    return _this.docRemoved.emit();
                }))), done$.pipe(tap(function() {
                    return _this.hostElement.appendChild(_this.nextViewContainer);
                }), tap(function() {
                    return onInsertedCb();
                }), tap(function() {
                    return _this.docInserted.emit();
                }), switchMap(function() {
                    return animateProp(_this.nextViewContainer, "opacity", "0.1", "1");
                }), tap(function() {
                    var prevViewContainer = _this.currViewContainer;
                    _this.currViewContainer = _this.nextViewContainer, _this.nextViewContainer = prevViewContainer, 
                    _this.nextViewContainer.innerHTML = "";
                }));
            }, DocViewerComponent.animationsEnabled = !0, DocViewerComponent.ngComponentDef = defineComponent({
                type: DocViewerComponent,
                selectors: [ [ "aio-doc-viewer" ] ],
                factory: function(t) {
                    return new (t || DocViewerComponent)(directiveInject(ElementRef), directiveInject(logger_service_Logger), directiveInject(platform_browser_Title), directiveInject(platform_browser_Meta), directiveInject(toc_service_TocService), directiveInject(elements_loader_ElementsLoader));
                },
                inputs: {
                    doc: "doc"
                },
                outputs: {
                    docReady: "docReady",
                    docRemoved: "docRemoved",
                    docInserted: "docInserted",
                    docRendered: "docRendered"
                },
                consts: 0,
                vars: 0,
                template: function(rf, ctx) {},
                encapsulation: 2
            }), DocViewerComponent;
        }(), footer_component_c0 = [ 1, "grid-fluid" ], footer_component_c1 = [ "class", "footer-block", 4, "ngFor", "ngForOf" ], footer_component_c2 = [ "href", "license", "title", "License text" ], footer_component_c3 = [ "href", "http://creativecommons.org/licenses/by/4.0/" ], footer_component_c4 = [ 1, "footer-block" ], footer_component_c5 = [ 4, "ngFor", "ngForOf" ], footer_component_c6 = [ 1, "link", 3, "href", "title" ];
        function FooterComponent_div_1_li_4_Template(rf, ctx) {
            if (1 & rf && (elementStart(0, "li"), elementStart(1, "a", footer_component_c6), 
            core_text(2), elementEnd(), elementEnd()), 2 & rf) {
                var item_r27 = ctx.$implicit;
                core_select(1), elementProperty(1, "href", bind(item_r27.url), sanitizeUrl), elementProperty(1, "title", bind(item_r27.tooltip || item_r27.title)), 
                core_select(2), textBinding(2, interpolation1("", item_r27.title, ""));
            }
        }
        function FooterComponent_div_1_Template(rf, ctx) {
            if (1 & rf && (elementStart(0, "div", footer_component_c4), elementStart(1, "h3"), 
            core_text(2), elementEnd(), elementStart(3, "ul"), template(4, FooterComponent_div_1_li_4_Template, 3, 3, "li", footer_component_c5), 
            elementEnd(), elementEnd()), 2 & rf) {
                var node_r25 = ctx.$implicit;
                core_select(2), textBinding(2, interpolation1("", node_r25.title, "")), core_select(4), 
                elementProperty(4, "ngForOf", bind(node_r25.children));
            }
        }
        var footer_component_FooterComponent = function() {
            function FooterComponent() {}
            return FooterComponent.ngComponentDef = defineComponent({
                type: FooterComponent,
                selectors: [ [ "aio-footer" ] ],
                factory: function(t) {
                    return new (t || FooterComponent)();
                },
                inputs: {
                    nodes: "nodes",
                    versionInfo: "versionInfo"
                },
                consts: 12,
                vars: 2,
                template: function(rf, ctx) {
                    1 & rf && (elementStart(0, "div", footer_component_c0), template(1, FooterComponent_div_1_Template, 5, 2, "div", footer_component_c1), 
                    elementEnd(), elementStart(2, "p"), core_text(3, " Super-powered by Google \xa92010-2019. Code licensed under an "), 
                    elementStart(4, "a", footer_component_c2), core_text(5, "MIT-style License"), elementEnd(), 
                    core_text(6, ". Documentation licensed under "), elementStart(7, "a", footer_component_c3), 
                    core_text(8, "CC BY 4.0"), elementEnd(), core_text(9, ".\n"), elementEnd(), elementStart(10, "p"), 
                    core_text(11), elementEnd()), 2 & rf && (core_select(1), elementProperty(1, "ngForOf", bind(ctx.nodes)), 
                    core_select(11), textBinding(11, interpolation1(" Version ", null == ctx.versionInfo ? null : ctx.versionInfo.full, ".\n")));
                },
                directives: [ common_NgForOf ],
                encapsulation: 2
            }), FooterComponent;
        }(), top_menu_component_c0 = [ "role", "navigation" ], top_menu_component_c1 = [ 4, "ngFor", "ngForOf" ], top_menu_component_c2 = [ 1, "nav-link", 3, "href", "title" ], top_menu_component_c3 = [ 1, "nav-link-inner" ];
        function TopMenuComponent_li_1_Template(rf, ctx) {
            if (1 & rf && (elementStart(0, "li"), elementStart(1, "a", top_menu_component_c2), 
            elementStart(2, "span", top_menu_component_c3), core_text(3), elementEnd(), elementEnd(), 
            elementEnd()), 2 & rf) {
                var node_r23 = ctx.$implicit;
                core_select(1), elementProperty(1, "href", bind(node_r23.url), sanitizeUrl), elementProperty(1, "title", bind(node_r23.title)), 
                core_select(3), textBinding(3, interpolation1("", node_r23.title, ""));
            }
        }
        var top_menu_component_TopMenuComponent = function() {
            function TopMenuComponent() {}
            return TopMenuComponent.ngComponentDef = defineComponent({
                type: TopMenuComponent,
                selectors: [ [ "aio-top-menu" ] ],
                factory: function(t) {
                    return new (t || TopMenuComponent)();
                },
                inputs: {
                    nodes: "nodes"
                },
                consts: 2,
                vars: 1,
                template: function(rf, ctx) {
                    1 & rf && (elementStart(0, "ul", top_menu_component_c0), template(1, TopMenuComponent_li_1_Template, 4, 3, "li", top_menu_component_c1), 
                    elementEnd()), 2 & rf && (core_select(1), elementProperty(1, "ngForOf", bind(ctx.nodes)));
                },
                directives: [ common_NgForOf ],
                encapsulation: 2
            }), TopMenuComponent;
        }(), search_results_component_c0 = [ 1, "search-results" ], search_results_component_c1 = [ 4, "ngIf", "ngIfThen", "ngIfElse" ], search_results_component_c2 = [ "searchResults", "" ], search_results_component_c3 = [ "notFound", "" ];
        function SearchResultsComponent_div_1_Template(rf, ctx) {
            1 & rf && core_element(0, "div");
        }
        var search_results_component_c4 = [ 1, "visually-hidden" ], search_results_component_c5 = [ "class", "search-area", 4, "ngFor", "ngForOf" ], search_results_component_c6 = [ 1, "search-area" ], search_results_component_c7 = [ 1, "priority-pages" ], search_results_component_c8 = [ "class", "search-page", 4, "ngFor", "ngForOf" ], search_results_component_c9 = [ 1, "search-page" ], search_results_component_c10 = [ 1, "search-result-item", 3, "href", "click" ], search_results_component_c11 = [ 3, "class", 4, "ngIf" ];
        function SearchResultsComponent_ng_template_2_div_2_li_4_span_2_Template(rf, ctx) {
            1 & rf && (elementStart(0, "span"), elementStyling(), elementEnd()), 2 & rf && (elementStylingMap(0, interpolation1("symbol ", nextContext().$implicit.type, "")), 
            elementStylingApply(0));
        }
        var search_results_component_c12 = [ "deprecated-api-item" ];
        function SearchResultsComponent_ng_template_2_div_2_li_4_Template(rf, ctx) {
            if (1 & rf) {
                var _r53 = getCurrentView();
                elementStart(0, "li", search_results_component_c9), elementStart(1, "a", search_results_component_c10), 
                listener("click", function($event) {
                    restoreView(_r53);
                    var page_r49 = ctx.$implicit;
                    return nextContext(3).onResultSelected(page_r49, $event);
                }), template(2, SearchResultsComponent_ng_template_2_div_2_li_4_span_2_Template, 1, 1, "span", search_results_component_c11), 
                elementStart(3, "span"), elementStyling(search_results_component_c12), core_text(4), 
                elementEnd(), elementEnd(), elementEnd();
            }
            if (2 & rf) {
                var page_r49 = ctx.$implicit, area_r46 = nextContext().$implicit;
                core_select(1), elementProperty(1, "href", interpolation1("", page_r49.path, ""), sanitizeUrl), 
                core_select(2), elementProperty(2, "ngIf", bind("api" === area_r46.name)), elementClassProp(3, 0, page_r49.deprecated), 
                elementStylingApply(3), core_select(4), textBinding(4, interpolation1("", page_r49.title, ""));
            }
        }
        function SearchResultsComponent_ng_template_2_div_2_li_6_span_2_Template(rf, ctx) {
            1 & rf && (elementStart(0, "span"), elementStyling(), elementEnd()), 2 & rf && (elementStylingMap(0, interpolation1("symbol ", nextContext().$implicit.type, "")), 
            elementStylingApply(0));
        }
        function SearchResultsComponent_ng_template_2_div_2_li_6_Template(rf, ctx) {
            if (1 & rf) {
                var _r59 = getCurrentView();
                elementStart(0, "li", search_results_component_c9), elementStart(1, "a", search_results_component_c10), 
                listener("click", function($event) {
                    restoreView(_r59);
                    var page_r55 = ctx.$implicit;
                    return nextContext(3).onResultSelected(page_r55, $event);
                }), template(2, SearchResultsComponent_ng_template_2_div_2_li_6_span_2_Template, 1, 1, "span", search_results_component_c11), 
                elementStart(3, "span"), elementStyling(search_results_component_c12), core_text(4), 
                elementEnd(), elementEnd(), elementEnd();
            }
            if (2 & rf) {
                var page_r55 = ctx.$implicit, area_r46 = nextContext().$implicit;
                core_select(1), elementProperty(1, "href", interpolation1("", page_r55.path, ""), sanitizeUrl), 
                core_select(2), elementProperty(2, "ngIf", bind("api" === area_r46.name)), elementClassProp(3, 0, page_r55.deprecated), 
                elementStylingApply(3), core_select(4), textBinding(4, interpolation1("", page_r55.title, ""));
            }
        }
        function SearchResultsComponent_ng_template_2_div_2_Template(rf, ctx) {
            if (1 & rf && (elementStart(0, "div", search_results_component_c6), elementStart(1, "h3"), 
            core_text(2), elementEnd(), elementStart(3, "ul", search_results_component_c7), 
            template(4, SearchResultsComponent_ng_template_2_div_2_li_4_Template, 5, 3, "li", search_results_component_c8), 
            elementEnd(), elementStart(5, "ul"), template(6, SearchResultsComponent_ng_template_2_div_2_li_6_Template, 5, 3, "li", search_results_component_c8), 
            elementEnd(), elementEnd()), 2 & rf) {
                var area_r46 = ctx.$implicit;
                core_select(2), textBinding(2, (prefix = "", v0 = area_r46.name, i0 = " (", v1 = area_r46.pages.length + area_r46.priorityPages.length, 
                suffix = ")", lView = getLView(), different = function(lView, bindingIndex, exp1, exp2) {
                    var different = bindingUpdated(lView, bindingIndex, v0);
                    return bindingUpdated(lView, bindingIndex + 1, exp2) || different;
                }(lView, bindingIndex = lView[BINDING_INDEX], 0, v1), lView[BINDING_INDEX] += 2, 
                storeBindingMetadata(lView, prefix, suffix) && (lView[TVIEW].data[bindingIndex] = i0), 
                different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE)), 
                core_select(4), elementProperty(4, "ngForOf", bind(area_r46.priorityPages)), core_select(6), 
                elementProperty(6, "ngForOf", bind(area_r46.pages));
            }
            var prefix, v0, i0, v1, suffix, lView, bindingIndex, different;
        }
        function SearchResultsComponent_ng_template_2_Template(rf, ctx) {
            if (1 & rf && (elementStart(0, "h2", search_results_component_c4), core_text(1, "Search Results"), 
            elementEnd(), template(2, SearchResultsComponent_ng_template_2_div_2_Template, 7, 4, "div", search_results_component_c5)), 
            2 & rf) {
                var ctx_r42 = nextContext();
                core_select(2), elementProperty(2, "ngForOf", bind(ctx_r42.searchAreas));
            }
        }
        function SearchResultsComponent_ng_template_4_Template(rf, ctx) {
            if (1 & rf && (elementStart(0, "p"), core_text(1), elementEnd()), 2 & rf) {
                var ctx_r44 = nextContext();
                core_select(1), textBinding(1, interpolation1("", ctx_r44.notFoundMessage, ""));
            }
        }
        var search_results_component_SearchResultsComponent = function() {
            function SearchResultsComponent() {
                this.resultSelected = new core_EventEmitter(), this.defaultArea = "other", this.notFoundMessage = "Searching ...", 
                this.topLevelFolders = [ "guide", "tutorial" ], this.searchAreas = [];
            }
            return SearchResultsComponent.prototype.ngOnChanges = function(changes) {
                this.searchAreas = this.processSearchResults(this.searchResults);
            }, SearchResultsComponent.prototype.onResultSelected = function(page, event) {
                0 !== event.button || event.ctrlKey || event.metaKey || this.resultSelected.emit(page);
            }, SearchResultsComponent.prototype.processSearchResults = function(search) {
                var _this = this;
                if (!search) return [];
                this.notFoundMessage = "No results found.";
                var searchAreaMap = {};
                return search.results.forEach(function(result) {
                    if (result.title) {
                        var areaName = _this.computeAreaName(result) || _this.defaultArea;
                        (searchAreaMap[areaName] = searchAreaMap[areaName] || []).push(result);
                    }
                }), Object.keys(searchAreaMap).sort(function(l, r) {
                    return l > r ? 1 : -1;
                }).map(function(name) {
                    var _a = function(allPages) {
                        var priorityPages = [], pages = [], deprecated = [];
                        for (searchAreaMap[name].forEach(function(page) {
                            page.deprecated ? deprecated.push(page) : priorityPages.length < 5 ? priorityPages.push(page) : pages.push(page);
                        }); priorityPages.length < 5 && pages.length; ) priorityPages.push(pages.shift());
                        for (;priorityPages.length < 5 && deprecated.length; ) priorityPages.push(deprecated.shift());
                        return pages.sort(compareResults), {
                            priorityPages: priorityPages,
                            pages: pages,
                            deprecated: deprecated
                        };
                    }();
                    return {
                        name: name,
                        priorityPages: _a.priorityPages,
                        pages: _a.pages.concat(_a.deprecated)
                    };
                });
            }, SearchResultsComponent.prototype.computeAreaName = function(result) {
                if (-1 !== this.topLevelFolders.indexOf(result.path)) return result.path;
                var _a = result.path.split("/", 2);
                return _a[1] && _a[0];
            }, SearchResultsComponent.ngComponentDef = defineComponent({
                type: SearchResultsComponent,
                selectors: [ [ "aio-search-results" ] ],
                factory: function(t) {
                    return new (t || SearchResultsComponent)();
                },
                inputs: {
                    searchResults: "searchResults"
                },
                outputs: {
                    resultSelected: "resultSelected"
                },
                features: [ NgOnChangesFeature() ],
                consts: 6,
                vars: 3,
                template: function(rf, ctx) {
                    if (1 & rf && (elementStart(0, "div", search_results_component_c0), template(1, SearchResultsComponent_div_1_Template, 1, 0, "div", search_results_component_c1), 
                    elementEnd(), template(2, SearchResultsComponent_ng_template_2_Template, 3, 1, "ng-template", null, search_results_component_c2, templateRefExtractor), 
                    template(4, SearchResultsComponent_ng_template_4_Template, 2, 1, "ng-template", null, search_results_component_c3, templateRefExtractor)), 
                    2 & rf) {
                        var _r41 = reference(3), _r43 = reference(5);
                        core_select(1), elementProperty(1, "ngIf", bind(ctx.searchAreas.length)), elementProperty(1, "ngIfThen", bind(_r41)), 
                        elementProperty(1, "ngIfElse", bind(_r43));
                    }
                },
                directives: [ common_NgIf, common_NgForOf ],
                encapsulation: 2
            }), SearchResultsComponent;
        }();
        function compareResults(l, r) {
            return l.title.toUpperCase() > r.title.toUpperCase() ? 1 : -1;
        }
        var dt_component_c0 = [ "dt" ], dt_component_c1 = [ "rows", "10", "cols", "80", 3, "value" ], dt_component_c2 = [ "dt", "" ], dt_component_c3 = [ 3, "click" ], dt_component_DtComponent = function() {
            function DtComponent() {
                this.docChange = new core_EventEmitter();
            }
            return Object.defineProperty(DtComponent.prototype, "text", {
                get: function() {
                    return this.doc && this.doc.contents;
                },
                enumerable: !0,
                configurable: !0
            }), DtComponent.prototype.dtextSet = function() {
                this.doc.contents = this.dt.nativeElement.value, this.docChange.emit(__assign({}, this.doc));
            }, DtComponent.ngComponentDef = defineComponent({
                type: DtComponent,
                selectors: [ [ "aio-dt" ] ],
                factory: function(t) {
                    return new (t || DtComponent)();
                },
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && viewQuery(dt_component_c0, !0, ElementRef), 2 & rf && queryRefresh(_t = loadViewQuery()) && (ctx.dt = _t.first);
                },
                inputs: {
                    doc: "doc"
                },
                outputs: {
                    docChange: "docChange"
                },
                consts: 7,
                vars: 1,
                template: function(rf, ctx) {
                    1 & rf && (elementStart(0, "div"), core_element(1, "hr"), core_element(2, "textarea", dt_component_c1, dt_component_c2), 
                    core_element(4, "br"), elementStart(5, "button", dt_component_c3), listener("click", function($event) {
                        return ctx.dtextSet();
                    }), core_text(6, "Show change"), elementEnd(), elementEnd()), 2 & rf && (core_select(2), 
                    elementProperty(2, "value", bind(ctx.text)));
                },
                encapsulation: 2
            }), DtComponent;
        }(), lazy_custom_element_component_LazyCustomElementComponent = function() {
            function LazyCustomElementComponent(elementRef, elementsLoader, logger) {
                this.elementRef = elementRef, this.elementsLoader = elementsLoader, this.logger = logger, 
                this.selector = "";
            }
            return LazyCustomElementComponent.prototype.ngOnInit = function() {
                this.selector && !/[^\w-]/.test(this.selector) ? (this.elementRef.nativeElement.innerHTML = "<" + this.selector + "></" + this.selector + ">", 
                this.elementsLoader.loadCustomElement(this.selector)) : this.logger.error(new Error("Invalid selector for 'aio-lazy-ce': " + this.selector));
            }, LazyCustomElementComponent.ngComponentDef = defineComponent({
                type: LazyCustomElementComponent,
                selectors: [ [ "aio-lazy-ce" ] ],
                factory: function(t) {
                    return new (t || LazyCustomElementComponent)(directiveInject(ElementRef), directiveInject(elements_loader_ElementsLoader), directiveInject(logger_service_Logger));
                },
                inputs: {
                    selector: "selector"
                },
                consts: 0,
                vars: 0,
                template: function(rf, ctx) {},
                encapsulation: 2
            }), LazyCustomElementComponent;
        }(), app_component_c0 = [ "searchBox", "searchResultsView" ], app_component_c1 = [ "id", "top-of-page" ], app_component_c2 = [ "class", "progress-bar-container", 4, "ngIf" ], app_component_c3 = [ "color", "primary", 1, "app-toolbar", "no-print" ], app_component_c4 = [ 1, "notification-container" ], app_component_c5 = [ "notificationId", "survey-february-2019", "expirationDate", "2019-03-01", 3, "dismissOnContentClick", "dismissed" ], app_component_c6 = [ "href", "http://bit.ly/angular-survey-2019" ], app_component_c7 = [ "svgIcon", "insert_comment", "aria-label", "Announcement", 1, "icon" ], app_component_c8 = [ 1, "message" ], app_component_c9 = [ 1, "action-button" ], app_component_c10 = [ "mat-button", "", "title", "Docs menu", 1, "hamburger", 3, "click" ], app_component_c11 = [ "svgIcon", "menu" ], app_component_c12 = [ "href", "/", 1, "nav-link", "home", 3, "ngSwitch" ], app_component_c13 = [ "src", "assets/images/logos/angular/logo-nav@2x.png", "width", "150", "height", "40", "title", "Home", "alt", "Home", 4, "ngSwitchCase" ], app_component_c14 = [ "src", "assets/images/logos/angular/shield-large.svg", "width", "37", "height", "40", "title", "Home", "alt", "Home", 4, "ngSwitchDefault" ], app_component_c15 = [ 3, "nodes", 4, "ngIf" ], app_component_c16 = [ 1, "search-container", 3, "onSearch", "onFocus" ], app_component_c17 = [ "searchBox", "" ], app_component_c18 = [ 1, "toolbar-external-icons-container" ], app_component_c19 = [ "href", "https://twitter.com/angular", "title", "Twitter", "aria-label", "Angular on twitter" ], app_component_c20 = [ "svgIcon", "logos:twitter" ], app_component_c21 = [ "href", "https://github.com/angular/angular", "title", "GitHub", "aria-label", "Angular on github" ], app_component_c22 = [ "svgIcon", "logos:github" ], _c23 = [ 3, "searchResults", "resultSelected", 4, "ngIf" ], _c24 = [ "role", "main", 1, "sidenav-container" ], _c25 = [ 1, "sidenav", 3, "ngClass", "mode", "opened", "openedChange" ], _c26 = [ "sidenav", "" ], _c27 = [ 3, "nodes", "currentNode", "isWide", 4, "ngIf" ], _c28 = [ 3, "nodes", "currentNode", "isWide" ], _c29 = [ 1, "doc-version" ], _c30 = [ 3, "options", "selected", "change" ], _c31 = [ "role", "main", 1, "sidenav-content", 3, "id" ], _c32 = [ 3, "mode", "version" ], _c33 = [ 3, "doc", "docReady", "docRemoved", "docInserted", "docRendered" ], _c34 = [ 3, "doc", "docChange", 4, "ngIf" ], _c35 = [ "class", "toc-container no-print", 3, "max-height", "mousewheel", 4, "ngIf" ], _c36 = [ 1, "no-print" ], _c37 = [ 3, "nodes", "versionInfo" ], _c38 = [ "class", "cdk-visually-hidden", 4, "ngIf" ], _c39 = [ 1, "progress-bar-container" ], _c40 = [ "mode", "indeterminate", "color", "warn" ];
        function AppComponent_div_1_Template(rf, ctx) {
            1 & rf && (elementStart(0, "div", _c39), core_element(1, "mat-progress-bar", _c40), 
            elementEnd());
        }
        var _c41 = [ "src", "assets/images/logos/angular/logo-nav@2x.png", "width", "150", "height", "40", "title", "Home", "alt", "Home" ];
        function AppComponent_img_18_Template(rf, ctx) {
            1 & rf && core_element(0, "img", _c41);
        }
        var _c42 = [ "src", "assets/images/logos/angular/shield-large.svg", "width", "37", "height", "40", "title", "Home", "alt", "Home" ];
        function AppComponent_img_19_Template(rf, ctx) {
            1 & rf && core_element(0, "img", _c42);
        }
        var _c43 = [ 3, "nodes" ];
        function AppComponent_aio_top_menu_20_Template(rf, ctx) {
            if (1 & rf && core_element(0, "aio-top-menu", _c43), 2 & rf) {
                var ctx_r4 = nextContext();
                core_select(0), elementProperty(0, "nodes", bind(ctx_r4.topMenuNodes));
            }
        }
        var _c44 = [ 3, "searchResults", "resultSelected" ], _c45 = [ "searchResultsView", "" ];
        function AppComponent_aio_search_results_28_Template(rf, ctx) {
            if (1 & rf) {
                var _r14 = getCurrentView();
                elementStart(0, "aio-search-results", _c44, _c45), listener("resultSelected", function($event) {
                    return restoreView(_r14), nextContext().hideSearchResults();
                }), tView = getLView()[TVIEW], adjustedIndex = 2 + HEADER_OFFSET, tView.firstTemplatePass ? (pipeDef = function(name, registry) {
                    if (registry) for (var i = registry.length - 1; i >= 0; i--) {
                        var pipeDef = registry[i];
                        if ("async" === pipeDef.name) return pipeDef;
                    }
                    throw new Error("The pipe 'async' could not be found!");
                }(0, tView.pipeRegistry), tView.data[adjustedIndex] = pipeDef, pipeDef.onDestroy && (tView.destroyHooks || (tView.destroyHooks = [])).push(adjustedIndex, pipeDef.onDestroy)) : pipeDef = tView.data[adjustedIndex], 
                store(2, pipeDef.factory(null)), elementEnd();
            }
            var pipeDef, tView, adjustedIndex, index, slotOffset, v1, pipeInstance;
            if (2 & rf) {
                var ctx_r6 = nextContext();
                core_select(0), elementProperty(0, "searchResults", bind((slotOffset = 1, v1 = ctx_r6.searchResults, 
                pipeInstance = load(index = 2), function(newValue) {
                    if (WrappedValue.isWrapped(newValue)) {
                        newValue = WrappedValue.unwrap(newValue);
                        var lView = getLView();
                        lView[lView[BINDING_INDEX]] = NO_CHANGE;
                    }
                    return newValue;
                }(function(index) {
                    return getLView()[TVIEW].data[index + HEADER_OFFSET].pure;
                }(index) ? pureFunction1(slotOffset, pipeInstance.transform, v1, pipeInstance) : pipeInstance.transform(v1)))));
            }
        }
        function AppComponent_aio_nav_menu_32_Template(rf, ctx) {
            if (1 & rf && core_element(0, "aio-nav-menu", _c28), 2 & rf) {
                var ctx_r8 = nextContext();
                core_select(0), elementProperty(0, "nodes", bind(ctx_r8.topMenuNarrowNodes)), elementProperty(0, "currentNode", bind(null == ctx_r8.currentNodes ? null : ctx_r8.currentNodes.TopBarNarrow)), 
                elementProperty(0, "isWide", bind(!1));
            }
        }
        var _c46 = [ 3, "doc", "docChange" ];
        function AppComponent_aio_dt_39_Template(rf, ctx) {
            if (1 & rf) {
                var _r16 = getCurrentView();
                elementStart(0, "aio-dt", _c46), listener("docChange", function($event) {
                    return restoreView(_r16), nextContext().currentDocument = $event;
                }), elementEnd();
            }
            if (2 & rf) {
                var ctx_r9 = nextContext();
                core_select(0), elementProperty(0, "doc", bind(ctx_r9.currentDocument));
            }
        }
        var _c47 = [ 1, "toc-container", "no-print", 3, "mousewheel" ], _c48 = [ "selector", "aio-toc" ], _c49 = [ "max-height" ];
        function AppComponent_div_40_Template(rf, ctx) {
            if (1 & rf) {
                var _r18 = getCurrentView();
                elementStart(0, "div", _c47), elementStyling(null, _c49), listener("mousewheel", function($event) {
                    return restoreView(_r18), nextContext().restrainScrolling($event);
                }), core_element(1, "aio-lazy-ce", _c48), elementEnd();
            }
            2 & rf && (0, 0, elementStylePropInternal(null, 0, 0, nextContext().tocMaxHeight, "px", void 0), 
            elementStylingApply(0));
        }
        var _c50 = [ 1, "cdk-visually-hidden" ];
        function AppComponent_div_43_Template(rf, ctx) {
            1 & rf && (elementStart(0, "div", _c50), elementStart(1, "mat-icon"), core_text(2, "\xa0"), 
            elementEnd(), elementEnd());
        }
        var _c51 = [ "transitioning" ], _c52 = [ "starting" ], _c53 = [ "starting", "has-floating-toc" ], _c54 = [ "no-animations" ], _c55 = function(a0) {
            return {
                collapsed: a0
            };
        }, app_component_AppComponent = function() {
            function AppComponent(deployment, documentService, hostElement, locationService, navigationService, scrollService, searchService, tocService) {
                this.deployment = deployment, this.documentService = documentService, this.hostElement = hostElement, 
                this.locationService = locationService, this.navigationService = navigationService, 
                this.scrollService = scrollService, this.searchService = searchService, this.tocService = tocService, 
                this.currentNodes = {}, this.dtOn = !1, this.hostClasses = "", this.isStarting = !0, 
                this.isTransitioning = !0, this.isFetching = !1, this.isSideBySide = !1, this.isSideNavDoc = !1, 
                this.sideBySideWidth = 992, this.hasFloatingToc = !1, this.showFloatingToc = new BehaviorSubject_BehaviorSubject(!1), 
                this.showFloatingTocWidth = 800, this.tocMaxHeightOffset = 0, this.showSearchResults = !1, 
                this.notificationAnimating = !1;
            }
            return Object.defineProperty(AppComponent.prototype, "isOpened", {
                get: function() {
                    return this.isSideBySide && this.isSideNavDoc;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(AppComponent.prototype, "mode", {
                get: function() {
                    return this.isSideBySide ? "side" : "over";
                },
                enumerable: !0,
                configurable: !0
            }), AppComponent.prototype.ngOnInit = function() {
                var _this = this;
                "Worker" in window && this.searchService.initWorker("app/search/search-worker.js", 2e3), 
                this.onResize(window.innerWidth), this.documentService.currentDocument.subscribe(function(doc) {
                    return _this.currentDocument = doc;
                }), this.locationService.currentPath.subscribe(function(path) {
                    "archive" !== _this.deployment.mode || /^(docs$|api|guide|tutorial)/.test(path) || _this.locationService.replace("docs"), 
                    path === _this.currentPath ? _this.scrollService.scroll() : (_this.currentPath = path, 
                    clearTimeout(_this.isFetchingTimeout), _this.isFetchingTimeout = setTimeout(function() {
                        return _this.isFetching = !0;
                    }, 200));
                }), this.navigationService.currentNodes.subscribe(function(currentNodes) {
                    return _this.currentNodes = currentNodes;
                }), combineLatest(this.navigationService.versionInfo, this.navigationService.navigationViews.pipe(map_map(function(views) {
                    return views.docVersions;
                }))).subscribe(function(_a) {
                    var versionInfo = _a[0], versions = _a[1], computedVersions = [ {
                        title: "next",
                        url: "https://next.angular.io"
                    }, {
                        title: "stable",
                        url: "https://angular.io"
                    } ];
                    "archive" === _this.deployment.mode && computedVersions.push({
                        title: "v" + versionInfo.major
                    }), _this.docVersions = computedVersions.concat(versions), _this.currentDocVersion = _this.docVersions.find(function(version) {
                        return version.title === _this.deployment.mode || version.title === "v" + versionInfo.major;
                    }), _this.currentDocVersion.title += " (v" + versionInfo.raw + ")";
                }), this.navigationService.navigationViews.subscribe(function(views) {
                    _this.footerNodes = views.Footer || [], _this.sideNavNodes = views.SideNav || [], 
                    _this.topMenuNodes = views.TopBar || [], _this.topMenuNarrowNodes = views.TopBarNarrow || _this.topMenuNodes;
                }), this.navigationService.versionInfo.subscribe(function(vi) {
                    return _this.versionInfo = vi;
                }), combineLatest(this.tocService.tocList.pipe(map_map(function(tocList) {
                    return tocList.length > 0;
                })), this.showFloatingToc).subscribe(function(_a) {
                    return _this.hasFloatingToc = _a[0] && _a[1];
                }), combineLatest(this.documentService.currentDocument, this.navigationService.currentNodes).pipe(first_first()).subscribe(function() {
                    return _this.updateShell();
                });
            }, AppComponent.prototype.onDocReady = function() {
                var _this = this;
                this.isTransitioning = !0, clearTimeout(this.isFetchingTimeout), setTimeout(function() {
                    return _this.isFetching = !1;
                }, 500);
            }, AppComponent.prototype.onDocRemoved = function() {
                this.scrollService.removeStoredScrollPosition();
            }, AppComponent.prototype.onDocInserted = function() {
                var _this = this;
                setTimeout(function() {
                    return _this.updateShell();
                }), this.scrollService.scrollAfterRender(500);
            }, AppComponent.prototype.onDocRendered = function() {
                var _this = this;
                this.isStarting && setTimeout(function() {
                    return _this.isStarting = !1;
                }, 100), this.isTransitioning = !1;
            }, AppComponent.prototype.onDocVersionChange = function(versionIndex) {
                var version = this.docVersions[versionIndex];
                version.url && this.locationService.go(version.url);
            }, AppComponent.prototype.onResize = function(width) {
                this.isSideBySide = width >= this.sideBySideWidth, this.showFloatingToc.next(width > this.showFloatingTocWidth), 
                this.isSideBySide && !this.isSideNavDoc && this.sidenav.toggle(!1);
            }, AppComponent.prototype.onClick = function(eventTarget, button, ctrlKey, metaKey, altKey) {
                if (this.searchElements.some(function(element) {
                    return element.nativeElement.contains(eventTarget);
                }) || this.hideSearchResults(), "FOOTER" === eventTarget.tagName && metaKey && altKey) return this.dtOn = !this.dtOn, 
                !1;
                for (var target = eventTarget; target && !(target instanceof HTMLAnchorElement); ) target = target.parentElement;
                return !(target instanceof HTMLAnchorElement) || this.locationService.handleAnchorClick(target, button, ctrlKey, metaKey);
            }, AppComponent.prototype.setPageId = function(id) {
                this.pageId = "index" === id ? "home" : id.replace("/", "-");
            }, AppComponent.prototype.setFolderId = function(id) {
                this.folderId = "index" === id ? "home" : id.split("/", 1)[0];
            }, AppComponent.prototype.notificationDismissed = function() {
                var _this = this;
                this.notificationAnimating = !0, setTimeout(function() {
                    return _this.notificationAnimating = !1;
                }, 250), this.updateHostClasses();
            }, AppComponent.prototype.updateHostClasses = function() {
                var mode = "mode-" + this.deployment.mode, sideNavOpen = "sidenav-" + (this.sidenav.opened ? "open" : "closed"), pageClass = "page-" + this.pageId, folderClass = "folder-" + this.folderId, viewClasses = Object.keys(this.currentNodes).map(function(view) {
                    return "view-" + view;
                }).join(" ");
                this.hostClasses = [ mode, sideNavOpen, pageClass, folderClass, viewClasses, "aio-notification-" + this.notification.showNotification, this.notificationAnimating ? "aio-notification-animating" : "" ].join(" ");
            }, AppComponent.prototype.updateShell = function() {
                this.updateSideNav(), this.setPageId(this.currentDocument.id), this.setFolderId(this.currentDocument.id), 
                this.updateHostClasses();
            }, AppComponent.prototype.updateSideNav = function() {
                var openSideNav = this.sidenav.opened, isSideNavDoc = !!this.currentNodes.SideNav;
                this.isSideNavDoc !== isSideNavDoc && (openSideNav = this.isSideNavDoc = isSideNavDoc), 
                this.sidenav.toggle(this.isSideBySide && openSideNav);
            }, AppComponent.prototype.onScroll = function() {
                if (!this.tocMaxHeightOffset) {
                    var el = this.hostElement.nativeElement, headerEl = el.querySelector(".app-toolbar"), footerEl = el.querySelector("footer");
                    headerEl && footerEl && (this.tocMaxHeightOffset = headerEl.clientHeight + footerEl.clientHeight + 24);
                }
                this.tocMaxHeight = (document.body.scrollHeight - window.pageYOffset - this.tocMaxHeightOffset).toFixed(2);
            }, AppComponent.prototype.restrainScrolling = function(evt) {
                var elem = evt.currentTarget, scrollTop = elem.scrollTop;
                evt.deltaY < 0 ? scrollTop < 1 && evt.preventDefault() : elem.scrollHeight - elem.clientHeight - scrollTop < 1 && evt.preventDefault();
            }, AppComponent.prototype.hideSearchResults = function() {
                this.showSearchResults = !1;
                var oldSearch = this.locationService.search();
                void 0 !== oldSearch.search && this.locationService.setSearch("", __assign({}, oldSearch, {
                    search: void 0
                }));
            }, AppComponent.prototype.focusSearchBox = function() {
                this.searchBox && this.searchBox.focus();
            }, AppComponent.prototype.doSearch = function(query) {
                this.searchResults = this.searchService.search(query), this.showSearchResults = !!query;
            }, AppComponent.prototype.onKeyUp = function(key, keyCode) {
                "/" !== key && 191 !== keyCode || this.focusSearchBox(), "Escape" !== key && 27 !== keyCode || this.showSearchResults && (this.hideSearchResults(), 
                this.focusSearchBox());
            }, AppComponent.ngComponentDef = defineComponent({
                type: AppComponent,
                selectors: [ [ "aio-shell" ] ],
                factory: function(t) {
                    return new (t || AppComponent)(directiveInject(deployment_service_Deployment), directiveInject(document_service_DocumentService), directiveInject(ElementRef), directiveInject(location_service_LocationService), directiveInject(navigation_service_NavigationService), directiveInject(scroll_service_ScrollService), directiveInject(search_service_SearchService), directiveInject(toc_service_TocService));
                },
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && (viewQuery(search_box_component_SearchBoxComponent, !0, null), viewQuery(sidenav_es5_MatSidenav, !0, null), 
                    viewQuery(notification_component_NotificationComponent, !0, null), viewQuery(app_component_c0, !0, ElementRef)), 
                    2 & rf && (queryRefresh(_t = loadViewQuery()) && (ctx.searchBox = _t.first), queryRefresh(_t = loadViewQuery()) && (ctx.sidenav = _t.first), 
                    queryRefresh(_t = loadViewQuery()) && (ctx.notification = _t.first), queryRefresh(_t = loadViewQuery()) && (ctx.searchElements = _t));
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (allocHostVars(1), listener("resize", function($event) {
                        return ctx.onResize($event.target.innerWidth);
                    }, !1, resolveWindow), listener("click", function($event) {
                        return ctx.onClick($event.target, $event.button, $event.ctrlKey, $event.metaKey, $event.altKey);
                    }), listener("scroll", function($event) {
                        return ctx.onScroll();
                    }, !1, resolveWindow), listener("keyup", function($event) {
                        return ctx.onKeyUp($event.key, $event.which);
                    }, !1, resolveDocument), elementHostStyling()), 2 & rf && (componentHostSyntheticProperty(elIndex, "@.disabled", bind(ctx.isStarting), null, !0), 
                    elementHostStylingMap(ctx.hostClasses), elementHostStylingApply());
                },
                consts: 44,
                vars: 26,
                template: function(rf, ctx) {
                    if (1 & rf) {
                        var _r19 = getCurrentView();
                        core_element(0, "div", app_component_c1), template(1, AppComponent_div_1_Template, 2, 0, "div", app_component_c2), 
                        elementStart(2, "mat-toolbar", app_component_c3), elementStyling(_c51), elementStart(3, "mat-toolbar-row", app_component_c4), 
                        elementStart(4, "aio-notification", app_component_c5), listener("dismissed", function($event) {
                            return ctx.notificationDismissed();
                        }), elementStart(5, "a", app_component_c6), core_element(6, "mat-icon", app_component_c7), 
                        elementStart(7, "span", app_component_c8), core_text(8, "Help Angular by taking a "), 
                        elementStart(9, "b"), core_text(10, "1 minute survey"), elementEnd(), core_text(11, "!"), 
                        elementEnd(), elementStart(12, "span", app_component_c9), core_text(13, "Go to survey"), 
                        elementEnd(), elementEnd(), elementEnd(), elementEnd(), elementStart(14, "mat-toolbar-row"), 
                        elementStart(15, "button", app_component_c10), elementStyling(_c52), listener("click", function($event) {
                            return restoreView(_r19), reference(31).toggle();
                        }), core_element(16, "mat-icon", app_component_c11), elementEnd(), elementStart(17, "a", app_component_c12), 
                        template(18, AppComponent_img_18_Template, 1, 0, "img", app_component_c13), template(19, AppComponent_img_19_Template, 1, 0, "img", app_component_c14), 
                        elementEnd(), template(20, AppComponent_aio_top_menu_20_Template, 1, 1, "aio-top-menu", app_component_c15), 
                        elementStart(21, "aio-search-box", app_component_c16, app_component_c17), listener("onSearch", function($event) {
                            return ctx.doSearch($event);
                        }), listener("onFocus", function($event) {
                            return ctx.doSearch($event);
                        }), elementEnd(), elementStart(23, "div", app_component_c18), elementStart(24, "a", app_component_c19), 
                        core_element(25, "mat-icon", app_component_c20), elementEnd(), elementStart(26, "a", app_component_c21), 
                        core_element(27, "mat-icon", app_component_c22), elementEnd(), elementEnd(), elementEnd(), 
                        elementEnd(), template(28, AppComponent_aio_search_results_28_Template, 3, 3, "aio-search-results", _c23), 
                        elementStart(29, "mat-sidenav-container", _c24), elementStyling(_c53), elementStart(30, "mat-sidenav", _c25, _c26), 
                        listener("openedChange", function($event) {
                            return ctx.updateHostClasses();
                        }), template(32, AppComponent_aio_nav_menu_32_Template, 1, 3, "aio-nav-menu", _c27), 
                        core_element(33, "aio-nav-menu", _c28), elementStart(34, "div", _c29), elementStart(35, "aio-select", _c30), 
                        listener("change", function($event) {
                            return ctx.onDocVersionChange($event.index);
                        }), elementEnd(), elementEnd(), elementEnd(), elementStart(36, "main", _c31), core_element(37, "aio-mode-banner", _c32), 
                        elementStart(38, "aio-doc-viewer", _c33), elementStyling(_c54), listener("docReady", function($event) {
                            return ctx.onDocReady();
                        }), listener("docRemoved", function($event) {
                            return ctx.onDocRemoved();
                        }), listener("docInserted", function($event) {
                            return ctx.onDocInserted();
                        }), listener("docRendered", function($event) {
                            return ctx.onDocRendered();
                        }), elementEnd(), template(39, AppComponent_aio_dt_39_Template, 1, 1, "aio-dt", _c34), 
                        elementEnd(), elementEnd(), template(40, AppComponent_div_40_Template, 2, 0, "div", _c35), 
                        elementStart(41, "footer", _c36), core_element(42, "aio-footer", _c37), elementEnd(), 
                        template(43, AppComponent_div_43_Template, 3, 0, "div", _c38);
                    }
                    2 & rf && (core_select(1), elementProperty(1, "ngIf", bind(ctx.isFetching)), elementClassProp(2, 0, ctx.isTransitioning), 
                    elementStylingApply(2), core_select(4), elementProperty(4, "dismissOnContentClick", bind(!0)), 
                    elementClassProp(15, 0, ctx.isStarting), elementStylingApply(15), core_select(17), 
                    elementProperty(17, "ngSwitch", bind(ctx.isSideBySide)), core_select(18), elementProperty(18, "ngSwitchCase", bind(!0)), 
                    core_select(20), elementProperty(20, "ngIf", bind(ctx.isSideBySide)), core_select(28), 
                    elementProperty(28, "ngIf", bind(ctx.showSearchResults)), elementClassProp(29, 0, ctx.isStarting), 
                    elementClassProp(29, 1, ctx.hasFloatingToc), elementStylingApply(29), core_select(30), 
                    elementProperty(30, "ngClass", bind(pureFunction1(24, _c55, !ctx.isSideBySide))), 
                    elementProperty(30, "mode", bind(ctx.mode)), elementProperty(30, "opened", bind(ctx.isOpened)), 
                    core_select(32), elementProperty(32, "ngIf", bind(!ctx.isSideBySide)), core_select(33), 
                    elementProperty(33, "nodes", bind(ctx.sideNavNodes)), elementProperty(33, "currentNode", bind(null == ctx.currentNodes ? null : ctx.currentNodes.SideNav)), 
                    elementProperty(33, "isWide", bind(ctx.isSideBySide)), core_select(35), elementProperty(35, "options", bind(ctx.docVersions)), 
                    elementProperty(35, "selected", bind(ctx.currentDocVersion)), core_select(36), elementProperty(36, "id", bind(ctx.pageId)), 
                    core_select(37), elementProperty(37, "mode", bind(ctx.deployment.mode)), elementProperty(37, "version", bind(ctx.versionInfo)), 
                    elementClassProp(38, 0, ctx.isStarting), elementStylingApply(38), core_select(38), 
                    elementProperty(38, "doc", bind(ctx.currentDocument)), core_select(39), elementProperty(39, "ngIf", bind(ctx.dtOn)), 
                    core_select(40), elementProperty(40, "ngIf", bind(ctx.hasFloatingToc)), core_select(42), 
                    elementProperty(42, "nodes", bind(ctx.footerNodes)), elementProperty(42, "versionInfo", bind(ctx.versionInfo)), 
                    core_select(43), elementProperty(43, "ngIf", bind(!ctx.isStarting)));
                },
                directives: [ common_NgIf, toolbar_es5_MatToolbar, toolbar_es5_MatToolbarRow, notification_component_NotificationComponent, icon_es5_MatIcon, button_es5_MatButton, common_NgSwitch, common_NgSwitchCase, common_NgSwitchDefault, search_box_component_SearchBoxComponent, sidenav_es5_MatSidenavContainer, sidenav_es5_MatSidenav, common_NgClass, nav_menu_component_NavMenuComponent, select_component_SelectComponent, mode_banner_component_ModeBannerComponent, doc_viewer_component_DocViewerComponent, footer_component_FooterComponent, progress_bar_es5_MatProgressBar, top_menu_component_TopMenuComponent, search_results_component_SearchResultsComponent, dt_component_DtComponent, lazy_custom_element_component_LazyCustomElementComponent ],
                pipes: [ common_AsyncPipe ],
                encapsulation: 2
            }), AppComponent;
        }(), SVG_ICONS = new InjectionToken("SvgIcons"), DEFAULT_NS = "$$default", custom_icon_registry_CustomIconRegistry = function(_super) {
            function CustomIconRegistry(http, sanitizer, document, svgIcons) {
                var _a, _this = _super.call(this, http, sanitizer, document) || this;
                return _this.preloadedSvgElements = ((_a = {})[DEFAULT_NS] = {}, _a), _this.loadSvgElements(svgIcons), 
                _this;
            }
            return __extends(CustomIconRegistry, _super), CustomIconRegistry.prototype.getNamedSvgIcon = function(iconName, namespace) {
                var nsIconMap = this.preloadedSvgElements[namespace || DEFAULT_NS], preloadedElement = nsIconMap && nsIconMap[iconName];
                return preloadedElement ? of(preloadedElement.cloneNode(!0)) : _super.prototype.getNamedSvgIcon.call(this, iconName, namespace);
            }, CustomIconRegistry.prototype.loadSvgElements = function(svgIcons) {
                var _this = this, div = document.createElement("DIV");
                svgIcons.forEach(function(icon) {
                    var ns = icon.namespace || DEFAULT_NS, nsIconMap = _this.preloadedSvgElements[ns] || (_this.preloadedSvgElements[ns] = {});
                    div.innerHTML = icon.svgSource, nsIconMap[icon.name] = div.querySelector("svg");
                });
            }, CustomIconRegistry.ngInjectableDef = defineInjectable({
                token: CustomIconRegistry,
                factory: function(t) {
                    return new (t || CustomIconRegistry)(inject(http_HttpClient), inject(DomSanitizer), inject(DOCUMENT, 8), inject(SVG_ICONS));
                },
                providedIn: null
            }), CustomIconRegistry;
        }(icon_es5_MatIconRegistry), reporting_error_handler_ReportingErrorHandler = function(_super) {
            function ReportingErrorHandler(window) {
                var _this = _super.call(this) || this;
                return _this.window = window, _this;
            }
            return __extends(ReportingErrorHandler, _super), ReportingErrorHandler.prototype.handleError = function(error) {
                try {
                    _super.prototype.handleError.call(this, error);
                } catch (e) {
                    this.reportError(e);
                }
                this.reportError(error);
            }, ReportingErrorHandler.prototype.reportError = function(error) {
                "string" == typeof error ? this.window.onerror(error) : this.window.onerror(error.message, void 0, void 0, void 0, error);
            }, ReportingErrorHandler.ngInjectableDef = defineInjectable({
                token: ReportingErrorHandler,
                factory: function(t) {
                    return new (t || ReportingErrorHandler)(inject(WindowToken));
                },
                providedIn: null
            }), ReportingErrorHandler;
        }(ErrorHandler), custom_elements_module_CustomElementsModule = function() {
            function CustomElementsModule() {}
            return CustomElementsModule.ngModuleDef = defineNgModule({
                type: CustomElementsModule
            }), CustomElementsModule.ngInjectorDef = defineInjector({
                factory: function(t) {
                    return new (t || CustomElementsModule)();
                },
                providers: [ elements_loader_ElementsLoader, {
                    provide: NgModuleFactoryLoader,
                    useClass: core_SystemJsNgModuleLoader
                }, {
                    provide: ELEMENT_MODULE_PATHS_TOKEN,
                    useValue: ELEMENT_MODULE_PATHS
                } ]
            }), CustomElementsModule;
        }(), shared_module_SharedModule = function() {
            function SharedModule() {}
            return SharedModule.ngModuleDef = defineNgModule({
                type: SharedModule
            }), SharedModule.ngInjectorDef = defineInjector({
                factory: function(t) {
                    return new (t || SharedModule)();
                },
                imports: [ [ common_CommonModule ] ]
            }), SharedModule;
        }(), sw_updates_module_SwUpdatesModule = function() {
            function SwUpdatesModule() {}
            return SwUpdatesModule.ngModuleDef = defineNgModule({
                type: SwUpdatesModule
            }), SwUpdatesModule.ngInjectorDef = defineInjector({
                factory: function(t) {
                    return new (t || SwUpdatesModule)();
                },
                providers: [ sw_updates_service_SwUpdatesService ]
            }), SwUpdatesModule;
        }(), svgIconProviders = [ {
            provide: SVG_ICONS,
            useValue: {
                name: "close",
                svgSource: '<svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" /><path d="M0 0h24v24H0z" fill="none" /></svg>'
            },
            multi: !0
        }, {
            provide: SVG_ICONS,
            useValue: {
                name: "insert_comment",
                svgSource: '<svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z" /><path d="M0 0h24v24H0z" fill="none" /></svg>'
            },
            multi: !0
        }, {
            provide: SVG_ICONS,
            useValue: {
                name: "keyboard_arrow_right",
                svgSource: '<svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z" /></svg>'
            },
            multi: !0
        }, {
            provide: SVG_ICONS,
            useValue: {
                name: "menu",
                svgSource: '<svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z" /></svg>'
            },
            multi: !0
        }, {
            provide: SVG_ICONS,
            useValue: {
                namespace: "logos",
                name: "github",
                svgSource: '<svg focusable="false" viewBox="0 0 51.8 50.4" xmlns="http://www.w3.org/2000/svg"><path d="M25.9,0.2C11.8,0.2,0.3,11.7,0.3,25.8c0,11.3,7.3,20.9,17.5,24.3c1.3,0.2,1.7-0.6,1.7-1.2c0-0.6,0-2.6,0-4.8c-7.1,1.5-8.6-3-8.6-3c-1.2-3-2.8-3.7-2.8-3.7c-2.3-1.6,0.2-1.6,0.2-1.6c2.6,0.2,3.9,2.6,3.9,2.6c2.3,3.9,6,2.8,7.5,2.1c0.2-1.7,0.9-2.8,1.6-3.4c-5.7-0.6-11.7-2.8-11.7-12.7c0-2.8,1-5.1,2.6-6.9c-0.3-0.7-1.1-3.3,0.3-6.8c0,0,2.1-0.7,7,2.6c2-0.6,4.2-0.9,6.4-0.9c2.2,0,4.4,0.3,6.4,0.9c4.9-3.3,7-2.6,7-2.6c1.4,3.5,0.5,6.1,0.3,6.8c1.6,1.8,2.6,4.1,2.6,6.9c0,9.8-6,12-11.7,12.6c0.9,0.8,1.7,2.4,1.7,4.7c0,3.4,0,6.2,0,7c0,0.7,0.5,1.5,1.8,1.2c10.2-3.4,17.5-13,17.5-24.3C51.5,11.7,40.1,0.2,25.9,0.2z" /></svg>'
            },
            multi: !0
        }, {
            provide: SVG_ICONS,
            useValue: {
                namespace: "logos",
                name: "twitter",
                svgSource: '<svg focusable="false" viewBox="0 0 50 59" xmlns="http://www.w3.org/2000/svg"><path d="M50,9.3c-1.8,0.8-3.8,1.4-5.9,1.6c2.1-1.3,3.7-3.3,4.5-5.7c-2,1.2-4.2,2-6.5,2.5c-1.9-2-4.5-3.2-7.5-3.2c-5.7,0-10.3,4.6-10.3,10.3c0,0.8,0.1,1.6,0.3,2.3C16.1,16.7,8.5,12.6,3.5,6.4c-0.9,1.5-1.4,3.3-1.4,5.2c0,3.6,1.8,6.7,4.6,8.5C5,20,3.4,19.6,2,18.8c0,0,0,0.1,0,0.1c0,5,3.5,9.1,8.2,10.1c-0.9,0.2-1.8,0.4-2.7,0.4c-0.7,0-1.3-0.1-1.9-0.2c1.3,4.1,5.1,7,9.6,7.1c-3.5,2.8-7.9,4.4-12.7,4.4c-0.8,0-1.6,0-2.4-0.1c4.5,2.9,9.9,4.6,15.7,4.6c18.9,0,29.2-15.6,29.2-29.2c0-0.4,0-0.9,0-1.3C46.9,13.2,48.6,11.4,50,9.3z" /></svg>'
            },
            multi: !0
        } ], app_module_AppModule = function() {
            function AppModule() {}
            return AppModule.ngModuleDef = defineNgModule({
                type: AppModule,
                bootstrap: [ app_component_AppComponent ]
            }), AppModule.ngInjectorDef = defineInjector({
                factory: function(t) {
                    return new (t || AppModule)();
                },
                providers: [ deployment_service_Deployment, document_service_DocumentService, {
                    provide: ErrorHandler,
                    useClass: reporting_error_handler_ReportingErrorHandler
                }, ga_service_GaService, logger_service_Logger, common_Location, {
                    provide: LocationStrategy,
                    useClass: common_PathLocationStrategy
                }, location_service_LocationService, {
                    provide: icon_es5_MatIconRegistry,
                    useClass: custom_icon_registry_CustomIconRegistry
                }, navigation_service_NavigationService, scroll_service_ScrollService, scroll_spy_service_ScrollSpyService, search_service_SearchService, svgIconProviders, toc_service_TocService, {
                    provide: CurrentDateToken,
                    useFactory: currentDateProvider
                }, {
                    provide: WindowToken,
                    useFactory: windowProvider
                } ],
                imports: [ [ platform_browser_BrowserModule, animations_BrowserAnimationsModule, custom_elements_module_CustomElementsModule, http_HttpClientModule, button_es5_MatButtonModule, icon_es5_MatIconModule, progress_bar_es5_MatProgressBarModule, sidenav_es5_MatSidenavModule, toolbar_es5_MatToolbarModule, sw_updates_module_SwUpdatesModule, shared_module_SharedModule, service_worker_ServiceWorkerModule.register("/ngsw-worker.js", {
                    enabled: environment.production
                }) ] ]
            }), AppModule;
        }();
        service_worker_ServiceWorkerModule.register("/ngsw-worker.js", {
            enabled: environment.production
        }), environment.production && function() {
            if (_runModeLocked) throw new Error("Cannot enable prod mode after platform setup.");
            _devMode = !1;
        }(), platformBrowser().bootstrapModule(app_module_AppModule);
    }
}, [ [ 0, 0 ] ] ]);
//# sourceMappingURL=main.cdc957555266693e9720.js.map