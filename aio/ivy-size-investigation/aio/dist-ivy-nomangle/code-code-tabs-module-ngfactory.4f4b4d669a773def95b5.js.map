{"version":3,"sources":["webpack:///./node_modules/@angular/material/esm5/card.es5.js.pre-build-optimizer.js","webpack:///./node_modules/@angular/material/esm5/tabs.es5.js.pre-build-optimizer.js","webpack:///./src/app/custom-elements/code/code-tabs.component.ts.pre-build-optimizer.js","webpack:///./src/app/custom-elements/code/code-tabs.component.ts","webpack:///./src/app/custom-elements/code/code-tabs.module.ts","webpack:///./src/app/custom-elements/code/code-tabs.module.ts.pre-build-optimizer.js","webpack:///./src/app/custom-elements/code/code-tabs.module.ngfactory.ts"],"names":["_c12","_c13","_c14","card_es5_MatCard","MatCard","ngComponentDef","core","type","selectors","factory","t","hostBindings","rf","ctx","elIndex","exportAs","ngContentSelectors","consts","vars","template","styles","encapsulation","changeDetection","card_es5_MatCardModule","MatCardModule","ngModuleDef","ngInjectorDef","imports","core_es5","tabs_es5_c0","MatTab_ng_template_0_Template","tabs_es5_c1","tabs_es5_c2","tabs_es5_c3","tabs_es5_c4","tabs_es5_c5","MatTabBody_ng_template_2_Template","tabs_es5_c6","tabs_es5_c7","tabs_es5_c8","tabs_es5_c9","tabs_es5_c10","tabs_es5_c11","tabs_es5_c12","tabs_es5_c13","tabs_es5_c14","tabs_es5_c15","tabs_es5_c16","tabs_es5_c17","tabs_es5_c18","tabs_es5_c19","tabs_es5_c20","tabs_es5_c21","_c22","_c23","_c24","_c25","_c26","_c27","_c28","_c29","_c30","_c31","_c32","_c33","MatTabGroup_div_2_ng_template_2_ng_template_0_Template","MatTabGroup_div_2_ng_template_2_Template","tab_r348","$implicit","templateLabel","MatTabGroup_div_2_ng_template_3_Template","textLabel","_c34","MatTabGroup_div_2_Template","_r356","$event","i_r349","index","ctx_r355","_r344","_handleClick","ctx_r345","selectedIndex","_getTabLabelId","_getTabIndex","_tabs","length","_getTabContentId","ariaLabel","ariaLabelledby","disabled","disableRipple","_c35","_c36","MatTabGroup_mat_tab_body_5_Template","_r360","_removeTabBodyWrapperHeight","_setTabBodyWrapperHeight","tab_r357","i_r358","ctx_r347","content","position","origin","_MAT_INK_BAR_POSITIONER","providedIn","element","left","offsetLeft","width","offsetWidth","tabs_es5_MatInkBar","MatInkBar","_elementRef","_ngZone","_inkBarPositioner","this","prototype","alignToElement","_this","show","requestAnimationFrame","runOutsideAngular","_setStyles","nativeElement","style","visibility","hide","positions","inkBar","ngDirectiveDef","tabs_es5_MatTabContent","MatTabContent","tabs_es5_MatTabLabel","_super","MatTabLabel","apply","arguments","Object","tslib_es6","ÉµMatTabLabel_BaseFactory","features","portal_es5","MatTabBase","tabs_es5_MatTab","MatTab","_viewContainerRef","call","_contentPortal","_stateChanges","Subject","isActive","defineProperty","get","enumerable","configurable","ngOnChanges","changes","hasOwnProperty","next","ngOnDestroy","complete","ngOnInit","_explicitContent","_implicitContent","contentQueries","dirIndex","_t","first","viewQuery","inputs","matTabsAnimations","translateTab","animations","transform","minHeight","tabs_es5_MatTabBodyPortal","MatTabBodyPortal","componentFactoryResolver","viewContainerRef","_host","_centeringSub","Subscription","EMPTY","_leavingSub","_beforeCentering","pipe","startWith","_isCenterPosition","_position","subscribe","isCentering","hasAttached","attach","_content","_afterLeavingCenter","detach","unsubscribe","tabs_es5_MatTabBody","MatTabBody","_dir","changeDetectorRef","_dirChangeSubscription","_onCentering","_onCentered","change","dir","_computePositionAnimationState","markForCheck","set","_positionIndex","_computePositionFromOrigin","_onTranslateTabStarted","e","toState","emit","clientHeight","_onTranslateTabComplete","fromState","_getLayoutDirection","value","bidi_es5","_portalHost","outputs","directives","data","animation","MatTabLabelWrapperBase","tabs_es5_MatTabLabelWrapper","MatTabLabelWrapper","elementRef","focus","getOffsetLeft","getOffsetWidth","MatTabHeaderBase","tabs_es5_MatTabHeader","MatTabHeader","_changeDetectorRef","_viewportRuler","_scrollDistance","_selectedIndexChanged","_destroyed","_showPaginationControls","_disableScrollAfter","_disableScrollBefore","_selectedIndex","selectFocusedIndex","indexFocused","coercion_es5","_keyManager","updateActiveItemIndex","ngAfterContentChecked","_tabLabelCount","_labelWrappers","_updatePagination","_scrollToLabel","_checkScrollingControls","_alignInkBarToSelectedTab","_scrollDistanceChanged","_updateTabScrollPosition","_handleKeydown","event","keyCode","keycodes_es5","setFirstItemActive","preventDefault","setLastItemActive","focusIndex","onKeydown","ngAfterContentInit","dirChange","of","resize","realign","a11y_es5","withHorizontalOrientation","withWrap","updateActiveItem","merge","takeUntil","newFocusIndex","_setTabFocus","_onContentChanges","zoneCallback","run","_checkPaginationEnabled","_isValidIndex","setActiveItem","tab","toArray","tabIndex","containerEl","_tabListContainer","scrollLeft","scrollWidth","scrollDistance","translateX","_tabList","v","Math","max","min","_getMaxScrollDistance","_scrollHeader","scrollDir","labelIndex","selectedLabel","labelBeforePos","labelAfterPos","viewLength","beforeVisiblePos","afterVisiblePos","isEnabled","selectedLabelWrapper","_inkBar","scrolling_es5","observers_es5","nextId","MatTabChangeEvent","MatTabGroupBase","tabs_es5_MatTabGroup","MatTabGroup","_indexToSelect","_tabBodyWrapperHeight","_tabsSubscription","_tabLabelSubscription","_dynamicHeight","headerPosition","selectedIndexChange","focusChange","animationDone","selectedTabChange","_groupId","_backgroundColor","classList","remove","backgroundColor","add","indexToSelect","_clampTabIndex","isFirstRun_1","_createChangeEvent","Promise","resolve","then","forEach","_subscribeToTabLabels","tabs","i","realignInkBar","_tabHeader","_focusChanged","map","tabHeight","wrapper","_tabBodyWrapper","height","offsetHeight","tabHeader","idx","dynamicHeight","color","common","tabs_es5_MatTabsModule","MatTabsModule","code_tabs_component_c0","code_tabs_component_c1","code_tabs_component_c2","code_tabs_component_c3","code_tabs_component_c4","code_tabs_component_c5","code_tabs_component_c6","code_tabs_component_c7","CodeTabsComponent_mat_tab_5_ng_template_1_Template","tab_r90","class","header","CodeTabsComponent_mat_tab_5_Template","language","linenums","path","region","code_tabs_component_c8","code_tabs_component_CodeTabsComponent","CodeTabsComponent","codeExamples","querySelectorAll","push","getTabInfo","ngAfterViewInit","codeComponents","codeComponent","code","tabContent","getAttribute","innerHTML","code_component","code_tabs_module_CodeTabsModule","CodeTabsModule","customElementComponent","code_module","__webpack_require__","d","__webpack_exports__","CodeTabsModuleNgFactory"],"mappings":"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","file":"code-code-tabs-module-ngfactory.4f4b4d669a773def95b5.js","sourcesContent":["import * as Éµngcc0 from '@angular/core';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Component, ViewEncapsulation, ChangeDetectionStrategy, Directive, Input, NgModule } from '@angular/core';\nimport { MatCommonModule } from '@angular/material/core';\nconst _c0 = [1, \"mat-card-content\"];\nconst _c1 = [1, \"mat-card-title\"];\nconst _c2 = [1, \"mat-card-subtitle\"];\nconst _c3 = [1, \"mat-card-actions\"];\nconst _c4 = [\"mat-card-actions-align-end\"];\nconst _c5 = [1, \"mat-card-footer\"];\nconst _c6 = [1, \"mat-card-image\"];\nconst _c7 = [1, \"mat-card-sm-image\"];\nconst _c8 = [1, \"mat-card-md-image\"];\nconst _c9 = [1, \"mat-card-lg-image\"];\nconst _c10 = [1, \"mat-card-xl-image\"];\nconst _c11 = [1, \"mat-card-avatar\"];\nconst _c12 = [1, \"mat-card\"];\nconst _c13 = [[[\"mat-card-footer\"]]];\nconst _c14 = [\"mat-card-footer\"];\nconst _c15 = [1, \"mat-card-header\"];\nconst _c16 = [1, \"mat-card-header-text\"];\nconst _c17 = [[[\"\", \"mat-card-avatar\", \"\"], [\"\", \"matCardAvatar\", \"\"]], [[\"mat-card-title\"], [\"mat-card-subtitle\"], [\"\", \"mat-card-title\", \"\"], [\"\", \"mat-card-subtitle\", \"\"], [\"\", \"matCardTitle\", \"\"], [\"\", \"matCardSubtitle\", \"\"]]];\nconst _c18 = [\"[mat-card-avatar], [matCardAvatar]\", \"mat-card-title, mat-card-subtitle, [mat-card-title], [mat-card-subtitle], [matCardTitle], [matCardSubtitle]\"];\nconst _c19 = [1, \"mat-card-title-group\"];\nconst _c20 = [[[\"mat-card-title\"], [\"mat-card-subtitle\"], [\"\", \"mat-card-title\", \"\"], [\"\", \"mat-card-subtitle\", \"\"], [\"\", \"matCardTitle\", \"\"], [\"\", \"matCardSubtitle\", \"\"]], [[\"img\"]]];\nconst _c21 = [\"mat-card-title, mat-card-subtitle, [mat-card-title], [mat-card-subtitle], [matCardTitle], [matCardSubtitle]\", \"img\"];\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Content of a card, needed as it's used as a selector in the API.\n * \\@docs-private\n */\nvar MatCardContent = /** @class */ (function () {\n    function MatCardContent() {\n    }\nMatCardContent.ngDirectiveDef = Éµngcc0.ÉµdefineDirective({ type: MatCardContent, selectors: [[\"mat-card-content\"]], factory: function MatCardContent_Factory(t) { return new (t || MatCardContent)(); }, hostBindings: function MatCardContent_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµelementHostAttrs(_c0);\r\n    } } });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatCardContent, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: 'mat-card-content',\r\n                host: { 'class': 'mat-card-content' }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardContent;\n}());\n/**\n * Title of a card, needed as it's used as a selector in the API.\n * \\@docs-private\n */\nvar MatCardTitle = /** @class */ (function () {\n    function MatCardTitle() {\n    }\nMatCardTitle.ngDirectiveDef = Éµngcc0.ÉµdefineDirective({ type: MatCardTitle, selectors: [[\"mat-card-title\"], [\"\", \"mat-card-title\", \"\"], [\"\", \"matCardTitle\", \"\"]], factory: function MatCardTitle_Factory(t) { return new (t || MatCardTitle)(); }, hostBindings: function MatCardTitle_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµelementHostAttrs(_c1);\r\n    } } });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatCardTitle, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: \"mat-card-title, [mat-card-title], [matCardTitle]\",\r\n                host: {\r\n                    'class': 'mat-card-title'\r\n                }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardTitle;\n}());\n/**\n * Sub-title of a card, needed as it's used as a selector in the API.\n * \\@docs-private\n */\nvar MatCardSubtitle = /** @class */ (function () {\n    function MatCardSubtitle() {\n    }\nMatCardSubtitle.ngDirectiveDef = Éµngcc0.ÉµdefineDirective({ type: MatCardSubtitle, selectors: [[\"mat-card-subtitle\"], [\"\", \"mat-card-subtitle\", \"\"], [\"\", \"matCardSubtitle\", \"\"]], factory: function MatCardSubtitle_Factory(t) { return new (t || MatCardSubtitle)(); }, hostBindings: function MatCardSubtitle_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµelementHostAttrs(_c2);\r\n    } } });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatCardSubtitle, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: \"mat-card-subtitle, [mat-card-subtitle], [matCardSubtitle]\",\r\n                host: {\r\n                    'class': 'mat-card-subtitle'\r\n                }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardSubtitle;\n}());\n/**\n * Action section of a card, needed as it's used as a selector in the API.\n * \\@docs-private\n */\nvar MatCardActions = /** @class */ (function () {\n    function MatCardActions() {\n        /**\n         * Position of the actions inside the card.\n         */\n        this.align = 'start';\n    }\n    MatCardActions.propDecorators = {\n        align: [{ type: Input }]\n    };\nMatCardActions.ngDirectiveDef = Éµngcc0.ÉµdefineDirective({ type: MatCardActions, selectors: [[\"mat-card-actions\"]], factory: function MatCardActions_Factory(t) { return new (t || MatCardActions)(); }, hostBindings: function MatCardActions_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµelementHostAttrs(_c3);\r\n        Éµngcc0.ÉµelementHostStyling(_c4);\r\n    } if (rf & 2) {\r\n        Éµngcc0.ÉµelementHostClassProp(0, (ctx.align === \"end\"));\r\n        Éµngcc0.ÉµelementHostStylingApply();\r\n    } }, inputs: { align: \"align\" }, exportAs: [\"matCardActions\"] });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatCardActions, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: 'mat-card-actions',\r\n                exportAs: 'matCardActions',\r\n                host: {\r\n                    'class': 'mat-card-actions',\r\n                    '[class.mat-card-actions-align-end]': 'align === \"end\"'\r\n                }\r\n            }]\r\n    }], function () { return []; }, { align: [{\r\n            type: Input\r\n        }] });\n    return MatCardActions;\n}());\n/**\n * Footer of a card, needed as it's used as a selector in the API.\n * \\@docs-private\n */\nvar MatCardFooter = /** @class */ (function () {\n    function MatCardFooter() {\n    }\nMatCardFooter.ngDirectiveDef = Éµngcc0.ÉµdefineDirective({ type: MatCardFooter, selectors: [[\"mat-card-footer\"]], factory: function MatCardFooter_Factory(t) { return new (t || MatCardFooter)(); }, hostBindings: function MatCardFooter_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµelementHostAttrs(_c5);\r\n    } } });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatCardFooter, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: 'mat-card-footer',\r\n                host: { 'class': 'mat-card-footer' }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardFooter;\n}());\n/**\n * Image used in a card, needed to add the mat- CSS styling.\n * \\@docs-private\n */\nvar MatCardImage = /** @class */ (function () {\n    function MatCardImage() {\n    }\nMatCardImage.ngDirectiveDef = Éµngcc0.ÉµdefineDirective({ type: MatCardImage, selectors: [[\"\", \"mat-card-image\", \"\"], [\"\", \"matCardImage\", \"\"]], factory: function MatCardImage_Factory(t) { return new (t || MatCardImage)(); }, hostBindings: function MatCardImage_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµelementHostAttrs(_c6);\r\n    } } });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatCardImage, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[mat-card-image], [matCardImage]',\r\n                host: { 'class': 'mat-card-image' }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardImage;\n}());\n/**\n * Image used in a card, needed to add the mat- CSS styling.\n * \\@docs-private\n */\nvar MatCardSmImage = /** @class */ (function () {\n    function MatCardSmImage() {\n    }\nMatCardSmImage.ngDirectiveDef = Éµngcc0.ÉµdefineDirective({ type: MatCardSmImage, selectors: [[\"\", \"mat-card-sm-image\", \"\"], [\"\", \"matCardImageSmall\", \"\"]], factory: function MatCardSmImage_Factory(t) { return new (t || MatCardSmImage)(); }, hostBindings: function MatCardSmImage_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµelementHostAttrs(_c7);\r\n    } } });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatCardSmImage, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[mat-card-sm-image], [matCardImageSmall]',\r\n                host: { 'class': 'mat-card-sm-image' }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardSmImage;\n}());\n/**\n * Image used in a card, needed to add the mat- CSS styling.\n * \\@docs-private\n */\nvar MatCardMdImage = /** @class */ (function () {\n    function MatCardMdImage() {\n    }\nMatCardMdImage.ngDirectiveDef = Éµngcc0.ÉµdefineDirective({ type: MatCardMdImage, selectors: [[\"\", \"mat-card-md-image\", \"\"], [\"\", \"matCardImageMedium\", \"\"]], factory: function MatCardMdImage_Factory(t) { return new (t || MatCardMdImage)(); }, hostBindings: function MatCardMdImage_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµelementHostAttrs(_c8);\r\n    } } });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatCardMdImage, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[mat-card-md-image], [matCardImageMedium]',\r\n                host: { 'class': 'mat-card-md-image' }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardMdImage;\n}());\n/**\n * Image used in a card, needed to add the mat- CSS styling.\n * \\@docs-private\n */\nvar MatCardLgImage = /** @class */ (function () {\n    function MatCardLgImage() {\n    }\nMatCardLgImage.ngDirectiveDef = Éµngcc0.ÉµdefineDirective({ type: MatCardLgImage, selectors: [[\"\", \"mat-card-lg-image\", \"\"], [\"\", \"matCardImageLarge\", \"\"]], factory: function MatCardLgImage_Factory(t) { return new (t || MatCardLgImage)(); }, hostBindings: function MatCardLgImage_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµelementHostAttrs(_c9);\r\n    } } });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatCardLgImage, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[mat-card-lg-image], [matCardImageLarge]',\r\n                host: { 'class': 'mat-card-lg-image' }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardLgImage;\n}());\n/**\n * Large image used in a card, needed to add the mat- CSS styling.\n * \\@docs-private\n */\nvar MatCardXlImage = /** @class */ (function () {\n    function MatCardXlImage() {\n    }\nMatCardXlImage.ngDirectiveDef = Éµngcc0.ÉµdefineDirective({ type: MatCardXlImage, selectors: [[\"\", \"mat-card-xl-image\", \"\"], [\"\", \"matCardImageXLarge\", \"\"]], factory: function MatCardXlImage_Factory(t) { return new (t || MatCardXlImage)(); }, hostBindings: function MatCardXlImage_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµelementHostAttrs(_c10);\r\n    } } });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatCardXlImage, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[mat-card-xl-image], [matCardImageXLarge]',\r\n                host: { 'class': 'mat-card-xl-image' }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardXlImage;\n}());\n/**\n * Avatar image used in a card, needed to add the mat- CSS styling.\n * \\@docs-private\n */\nvar MatCardAvatar = /** @class */ (function () {\n    function MatCardAvatar() {\n    }\nMatCardAvatar.ngDirectiveDef = Éµngcc0.ÉµdefineDirective({ type: MatCardAvatar, selectors: [[\"\", \"mat-card-avatar\", \"\"], [\"\", \"matCardAvatar\", \"\"]], factory: function MatCardAvatar_Factory(t) { return new (t || MatCardAvatar)(); }, hostBindings: function MatCardAvatar_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµelementHostAttrs(_c11);\r\n    } } });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatCardAvatar, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[mat-card-avatar], [matCardAvatar]',\r\n                host: { 'class': 'mat-card-avatar' }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardAvatar;\n}());\n/**\n * A basic content container component that adds the styles of a Material design card.\n *\n * While this component can be used alone, it also provides a number\n * of preset styles for common card sections, including:\n * - mat-card-title\n * - mat-card-subtitle\n * - mat-card-content\n * - mat-card-actions\n * - mat-card-footer\n */\nvar MatCard = /** @class */ (function () {\n    function MatCard() {\n    }\nMatCard.ngComponentDef = Éµngcc0.ÉµdefineComponent({ type: MatCard, selectors: [[\"mat-card\"]], factory: function MatCard_Factory(t) { return new (t || MatCard)(); }, hostBindings: function MatCard_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµelementHostAttrs(_c12);\r\n    } }, exportAs: [\"matCard\"], ngContentSelectors: _c14, consts: 2, vars: 0, template: function MatCard_Template(rf, ctx) { if (rf & 1) {\r\n        Éµngcc0.ÉµprojectionDef(_c13, _c14);\r\n        Éµngcc0.Éµprojection(0);\r\n        Éµngcc0.Éµprojection(1, 1);\r\n    } }, styles: [\".mat-card{transition:box-shadow 280ms cubic-bezier(.4,0,.2,1);display:block;position:relative;padding:16px;border-radius:4px}.mat-card .mat-divider-horizontal{position:absolute;left:0;width:100%}[dir=rtl] .mat-card .mat-divider-horizontal{left:auto;right:0}.mat-card .mat-divider-horizontal.mat-divider-inset{position:static;margin:0}[dir=rtl] .mat-card .mat-divider-horizontal.mat-divider-inset{margin-right:0}@media screen and (-ms-high-contrast:active){.mat-card{outline:solid 1px}}.mat-card-actions,.mat-card-content,.mat-card-subtitle{display:block;margin-bottom:16px}.mat-card-title{display:block;margin-bottom:8px}.mat-card-actions{margin-left:-8px;margin-right:-8px;padding:8px 0}.mat-card-actions-align-end{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 32px);margin:0 -16px 16px -16px}.mat-card-footer{display:block;margin:0 -16px -16px -16px}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button{margin:0 8px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header .mat-card-title{margin-bottom:12px}.mat-card-header-text{margin:0 16px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;object-fit:cover}.mat-card-title-group{display:flex;justify-content:space-between}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-title-group>.mat-card-xl-image{margin:-8px 0 8px 0}@media (max-width:599px){.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}}.mat-card-content>:first-child,.mat-card>:first-child{margin-top:0}.mat-card-content>:last-child:not(.mat-card-footer),.mat-card>:last-child:not(.mat-card-footer){margin-bottom:0}.mat-card-image:first-child{margin-top:-16px;border-top-left-radius:inherit;border-top-right-radius:inherit}.mat-card>.mat-card-actions:last-child{margin-bottom:-8px;padding-bottom:0}.mat-card-actions .mat-button:first-child,.mat-card-actions .mat-raised-button:first-child{margin-left:0;margin-right:0}.mat-card-title{margin-bottom:8px}.mat-card-subtitle:not(:first-child),.mat-card-title:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}\"], encapsulation: 2, changeDetection: 0 });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatCard, [{\r\n        type: Component,\r\n        args: [{ selector: 'mat-card',\r\n                exportAs: 'matCard',\r\n                template: \"<ng-content></ng-content><ng-content select=\\\"mat-card-footer\\\"></ng-content>\",\r\n                styles: [\".mat-card{transition:box-shadow 280ms cubic-bezier(.4,0,.2,1);display:block;position:relative;padding:16px;border-radius:4px}.mat-card .mat-divider-horizontal{position:absolute;left:0;width:100%}[dir=rtl] .mat-card .mat-divider-horizontal{left:auto;right:0}.mat-card .mat-divider-horizontal.mat-divider-inset{position:static;margin:0}[dir=rtl] .mat-card .mat-divider-horizontal.mat-divider-inset{margin-right:0}@media screen and (-ms-high-contrast:active){.mat-card{outline:solid 1px}}.mat-card-actions,.mat-card-content,.mat-card-subtitle{display:block;margin-bottom:16px}.mat-card-title{display:block;margin-bottom:8px}.mat-card-actions{margin-left:-8px;margin-right:-8px;padding:8px 0}.mat-card-actions-align-end{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 32px);margin:0 -16px 16px -16px}.mat-card-footer{display:block;margin:0 -16px -16px -16px}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button{margin:0 8px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header .mat-card-title{margin-bottom:12px}.mat-card-header-text{margin:0 16px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;object-fit:cover}.mat-card-title-group{display:flex;justify-content:space-between}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-title-group>.mat-card-xl-image{margin:-8px 0 8px 0}@media (max-width:599px){.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}}.mat-card-content>:first-child,.mat-card>:first-child{margin-top:0}.mat-card-content>:last-child:not(.mat-card-footer),.mat-card>:last-child:not(.mat-card-footer){margin-bottom:0}.mat-card-image:first-child{margin-top:-16px;border-top-left-radius:inherit;border-top-right-radius:inherit}.mat-card>.mat-card-actions:last-child{margin-bottom:-8px;padding-bottom:0}.mat-card-actions .mat-button:first-child,.mat-card-actions .mat-raised-button:first-child{margin-left:0;margin-right:0}.mat-card-title{margin-bottom:8px}.mat-card-subtitle:not(:first-child),.mat-card-title:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}\"],\r\n                encapsulation: ViewEncapsulation.None,\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                host: { 'class': 'mat-card' }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCard;\n}());\n/**\n * Component intended to be used within the `<mat-card>` component. It adds styles for a\n * preset header section (i.e. a title, subtitle, and avatar layout).\n * \\@docs-private\n */\nvar MatCardHeader = /** @class */ (function () {\n    function MatCardHeader() {\n    }\nMatCardHeader.ngComponentDef = Éµngcc0.ÉµdefineComponent({ type: MatCardHeader, selectors: [[\"mat-card-header\"]], factory: function MatCardHeader_Factory(t) { return new (t || MatCardHeader)(); }, hostBindings: function MatCardHeader_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµelementHostAttrs(_c15);\r\n    } }, ngContentSelectors: _c18, consts: 4, vars: 0, template: function MatCardHeader_Template(rf, ctx) { if (rf & 1) {\r\n        Éµngcc0.ÉµprojectionDef(_c17, _c18);\r\n        Éµngcc0.Éµprojection(0, 1);\r\n        Éµngcc0.ÉµelementStart(1, \"div\", _c16);\r\n        Éµngcc0.Éµprojection(2, 2);\r\n        Éµngcc0.ÉµelementEnd();\r\n        Éµngcc0.Éµprojection(3);\r\n    } }, encapsulation: 2, changeDetection: 0 });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatCardHeader, [{\r\n        type: Component,\r\n        args: [{ selector: 'mat-card-header',\r\n                template: \"<ng-content select=\\\"[mat-card-avatar], [matCardAvatar]\\\"></ng-content><div class=\\\"mat-card-header-text\\\"><ng-content select=\\\"mat-card-title, mat-card-subtitle, [mat-card-title], [mat-card-subtitle], [matCardTitle], [matCardSubtitle]\\\"></ng-content></div><ng-content></ng-content>\",\r\n                encapsulation: ViewEncapsulation.None,\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                host: { 'class': 'mat-card-header' }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardHeader;\n}());\n/**\n * Component intended to be used within the `<mat-card>` component. It adds styles for a preset\n * layout that groups an image with a title section.\n * \\@docs-private\n */\nvar MatCardTitleGroup = /** @class */ (function () {\n    function MatCardTitleGroup() {\n    }\nMatCardTitleGroup.ngComponentDef = Éµngcc0.ÉµdefineComponent({ type: MatCardTitleGroup, selectors: [[\"mat-card-title-group\"]], factory: function MatCardTitleGroup_Factory(t) { return new (t || MatCardTitleGroup)(); }, hostBindings: function MatCardTitleGroup_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµelementHostAttrs(_c19);\r\n    } }, ngContentSelectors: _c21, consts: 4, vars: 0, template: function MatCardTitleGroup_Template(rf, ctx) { if (rf & 1) {\r\n        Éµngcc0.ÉµprojectionDef(_c20, _c21);\r\n        Éµngcc0.ÉµelementStart(0, \"div\");\r\n        Éµngcc0.Éµprojection(1, 1);\r\n        Éµngcc0.ÉµelementEnd();\r\n        Éµngcc0.Éµprojection(2, 2);\r\n        Éµngcc0.Éµprojection(3);\r\n    } }, encapsulation: 2, changeDetection: 0 });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatCardTitleGroup, [{\r\n        type: Component,\r\n        args: [{ selector: 'mat-card-title-group',\r\n                template: \"<div><ng-content select=\\\"mat-card-title, mat-card-subtitle, [mat-card-title], [mat-card-subtitle], [matCardTitle], [matCardSubtitle]\\\"></ng-content></div><ng-content select=\\\"img\\\"></ng-content><ng-content></ng-content>\",\r\n                encapsulation: ViewEncapsulation.None,\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                host: { 'class': 'mat-card-title-group' }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardTitleGroup;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MatCardModule = /** @class */ (function () {\n    function MatCardModule() {\n    }\nMatCardModule.ngModuleDef = Éµngcc0.ÉµdefineNgModule({ type: MatCardModule });\n/*@__PURE__*/ Éµngcc0.ÉµsetNgModuleScope(MatCardModule, { declarations: function () { return [MatCard,\r\n        MatCardHeader,\r\n        MatCardTitleGroup,\r\n        MatCardContent,\r\n        MatCardTitle,\r\n        MatCardSubtitle,\r\n        MatCardActions,\r\n        MatCardFooter,\r\n        MatCardSmImage,\r\n        MatCardMdImage,\r\n        MatCardLgImage,\r\n        MatCardImage,\r\n        MatCardXlImage,\r\n        MatCardAvatar]; }, imports: function () { return [MatCommonModule]; }, exports: function () { return [MatCard,\r\n        MatCardHeader,\r\n        MatCardTitleGroup,\r\n        MatCardContent,\r\n        MatCardTitle,\r\n        MatCardSubtitle,\r\n        MatCardActions,\r\n        MatCardFooter,\r\n        MatCardSmImage,\r\n        MatCardMdImage,\r\n        MatCardLgImage,\r\n        MatCardImage,\r\n        MatCardXlImage,\r\n        MatCardAvatar,\r\n        MatCommonModule]; } });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatCardModule, [{\r\n        type: NgModule,\r\n        args: [{\r\n                imports: [MatCommonModule],\r\n                exports: [\r\n                    MatCard,\r\n                    MatCardHeader,\r\n                    MatCardTitleGroup,\r\n                    MatCardContent,\r\n                    MatCardTitle,\r\n                    MatCardSubtitle,\r\n                    MatCardActions,\r\n                    MatCardFooter,\r\n                    MatCardSmImage,\r\n                    MatCardMdImage,\r\n                    MatCardLgImage,\r\n                    MatCardImage,\r\n                    MatCardXlImage,\r\n                    MatCardAvatar,\r\n                    MatCommonModule,\r\n                ],\r\n                declarations: [\r\n                    MatCard, MatCardHeader, MatCardTitleGroup, MatCardContent, MatCardTitle, MatCardSubtitle,\r\n                    MatCardActions, MatCardFooter, MatCardSmImage, MatCardMdImage, MatCardLgImage, MatCardImage,\r\n                    MatCardXlImage, MatCardAvatar,\r\n                ]\r\n            }]\r\n    }], function () { return []; }, null);\nMatCardModule.ngInjectorDef = Éµngcc0.defineInjector({ factory: function MatCardModule_Factory(t) { return new (t || MatCardModule)(); }, imports: [[MatCommonModule],\r\n        MatCommonModule] });\n    return MatCardModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\nexport { MatCardContent, MatCardTitle, MatCardSubtitle, MatCardActions, MatCardFooter, MatCardImage, MatCardSmImage, MatCardMdImage, MatCardLgImage, MatCardXlImage, MatCardAvatar, MatCard, MatCardHeader, MatCardTitleGroup, MatCardModule };\n\n//# sourceMappingURL=card.es5.js.map","import * as Éµngcc0 from '@angular/core';\nimport * as Éµngcc1 from '@angular/material/core';\nimport * as Éµngcc2 from '@angular/cdk/observers';\nimport * as Éµngcc3 from '@angular/cdk/a11y';\nimport * as Éµngcc4 from '@angular/common';\nimport * as Éµngcc5 from '@angular/cdk/portal';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, ElementRef, Inject, InjectionToken, NgZone, TemplateRef, ChangeDetectionStrategy, Component, ContentChild, Input, ViewChild, ViewContainerRef, ViewEncapsulation, ChangeDetectorRef, Output, EventEmitter, Optional, ComponentFactoryResolver, forwardRef, ContentChildren, Attribute, NgModule } from '@angular/core';\nimport { __extends } from 'tslib';\nimport { CdkPortal, TemplatePortal, CdkPortalOutlet, PortalHostDirective, PortalModule } from '@angular/cdk/portal';\nimport { mixinDisabled, mixinDisableRipple, mixinColor, MAT_RIPPLE_GLOBAL_OPTIONS, mixinTabIndex, RippleRenderer, MatCommonModule, MatRippleModule } from '@angular/material/core';\nimport { Subject, Subscription, merge, of } from 'rxjs';\nimport { animate, state, style, transition, trigger } from '@angular/animations';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { startWith, takeUntil } from 'rxjs/operators';\nimport { coerceNumberProperty, coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { END, ENTER, HOME, SPACE } from '@angular/cdk/keycodes';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\nimport { FocusKeyManager, FocusMonitor, A11yModule } from '@angular/cdk/a11y';\nimport { Platform } from '@angular/cdk/platform';\nimport { ObserversModule } from '@angular/cdk/observers';\nimport { CommonModule } from '@angular/common';\nconst _c0 = [1, \"mat-ink-bar\"];\nfunction MatTab_ng_template_0_Template(rf, ctx) { if (rf & 1) {\r\n    Éµngcc0.Éµprojection(0);\r\n} }\nconst _c1 = [];\nconst _c2 = [1, \"mat-tab-body\"];\nconst _c3 = [1, \"mat-tab-body-content\", 3];\nconst _c4 = [\"content\", \"\"];\nconst _c5 = [\"matTabBodyHost\", \"\"];\nfunction MatTabBody_ng_template_2_Template(rf, ctx) { }\nconst _c6 = [\"mat-tab-disabled\"];\nconst _c7 = [\"tabListContainer\"];\nconst _c8 = [\"tabList\"];\nconst _c9 = [1, \"mat-tab-header\"];\nconst _c10 = [\"mat-tab-header-pagination-controls-enabled\", \"mat-tab-header-rtl\"];\nconst _c11 = [\"aria-hidden\", \"true\", \"mat-ripple\", \"\", 1, \"mat-tab-header-pagination\", \"mat-tab-header-pagination-before\", \"mat-elevation-z4\", 3, \"matRippleDisabled\", \"click\"];\nconst _c12 = [1, \"mat-tab-header-pagination-chevron\"];\nconst _c13 = [1, \"mat-tab-label-container\", 3, \"keydown\"];\nconst _c14 = [\"tabListContainer\", \"\"];\nconst _c15 = [\"role\", \"tablist\", 1, \"mat-tab-list\", 3, \"cdkObserveContent\"];\nconst _c16 = [\"tabList\", \"\"];\nconst _c17 = [1, \"mat-tab-labels\"];\nconst _c18 = [\"aria-hidden\", \"true\", \"mat-ripple\", \"\", 1, \"mat-tab-header-pagination\", \"mat-tab-header-pagination-after\", \"mat-elevation-z4\", 3, \"matRippleDisabled\", \"click\"];\nconst _c19 = [\"mat-tab-header-pagination-disabled\"];\nconst _c20 = [\"tabBodyWrapper\"];\nconst _c21 = [\"tabHeader\"];\nconst _c22 = [1, \"mat-tab-group\"];\nconst _c23 = [\"mat-tab-group-dynamic-height\", \"mat-tab-group-inverted-header\"];\nconst _c24 = [3, \"selectedIndex\", \"disableRipple\", \"indexFocused\", \"selectFocusedIndex\"];\nconst _c25 = [\"tabHeader\", \"\"];\nconst _c26 = [\"class\", \"mat-tab-label\", \"role\", \"tab\", \"matTabLabelWrapper\", \"\", \"mat-ripple\", \"\", \"cdkMonitorElementFocus\", \"\", 3, \"id\", \"tabIndex\", \"aria-posinset\", \"aria-setsize\", \"aria-controls\", \"aria-selected\", \"aria-label\", \"aria-labelledby\", \"mat-tab-label-active\", \"disabled\", \"matRippleDisabled\", \"click\", 4, \"ngFor\", \"ngForOf\"];\nconst _c27 = [1, \"mat-tab-body-wrapper\"];\nconst _c28 = [\"tabBodyWrapper\", \"\"];\nconst _c29 = [\"role\", \"tabpanel\", 3, \"id\", \"aria-labelledby\", \"mat-tab-body-active\", \"content\", \"position\", \"origin\", \"_onCentered\", \"_onCentering\", 4, \"ngFor\", \"ngForOf\"];\nconst _c30 = [\"role\", \"tab\", \"matTabLabelWrapper\", \"\", \"mat-ripple\", \"\", \"cdkMonitorElementFocus\", \"\", 1, \"mat-tab-label\", 3, \"id\", \"tabIndex\", \"aria-posinset\", \"aria-setsize\", \"aria-controls\", \"aria-selected\", \"aria-label\", \"aria-labelledby\", \"disabled\", \"matRippleDisabled\", \"click\"];\nconst _c31 = [1, \"mat-tab-label-content\"];\nconst _c32 = [3, \"ngIf\"];\nconst _c33 = [3, \"cdkPortalOutlet\"];\nfunction MatTabGroup_div_2_ng_template_2_ng_template_0_Template(rf, ctx) { }\nfunction MatTabGroup_div_2_ng_template_2_Template(rf, ctx) { if (rf & 1) {\r\n    Éµngcc0.Éµtemplate(0, MatTabGroup_div_2_ng_template_2_ng_template_0_Template, 0, 0, \"ng-template\", _c33);\r\n} if (rf & 2) {\r\n    const tab_r348 = Éµngcc0.ÉµnextContext().$implicit;\r\n    Éµngcc0.Éµselect(0);\r\n    Éµngcc0.ÉµelementProperty(0, \"cdkPortalOutlet\", Éµngcc0.Éµbind(tab_r348.templateLabel));\r\n} }\nfunction MatTabGroup_div_2_ng_template_3_Template(rf, ctx) { if (rf & 1) {\r\n    Éµngcc0.Éµtext(0);\r\n} if (rf & 2) {\r\n    const tab_r348 = Éµngcc0.ÉµnextContext().$implicit;\r\n    Éµngcc0.Éµselect(0);\r\n    Éµngcc0.ÉµtextBinding(0, Éµngcc0.Éµinterpolation1(\"\", tab_r348.textLabel, \"\"));\r\n} }\nconst _c34 = [\"mat-tab-label-active\"];\nfunction MatTabGroup_div_2_Template(rf, ctx) { if (rf & 1) {\r\n    const _r356 = Éµngcc0.ÉµgetCurrentView();\r\n    Éµngcc0.ÉµelementStart(0, \"div\", _c30);\r\n    Éµngcc0.ÉµelementStyling(_c34);\r\n    Éµngcc0.Éµlistener(\"click\", function MatTabGroup_div_2_Template_div_click_0_listener($event) { Éµngcc0.ÉµrestoreView(_r356); const tab_r348 = ctx.$implicit; const i_r349 = ctx.index; const ctx_r355 = Éµngcc0.ÉµnextContext(); const _r344 = Éµngcc0.Éµreference(1); return ctx_r355._handleClick(tab_r348, _r344, i_r349); });\r\n    Éµngcc0.ÉµelementStart(1, \"div\", _c31);\r\n    Éµngcc0.Éµtemplate(2, MatTabGroup_div_2_ng_template_2_Template, 1, 1, \"ng-template\", _c32);\r\n    Éµngcc0.Éµtemplate(3, MatTabGroup_div_2_ng_template_3_Template, 1, 1, \"ng-template\", _c32);\r\n    Éµngcc0.ÉµelementEnd();\r\n    Éµngcc0.ÉµelementEnd();\r\n} if (rf & 2) {\r\n    const tab_r348 = ctx.$implicit;\r\n    const i_r349 = ctx.index;\r\n    const ctx_r345 = Éµngcc0.ÉµnextContext();\r\n    Éµngcc0.ÉµelementClassProp(0, 0, (ctx_r345.selectedIndex == i_r349));\r\n    Éµngcc0.ÉµelementStylingApply(0);\r\n    Éµngcc0.Éµselect(0);\r\n    Éµngcc0.ÉµelementProperty(0, \"id\", Éµngcc0.Éµbind(ctx_r345._getTabLabelId(i_r349)));\r\n    Éµngcc0.ÉµelementAttribute(0, \"tabIndex\", Éµngcc0.Éµbind(ctx_r345._getTabIndex(tab_r348, i_r349)));\r\n    Éµngcc0.ÉµelementAttribute(0, \"aria-posinset\", Éµngcc0.Éµbind((i_r349 + 1)));\r\n    Éµngcc0.ÉµelementAttribute(0, \"aria-setsize\", Éµngcc0.Éµbind(ctx_r345._tabs.length));\r\n    Éµngcc0.ÉµelementAttribute(0, \"aria-controls\", Éµngcc0.Éµbind(ctx_r345._getTabContentId(i_r349)));\r\n    Éµngcc0.ÉµelementAttribute(0, \"aria-selected\", Éµngcc0.Éµbind((ctx_r345.selectedIndex == i_r349)));\r\n    Éµngcc0.ÉµelementAttribute(0, \"aria-label\", Éµngcc0.Éµbind((tab_r348.ariaLabel || null)));\r\n    Éµngcc0.ÉµelementAttribute(0, \"aria-labelledby\", Éµngcc0.Éµbind(((!tab_r348.ariaLabel && tab_r348.ariaLabelledby) ? tab_r348.ariaLabelledby : null)));\r\n    Éµngcc0.ÉµelementProperty(0, \"disabled\", Éµngcc0.Éµbind(tab_r348.disabled));\r\n    Éµngcc0.ÉµelementProperty(0, \"matRippleDisabled\", Éµngcc0.Éµbind((tab_r348.disabled || ctx_r345.disableRipple)));\r\n    Éµngcc0.Éµselect(2);\r\n    Éµngcc0.ÉµelementProperty(2, \"ngIf\", Éµngcc0.Éµbind(tab_r348.templateLabel));\r\n    Éµngcc0.Éµselect(3);\r\n    Éµngcc0.ÉµelementProperty(3, \"ngIf\", Éµngcc0.Éµbind(!tab_r348.templateLabel));\r\n} }\nconst _c35 = [\"role\", \"tabpanel\", 3, \"id\", \"aria-labelledby\", \"content\", \"position\", \"origin\", \"_onCentered\", \"_onCentering\"];\nconst _c36 = [\"mat-tab-body-active\"];\nfunction MatTabGroup_mat_tab_body_5_Template(rf, ctx) { if (rf & 1) {\r\n    const _r360 = Éµngcc0.ÉµgetCurrentView();\r\n    Éµngcc0.ÉµelementStart(0, \"mat-tab-body\", _c35);\r\n    Éµngcc0.ÉµelementStyling(_c36);\r\n    Éµngcc0.Éµlistener(\"_onCentered\", function MatTabGroup_mat_tab_body_5_Template_mat_tab_body__onCentered_0_listener($event) { Éµngcc0.ÉµrestoreView(_r360); const ctx_r359 = Éµngcc0.ÉµnextContext(); return ctx_r359._removeTabBodyWrapperHeight(); });\r\n    Éµngcc0.Éµlistener(\"_onCentering\", function MatTabGroup_mat_tab_body_5_Template_mat_tab_body__onCentering_0_listener($event) { Éµngcc0.ÉµrestoreView(_r360); const ctx_r361 = Éµngcc0.ÉµnextContext(); return ctx_r361._setTabBodyWrapperHeight($event); });\r\n    Éµngcc0.ÉµelementEnd();\r\n} if (rf & 2) {\r\n    const tab_r357 = ctx.$implicit;\r\n    const i_r358 = ctx.index;\r\n    const ctx_r347 = Éµngcc0.ÉµnextContext();\r\n    Éµngcc0.ÉµelementClassProp(0, 0, (ctx_r347.selectedIndex == i_r358));\r\n    Éµngcc0.ÉµelementStylingApply(0);\r\n    Éµngcc0.Éµselect(0);\r\n    Éµngcc0.ÉµelementProperty(0, \"id\", Éµngcc0.Éµbind(ctx_r347._getTabContentId(i_r358)));\r\n    Éµngcc0.ÉµelementAttribute(0, \"aria-labelledby\", Éµngcc0.Éµbind(ctx_r347._getTabLabelId(i_r358)));\r\n    Éµngcc0.ÉµelementProperty(0, \"content\", Éµngcc0.Éµbind(tab_r357.content));\r\n    Éµngcc0.ÉµelementProperty(0, \"position\", Éµngcc0.Éµbind(tab_r357.position));\r\n    Éµngcc0.ÉµelementProperty(0, \"origin\", Éµngcc0.Éµbind(tab_r357.origin));\r\n} }\nconst _c37 = [1, \"mat-tab-nav-bar\"];\nconst _c38 = [\"mat-tab-nav-bar\", \"\"];\nconst _c39 = [1, \"mat-tab-links\", 3, \"cdkObserveContent\"];\nconst _c40 = [1, \"mat-tab-link\"];\nconst _c41 = [\"mat-tab-disabled\", \"mat-tab-label-active\"];\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * Injection token for the MatInkBar's Positioner.\n  @type {?} */\nvar _MAT_INK_BAR_POSITIONER = new InjectionToken('MatInkBarPositioner', {\n    providedIn: 'root',\n    factory: _MAT_INK_BAR_POSITIONER_FACTORY\n});\n/**\n * The default positioner function for the MatInkBar.\n * \\@docs-private\n * @return {?}\n */\nfunction _MAT_INK_BAR_POSITIONER_FACTORY() {\n    /** @type {?} */\n    var method = function (element) { return ({\n        left: element ? (element.offsetLeft || 0) + 'px' : '0',\n        width: element ? (element.offsetWidth || 0) + 'px' : '0',\n    }); };\n    return method;\n}\n/**\n * The ink-bar is used to display and animate the line underneath the current active tab label.\n * \\@docs-private\n */\nvar MatInkBar = /** @class */ (function () {\n    function MatInkBar(_elementRef, _ngZone, _inkBarPositioner) {\n        this._elementRef = _elementRef;\n        this._ngZone = _ngZone;\n        this._inkBarPositioner = _inkBarPositioner;\n    }\n    /**\n     * Calculates the styles from the provided element in order to align the ink-bar to that element.\n     * Shows the ink bar if previously set as hidden.\n     * @param element\n     */\n    /**\n     * Calculates the styles from the provided element in order to align the ink-bar to that element.\n     * Shows the ink bar if previously set as hidden.\n     * @param {?} element\n     * @return {?}\n     */\n    MatInkBar.prototype.alignToElement = /**\n     * Calculates the styles from the provided element in order to align the ink-bar to that element.\n     * Shows the ink bar if previously set as hidden.\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        var _this = this;\n        this.show();\n        if (typeof requestAnimationFrame !== 'undefined') {\n            this._ngZone.runOutsideAngular(function () {\n                requestAnimationFrame(function () { return _this._setStyles(element); });\n            });\n        }\n        else {\n            this._setStyles(element);\n        }\n    };\n    /** Shows the ink bar. */\n    /**\n     * Shows the ink bar.\n     * @return {?}\n     */\n    MatInkBar.prototype.show = /**\n     * Shows the ink bar.\n     * @return {?}\n     */\n    function () {\n        this._elementRef.nativeElement.style.visibility = 'visible';\n    };\n    /** Hides the ink bar. */\n    /**\n     * Hides the ink bar.\n     * @return {?}\n     */\n    MatInkBar.prototype.hide = /**\n     * Hides the ink bar.\n     * @return {?}\n     */\n    function () {\n        this._elementRef.nativeElement.style.visibility = 'hidden';\n    };\n    /**\n     * Sets the proper styles to the ink bar element.\n     * @param {?} element\n     * @return {?}\n     */\n    MatInkBar.prototype._setStyles = /**\n     * Sets the proper styles to the ink bar element.\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        /** @type {?} */\n        var positions = this._inkBarPositioner(element);\n        /** @type {?} */\n        var inkBar = this._elementRef.nativeElement;\n        inkBar.style.left = positions.left;\n        inkBar.style.width = positions.width;\n    };\n    /** @nocollapse */\n    MatInkBar.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: NgZone },\n        { type: undefined, decorators: [{ type: Inject, args: [_MAT_INK_BAR_POSITIONER,] }] }\n    ]; };\nMatInkBar.ngDirectiveDef = Éµngcc0.ÉµdefineDirective({ type: MatInkBar, selectors: [[\"mat-ink-bar\"]], factory: function MatInkBar_Factory(t) { return new (t || MatInkBar)(Éµngcc0.ÉµdirectiveInject(ElementRef), Éµngcc0.ÉµdirectiveInject(NgZone), Éµngcc0.ÉµdirectiveInject(_MAT_INK_BAR_POSITIONER)); }, hostBindings: function MatInkBar_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµelementHostAttrs(_c0);\r\n    } } });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatInkBar, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: 'mat-ink-bar',\r\n                host: {\r\n                    'class': 'mat-ink-bar'\r\n                }\r\n            }]\r\n    }], function () { return [{ type: ElementRef }, { type: NgZone }, { type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [_MAT_INK_BAR_POSITIONER]\r\n            }] }]; }, { _elementRef: [], _ngZone: [], _inkBarPositioner: [], alignToElement: [], show: [], hide: [], _setStyles: [] });\n    return MatInkBar;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Decorates the `ng-template` tags and reads out the template from it.\n */\nvar MatTabContent = /** @class */ (function () {\n    function MatTabContent(template) {\n        this.template = template;\n    }\n    /** @nocollapse */\n    MatTabContent.ctorParameters = function () { return [\n        { type: TemplateRef }\n    ]; };\nMatTabContent.ngDirectiveDef = Éµngcc0.ÉµdefineDirective({ type: MatTabContent, selectors: [[\"\", \"matTabContent\", \"\"]], factory: function MatTabContent_Factory(t) { return new (t || MatTabContent)(Éµngcc0.ÉµdirectiveInject(TemplateRef)); } });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatTabContent, [{\r\n        type: Directive,\r\n        args: [{ selector: '[matTabContent]' }]\r\n    }], function () { return [{ type: TemplateRef }]; }, { template: [] });\n    return MatTabContent;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar _CdkPortal = CdkPortal;\n/**\n * Used to flag tab labels for use with the portal directive\n */\nvar MatTabLabel = /** @class */ (function (_super) {\n    __extends(MatTabLabel, _super);\n    function MatTabLabel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\nMatTabLabel.ngDirectiveDef = Éµngcc0.ÉµdefineDirective({ type: MatTabLabel, selectors: [[\"\", \"mat-tab-label\", \"\"], [\"\", \"matTabLabel\", \"\"]], factory: function MatTabLabel_Factory(t) { return ÉµMatTabLabel_BaseFactory((t || MatTabLabel)); }, features: [Éµngcc0.ÉµInheritDefinitionFeature] });\nconst ÉµMatTabLabel_BaseFactory = Éµngcc0.ÉµgetInheritedFactory(MatTabLabel);\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatTabLabel, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[mat-tab-label], [matTabLabel]'\r\n            }]\r\n    }], null, null);\n    return MatTabLabel;\n}(_CdkPortal));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * \\@docs-private\n */\nvar  /**\n * \\@docs-private\n */\nMatTabBase = /** @class */ (function () {\n    function MatTabBase() {\n    }\n    return MatTabBase;\n}());\n/** @type {?} */\nvar _MatTabMixinBase = mixinDisabled(MatTabBase);\nvar MatTab = /** @class */ (function (_super) {\n    __extends(MatTab, _super);\n    function MatTab(_viewContainerRef) {\n        var _this = _super.call(this) || this;\n        _this._viewContainerRef = _viewContainerRef;\n        /**\n         * Plain text label for the tab, used when there is no template label.\n         */\n        _this.textLabel = '';\n        /**\n         * Portal that will be the hosted content of the tab\n         */\n        _this._contentPortal = null;\n        /**\n         * Emits whenever the internal state of the tab changes.\n         */\n        _this._stateChanges = new Subject();\n        /**\n         * The relatively indexed position where 0 represents the center, negative is left, and positive\n         * represents the right.\n         */\n        _this.position = null;\n        /**\n         * The initial relatively index origin of the tab if it was created and selected after there\n         * was already a selected tab. Provides context of what position the tab should originate from.\n         */\n        _this.origin = null;\n        /**\n         * Whether the tab is currently active.\n         */\n        _this.isActive = false;\n        return _this;\n    }\n    Object.defineProperty(MatTab.prototype, \"content\", {\n        /** @docs-private */\n        get: /**\n         * \\@docs-private\n         * @return {?}\n         */\n        function () {\n            return this._contentPortal;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    MatTab.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) {\n        if (changes.hasOwnProperty('textLabel') || changes.hasOwnProperty('disabled')) {\n            this._stateChanges.next();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatTab.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._stateChanges.complete();\n    };\n    /**\n     * @return {?}\n     */\n    MatTab.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        this._contentPortal = new TemplatePortal(this._explicitContent || this._implicitContent, this._viewContainerRef);\n    };\n    /** @nocollapse */\n    MatTab.ctorParameters = function () { return [\n        { type: ViewContainerRef }\n    ]; };\n    MatTab.propDecorators = {\n        templateLabel: [{ type: ContentChild, args: [MatTabLabel,] }],\n        _explicitContent: [{ type: ContentChild, args: [MatTabContent, { read: TemplateRef },] }],\n        _implicitContent: [{ type: ViewChild, args: [TemplateRef,] }],\n        textLabel: [{ type: Input, args: ['label',] }],\n        ariaLabel: [{ type: Input, args: ['aria-label',] }],\n        ariaLabelledby: [{ type: Input, args: ['aria-labelledby',] }]\n    };\nMatTab.ngComponentDef = Éµngcc0.ÉµdefineComponent({ type: MatTab, selectors: [[\"mat-tab\"]], factory: function MatTab_Factory(t) { return new (t || MatTab)(Éµngcc0.ÉµdirectiveInject(ViewContainerRef)); }, contentQueries: function MatTab_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµcontentQuery(dirIndex, MatTabLabel, true, null);\r\n        Éµngcc0.ÉµcontentQuery(dirIndex, MatTabContent, true, TemplateRef);\r\n    } if (rf & 2) {\r\n        var _t;\r\n        (Éµngcc0.ÉµqueryRefresh(_t = Éµngcc0.ÉµloadContentQuery()) && (ctx.templateLabel = _t.first));\r\n        (Éµngcc0.ÉµqueryRefresh(_t = Éµngcc0.ÉµloadContentQuery()) && (ctx._explicitContent = _t.first));\r\n    } }, viewQuery: function MatTab_Query(rf, ctx) { if (rf & 1) {\r\n        Éµngcc0.ÉµviewQuery(TemplateRef, true, null);\r\n    } if (rf & 2) {\r\n        var _t;\r\n        (Éµngcc0.ÉµqueryRefresh(_t = Éµngcc0.ÉµloadViewQuery()) && (ctx._implicitContent = _t.first));\r\n    } }, inputs: { disabled: \"disabled\", textLabel: [\"label\", \"textLabel\"], ariaLabel: [\"aria-label\", \"ariaLabel\"], ariaLabelledby: [\"aria-labelledby\", \"ariaLabelledby\"] }, exportAs: [\"matTab\"], features: [Éµngcc0.ÉµInheritDefinitionFeature, Éµngcc0.ÉµNgOnChangesFeature()], ngContentSelectors: _c1, consts: 1, vars: 0, template: function MatTab_Template(rf, ctx) { if (rf & 1) {\r\n        Éµngcc0.ÉµprojectionDef();\r\n        Éµngcc0.Éµtemplate(0, MatTab_ng_template_0_Template, 1, 0, \"ng-template\");\r\n    } }, encapsulation: 2, changeDetection: 0 });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatTab, [{\r\n        type: Component,\r\n        args: [{ selector: 'mat-tab',\r\n                template: \"<ng-template><ng-content></ng-content></ng-template>\",\r\n                inputs: ['disabled'],\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                encapsulation: ViewEncapsulation.None,\r\n                exportAs: 'matTab'\r\n            }]\r\n    }], function () { return [{ type: ViewContainerRef }]; }, { content: [], ngOnChanges: [], ngOnDestroy: [], ngOnInit: [], _contentPortal: [], templateLabel: [{\r\n            type: ContentChild,\r\n            args: [MatTabLabel]\r\n        }], _explicitContent: [{\r\n            type: ContentChild,\r\n            args: [MatTabContent, { read: TemplateRef }]\r\n        }], _implicitContent: [{\r\n            type: ViewChild,\r\n            args: [TemplateRef]\r\n        }], textLabel: [{\r\n            type: Input,\r\n            args: ['label']\r\n        }], ariaLabel: [{\r\n            type: Input,\r\n            args: ['aria-label']\r\n        }], ariaLabelledby: [{\r\n            type: Input,\r\n            args: ['aria-labelledby']\r\n        }] });\n    return MatTab;\n}(_MatTabMixinBase));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * Animations used by the Material tabs.\n * \\@docs-private\n  @type {?} */\nvar matTabsAnimations = {\n    /** Animation translates a tab along the X axis. */\n    translateTab: trigger('translateTab', [\n        // Note: transitions to `none` instead of 0, because some browsers might blur the content.\n        state('center, void, left-origin-center, right-origin-center', style({ transform: 'none' })),\n        // If the tab is either on the left or right, we additionally add a `min-height` of 1px\n        // in order to ensure that the element has a height before its state changes. This is\n        // necessary because Chrome does seem to skip the transition in RTL mode if the element does\n        // not have a static height and is not rendered. See related issue: #9465\n        state('left', style({ transform: 'translate3d(-100%, 0, 0)', minHeight: '1px' })),\n        state('right', style({ transform: 'translate3d(100%, 0, 0)', minHeight: '1px' })),\n        transition('* => left, * => right, left => center, right => center', animate('500ms cubic-bezier(0.35, 0, 0.25, 1)')),\n        transition('void => left-origin-center', [\n            style({ transform: 'translate3d(-100%, 0, 0)' }),\n            animate('500ms cubic-bezier(0.35, 0, 0.25, 1)')\n        ]),\n        transition('void => right-origin-center', [\n            style({ transform: 'translate3d(100%, 0, 0)' }),\n            animate('500ms cubic-bezier(0.35, 0, 0.25, 1)')\n        ])\n    ])\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * The portal host directive for the contents of the tab.\n * \\@docs-private\n */\nvar MatTabBodyPortal = /** @class */ (function (_super) {\n    __extends(MatTabBodyPortal, _super);\n    function MatTabBodyPortal(componentFactoryResolver, viewContainerRef, _host) {\n        var _this = _super.call(this, componentFactoryResolver, viewContainerRef) || this;\n        _this._host = _host;\n        /**\n         * Subscription to events for when the tab body begins centering.\n         */\n        _this._centeringSub = Subscription.EMPTY;\n        /**\n         * Subscription to events for when the tab body finishes leaving from center position.\n         */\n        _this._leavingSub = Subscription.EMPTY;\n        return _this;\n    }\n    /** Set initial visibility or set up subscription for changing visibility. */\n    /**\n     * Set initial visibility or set up subscription for changing visibility.\n     * @return {?}\n     */\n    MatTabBodyPortal.prototype.ngOnInit = /**\n     * Set initial visibility or set up subscription for changing visibility.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        _super.prototype.ngOnInit.call(this);\n        this._centeringSub = this._host._beforeCentering\n            .pipe(startWith(this._host._isCenterPosition(this._host._position)))\n            .subscribe(function (isCentering) {\n            if (isCentering && !_this.hasAttached()) {\n                _this.attach(_this._host._content);\n            }\n        });\n        this._leavingSub = this._host._afterLeavingCenter.subscribe(function () {\n            _this.detach();\n        });\n    };\n    /** Clean up centering subscription. */\n    /**\n     * Clean up centering subscription.\n     * @return {?}\n     */\n    MatTabBodyPortal.prototype.ngOnDestroy = /**\n     * Clean up centering subscription.\n     * @return {?}\n     */\n    function () {\n        _super.prototype.ngOnDestroy.call(this);\n        this._centeringSub.unsubscribe();\n        this._leavingSub.unsubscribe();\n    };\n    /** @nocollapse */\n    MatTabBodyPortal.ctorParameters = function () { return [\n        { type: ComponentFactoryResolver },\n        { type: ViewContainerRef },\n        { type: MatTabBody, decorators: [{ type: Inject, args: [forwardRef(function () { return MatTabBody; }),] }] }\n    ]; };\nMatTabBodyPortal.ngDirectiveDef = Éµngcc0.ÉµdefineDirective({ type: MatTabBodyPortal, selectors: [[\"\", \"matTabBodyHost\", \"\"]], factory: function MatTabBodyPortal_Factory(t) { return new (t || MatTabBodyPortal)(Éµngcc0.ÉµdirectiveInject(ComponentFactoryResolver), Éµngcc0.ÉµdirectiveInject(ViewContainerRef), Éµngcc0.ÉµdirectiveInject(forwardRef(function () { return MatTabBody; }))); }, features: [Éµngcc0.ÉµInheritDefinitionFeature] });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatTabBodyPortal, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[matTabBodyHost]'\r\n            }]\r\n    }], function () { return [{ type: ComponentFactoryResolver }, { type: ViewContainerRef }, { type: MatTabBody, decorators: [{\r\n                type: Inject,\r\n                args: [forwardRef(function () { return MatTabBody; })]\r\n            }] }]; }, { ngOnInit: [], _centeringSub: [], _leavingSub: [], ngOnDestroy: [] });\n    return MatTabBodyPortal;\n}(CdkPortalOutlet));\n/**\n * Wrapper for the contents of a tab.\n * \\@docs-private\n */\nvar MatTabBody = /** @class */ (function () {\n    function MatTabBody(_elementRef, _dir, /**\n                   * @breaking-change 8.0.0 changeDetectorRef to be made required.\n                   */\n    changeDetectorRef) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._dir = _dir;\n        /**\n         * Subscription to the directionality change observable.\n         */\n        this._dirChangeSubscription = Subscription.EMPTY;\n        /**\n         * Event emitted when the tab begins to animate towards the center as the active tab.\n         */\n        this._onCentering = new EventEmitter();\n        /**\n         * Event emitted before the centering of the tab begins.\n         */\n        this._beforeCentering = new EventEmitter();\n        /**\n         * Event emitted before the centering of the tab begins.\n         */\n        this._afterLeavingCenter = new EventEmitter();\n        /**\n         * Event emitted when the tab completes its animation towards the center.\n         */\n        this._onCentered = new EventEmitter(true);\n        if (this._dir && changeDetectorRef) {\n            this._dirChangeSubscription = this._dir.change.subscribe(function (dir) {\n                _this._computePositionAnimationState(dir);\n                changeDetectorRef.markForCheck();\n            });\n        }\n    }\n    Object.defineProperty(MatTabBody.prototype, \"position\", {\n        /** The shifted index position of the tab body, where zero represents the active center tab. */\n        set: /**\n         * The shifted index position of the tab body, where zero represents the active center tab.\n         * @param {?} position\n         * @return {?}\n         */\n        function (position) {\n            this._positionIndex = position;\n            this._computePositionAnimationState();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * After initialized, check if the content is centered and has an origin. If so, set the\n     * special position states that transition the tab from the left or right before centering.\n     */\n    /**\n     * After initialized, check if the content is centered and has an origin. If so, set the\n     * special position states that transition the tab from the left or right before centering.\n     * @return {?}\n     */\n    MatTabBody.prototype.ngOnInit = /**\n     * After initialized, check if the content is centered and has an origin. If so, set the\n     * special position states that transition the tab from the left or right before centering.\n     * @return {?}\n     */\n    function () {\n        if (this._position == 'center' && this.origin != null) {\n            this._position = this._computePositionFromOrigin();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatTabBody.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._dirChangeSubscription.unsubscribe();\n    };\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    MatTabBody.prototype._onTranslateTabStarted = /**\n     * @param {?} e\n     * @return {?}\n     */\n    function (e) {\n        /** @type {?} */\n        var isCentering = this._isCenterPosition(e.toState);\n        this._beforeCentering.emit(isCentering);\n        if (isCentering) {\n            this._onCentering.emit(this._elementRef.nativeElement.clientHeight);\n        }\n    };\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    MatTabBody.prototype._onTranslateTabComplete = /**\n     * @param {?} e\n     * @return {?}\n     */\n    function (e) {\n        // If the transition to the center is complete, emit an event.\n        if (this._isCenterPosition(e.toState) && this._isCenterPosition(this._position)) {\n            this._onCentered.emit();\n        }\n        if (this._isCenterPosition(e.fromState) && !this._isCenterPosition(this._position)) {\n            this._afterLeavingCenter.emit();\n        }\n    };\n    /** The text direction of the containing app. */\n    /**\n     * The text direction of the containing app.\n     * @return {?}\n     */\n    MatTabBody.prototype._getLayoutDirection = /**\n     * The text direction of the containing app.\n     * @return {?}\n     */\n    function () {\n        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    };\n    /** Whether the provided position state is considered center, regardless of origin. */\n    /**\n     * Whether the provided position state is considered center, regardless of origin.\n     * @param {?} position\n     * @return {?}\n     */\n    MatTabBody.prototype._isCenterPosition = /**\n     * Whether the provided position state is considered center, regardless of origin.\n     * @param {?} position\n     * @return {?}\n     */\n    function (position) {\n        return position == 'center' ||\n            position == 'left-origin-center' ||\n            position == 'right-origin-center';\n    };\n    /**\n     * Computes the position state that will be used for the tab-body animation trigger.\n     * @param {?=} dir\n     * @return {?}\n     */\n    MatTabBody.prototype._computePositionAnimationState = /**\n     * Computes the position state that will be used for the tab-body animation trigger.\n     * @param {?=} dir\n     * @return {?}\n     */\n    function (dir) {\n        if (dir === void 0) { dir = this._getLayoutDirection(); }\n        if (this._positionIndex < 0) {\n            this._position = dir == 'ltr' ? 'left' : 'right';\n        }\n        else if (this._positionIndex > 0) {\n            this._position = dir == 'ltr' ? 'right' : 'left';\n        }\n        else {\n            this._position = 'center';\n        }\n    };\n    /**\n     * Computes the position state based on the specified origin position. This is used if the\n     * tab is becoming visible immediately after creation.\n     * @return {?}\n     */\n    MatTabBody.prototype._computePositionFromOrigin = /**\n     * Computes the position state based on the specified origin position. This is used if the\n     * tab is becoming visible immediately after creation.\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var dir = this._getLayoutDirection();\n        if ((dir == 'ltr' && this.origin <= 0) || (dir == 'rtl' && this.origin > 0)) {\n            return 'left-origin-center';\n        }\n        return 'right-origin-center';\n    };\n    /** @nocollapse */\n    MatTabBody.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: Directionality, decorators: [{ type: Optional }] },\n        { type: ChangeDetectorRef }\n    ]; };\n    MatTabBody.propDecorators = {\n        _onCentering: [{ type: Output }],\n        _beforeCentering: [{ type: Output }],\n        _afterLeavingCenter: [{ type: Output }],\n        _onCentered: [{ type: Output }],\n        _portalHost: [{ type: ViewChild, args: [PortalHostDirective,] }],\n        _content: [{ type: Input, args: ['content',] }],\n        origin: [{ type: Input }],\n        position: [{ type: Input }]\n    };\nMatTabBody.ngComponentDef = Éµngcc0.ÉµdefineComponent({ type: MatTabBody, selectors: [[\"mat-tab-body\"]], factory: function MatTabBody_Factory(t) { return new (t || MatTabBody)(Éµngcc0.ÉµdirectiveInject(ElementRef), Éµngcc0.ÉµdirectiveInject(Directionality, 8), Éµngcc0.ÉµdirectiveInject(ChangeDetectorRef)); }, viewQuery: function MatTabBody_Query(rf, ctx) { if (rf & 1) {\r\n        Éµngcc0.ÉµviewQuery(PortalHostDirective, true, null);\r\n    } if (rf & 2) {\r\n        var _t;\r\n        (Éµngcc0.ÉµqueryRefresh(_t = Éµngcc0.ÉµloadViewQuery()) && (ctx._portalHost = _t.first));\r\n    } }, hostBindings: function MatTabBody_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµelementHostAttrs(_c2);\r\n    } }, inputs: { position: \"position\", _content: [\"content\", \"_content\"], origin: \"origin\" }, outputs: { _onCentering: \"_onCentering\", _beforeCentering: \"_beforeCentering\", _afterLeavingCenter: \"_afterLeavingCenter\", _onCentered: \"_onCentered\" }, consts: 3, vars: 1, template: function MatTabBody_Template(rf, ctx) { if (rf & 1) {\r\n        Éµngcc0.ÉµelementStart(0, \"div\", _c3, _c4);\r\n        Éµngcc0.Éµlistener(\"@translateTab.start\", function MatTabBody_Template_div_animation_translateTab_start_0_listener($event) { return ctx._onTranslateTabStarted($event); });\r\n        Éµngcc0.Éµlistener(\"@translateTab.done\", function MatTabBody_Template_div_animation_translateTab_done_0_listener($event) { return ctx._onTranslateTabComplete($event); });\r\n        Éµngcc0.Éµtemplate(2, MatTabBody_ng_template_2_Template, 0, 0, \"ng-template\", _c5);\r\n        Éµngcc0.ÉµelementEnd();\r\n    } if (rf & 2) {\r\n        Éµngcc0.Éµselect(0);\r\n        Éµngcc0.ÉµelementProperty(0, \"@translateTab\", Éµngcc0.Éµbind(ctx._position));\r\n    } }, directives: [MatTabBodyPortal], styles: [\".mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}\"], encapsulation: 2, data: { animation: [matTabsAnimations.translateTab] }, changeDetection: 0 });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatTabBody, [{\r\n        type: Component,\r\n        args: [{ selector: 'mat-tab-body',\r\n                template: \"<div class=\\\"mat-tab-body-content\\\" #content [@translateTab]=\\\"_position\\\" (@translateTab.start)=\\\"_onTranslateTabStarted($event)\\\" (@translateTab.done)=\\\"_onTranslateTabComplete($event)\\\"><ng-template matTabBodyHost></ng-template></div>\",\r\n                styles: [\".mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}\"],\r\n                encapsulation: ViewEncapsulation.None,\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                animations: [matTabsAnimations.translateTab],\r\n                host: {\r\n                    'class': 'mat-tab-body'\r\n                }\r\n            }]\r\n    }], function () { return [{ type: ElementRef }, { type: Directionality, decorators: [{\r\n                type: Optional\r\n            }] }, { type: ChangeDetectorRef }]; }, { _elementRef: [], _dir: [], _dirChangeSubscription: [], _onCentering: [{\r\n            type: Output\r\n        }], _beforeCentering: [{\r\n            type: Output\r\n        }], _afterLeavingCenter: [{\r\n            type: Output\r\n        }], _onCentered: [{\r\n            type: Output\r\n        }], position: [{\r\n            type: Input\r\n        }], ngOnInit: [], _position: [], ngOnDestroy: [], _onTranslateTabStarted: [], _onTranslateTabComplete: [], _getLayoutDirection: [], _isCenterPosition: [], _computePositionAnimationState: [], _computePositionFromOrigin: [], _portalHost: [{\r\n            type: ViewChild,\r\n            args: [PortalHostDirective]\r\n        }], _content: [{\r\n            type: Input,\r\n            args: ['content']\r\n        }], origin: [{\r\n            type: Input\r\n        }] });\n    return MatTabBody;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * \\@docs-private\n */\nvar  /**\n * \\@docs-private\n */\nMatTabLabelWrapperBase = /** @class */ (function () {\n    function MatTabLabelWrapperBase() {\n    }\n    return MatTabLabelWrapperBase;\n}());\n/** @type {?} */\nvar _MatTabLabelWrapperMixinBase = mixinDisabled(MatTabLabelWrapperBase);\n/**\n * Used in the `mat-tab-group` view to display tab labels.\n * \\@docs-private\n */\nvar MatTabLabelWrapper = /** @class */ (function (_super) {\n    __extends(MatTabLabelWrapper, _super);\n    function MatTabLabelWrapper(elementRef) {\n        var _this = _super.call(this) || this;\n        _this.elementRef = elementRef;\n        return _this;\n    }\n    /** Sets focus on the wrapper element */\n    /**\n     * Sets focus on the wrapper element\n     * @return {?}\n     */\n    MatTabLabelWrapper.prototype.focus = /**\n     * Sets focus on the wrapper element\n     * @return {?}\n     */\n    function () {\n        this.elementRef.nativeElement.focus();\n    };\n    /**\n     * @return {?}\n     */\n    MatTabLabelWrapper.prototype.getOffsetLeft = /**\n     * @return {?}\n     */\n    function () {\n        return this.elementRef.nativeElement.offsetLeft;\n    };\n    /**\n     * @return {?}\n     */\n    MatTabLabelWrapper.prototype.getOffsetWidth = /**\n     * @return {?}\n     */\n    function () {\n        return this.elementRef.nativeElement.offsetWidth;\n    };\n    /** @nocollapse */\n    MatTabLabelWrapper.ctorParameters = function () { return [\n        { type: ElementRef }\n    ]; };\nMatTabLabelWrapper.ngDirectiveDef = Éµngcc0.ÉµdefineDirective({ type: MatTabLabelWrapper, selectors: [[\"\", \"matTabLabelWrapper\", \"\"]], factory: function MatTabLabelWrapper_Factory(t) { return new (t || MatTabLabelWrapper)(Éµngcc0.ÉµdirectiveInject(ElementRef)); }, hostBindings: function MatTabLabelWrapper_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµallocHostVars(1);\r\n        Éµngcc0.ÉµelementHostStyling(_c6);\r\n    } if (rf & 2) {\r\n        Éµngcc0.ÉµelementAttribute(elIndex, \"aria-disabled\", Éµngcc0.Éµbind(!!ctx.disabled));\r\n        Éµngcc0.ÉµelementHostClassProp(0, ctx.disabled);\r\n        Éµngcc0.ÉµelementHostStylingApply();\r\n    } }, inputs: { disabled: \"disabled\" }, features: [Éµngcc0.ÉµInheritDefinitionFeature] });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatTabLabelWrapper, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[matTabLabelWrapper]',\r\n                inputs: ['disabled'],\r\n                host: {\r\n                    '[class.mat-tab-disabled]': 'disabled',\r\n                    '[attr.aria-disabled]': '!!disabled'\r\n                }\r\n            }]\r\n    }], function () { return [{ type: ElementRef }]; }, { focus: [], getOffsetLeft: [], getOffsetWidth: [] });\n    return MatTabLabelWrapper;\n}(_MatTabLabelWrapperMixinBase));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * The distance in pixels that will be overshot when scrolling a tab label into view. This helps\n * provide a small affordance to the label next to it.\n  @type {?} */\nvar EXAGGERATED_OVERSCROLL = 60;\n/**\n * \\@docs-private\n */\nvar  /**\n * \\@docs-private\n */\nMatTabHeaderBase = /** @class */ (function () {\n    function MatTabHeaderBase() {\n    }\n    return MatTabHeaderBase;\n}());\n/** @type {?} */\nvar _MatTabHeaderMixinBase = mixinDisableRipple(MatTabHeaderBase);\n/**\n * The header of the tab group which displays a list of all the tabs in the tab group. Includes\n * an ink bar that follows the currently selected tab. When the tabs list's width exceeds the\n * width of the header container, then arrows will be displayed to allow the user to scroll\n * left and right across the header.\n * \\@docs-private\n */\nvar MatTabHeader = /** @class */ (function (_super) {\n    __extends(MatTabHeader, _super);\n    function MatTabHeader(_elementRef, _changeDetectorRef, _viewportRuler, _dir, _ngZone) {\n        var _this = _super.call(this) || this;\n        _this._elementRef = _elementRef;\n        _this._changeDetectorRef = _changeDetectorRef;\n        _this._viewportRuler = _viewportRuler;\n        _this._dir = _dir;\n        _this._ngZone = _ngZone;\n        /**\n         * The distance in pixels that the tab labels should be translated to the left.\n         */\n        _this._scrollDistance = 0;\n        /**\n         * Whether the header should scroll to the selected index after the view has been checked.\n         */\n        _this._selectedIndexChanged = false;\n        /**\n         * Emits when the component is destroyed.\n         */\n        _this._destroyed = new Subject();\n        /**\n         * Whether the controls for pagination should be displayed\n         */\n        _this._showPaginationControls = false;\n        /**\n         * Whether the tab list can be scrolled more towards the end of the tab label list.\n         */\n        _this._disableScrollAfter = true;\n        /**\n         * Whether the tab list can be scrolled more towards the beginning of the tab label list.\n         */\n        _this._disableScrollBefore = true;\n        _this._selectedIndex = 0;\n        /**\n         * Event emitted when the option is selected.\n         */\n        _this.selectFocusedIndex = new EventEmitter();\n        /**\n         * Event emitted when a label is focused.\n         */\n        _this.indexFocused = new EventEmitter();\n        return _this;\n    }\n    Object.defineProperty(MatTabHeader.prototype, \"selectedIndex\", {\n        /** The index of the active tab. */\n        get: /**\n         * The index of the active tab.\n         * @return {?}\n         */\n        function () { return this._selectedIndex; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            value = coerceNumberProperty(value);\n            this._selectedIndexChanged = this._selectedIndex != value;\n            this._selectedIndex = value;\n            if (this._keyManager) {\n                this._keyManager.updateActiveItemIndex(value);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatTabHeader.prototype.ngAfterContentChecked = /**\n     * @return {?}\n     */\n    function () {\n        // If the number of tab labels have changed, check if scrolling should be enabled\n        if (this._tabLabelCount != this._labelWrappers.length) {\n            this._updatePagination();\n            this._tabLabelCount = this._labelWrappers.length;\n            this._changeDetectorRef.markForCheck();\n        }\n        // If the selected index has changed, scroll to the label and check if the scrolling controls\n        // should be disabled.\n        if (this._selectedIndexChanged) {\n            this._scrollToLabel(this._selectedIndex);\n            this._checkScrollingControls();\n            this._alignInkBarToSelectedTab();\n            this._selectedIndexChanged = false;\n            this._changeDetectorRef.markForCheck();\n        }\n        // If the scroll distance has been changed (tab selected, focused, scroll controls activated),\n        // then translate the header to reflect this.\n        if (this._scrollDistanceChanged) {\n            this._updateTabScrollPosition();\n            this._scrollDistanceChanged = false;\n            this._changeDetectorRef.markForCheck();\n        }\n    };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    MatTabHeader.prototype._handleKeydown = /**\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        switch (event.keyCode) {\n            case HOME:\n                this._keyManager.setFirstItemActive();\n                event.preventDefault();\n                break;\n            case END:\n                this._keyManager.setLastItemActive();\n                event.preventDefault();\n                break;\n            case ENTER:\n            case SPACE:\n                this.selectFocusedIndex.emit(this.focusIndex);\n                event.preventDefault();\n                break;\n            default:\n                this._keyManager.onKeydown(event);\n        }\n    };\n    /**\n     * Aligns the ink bar to the selected tab on load.\n     */\n    /**\n     * Aligns the ink bar to the selected tab on load.\n     * @return {?}\n     */\n    MatTabHeader.prototype.ngAfterContentInit = /**\n     * Aligns the ink bar to the selected tab on load.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        /** @type {?} */\n        var dirChange = this._dir ? this._dir.change : of(null);\n        /** @type {?} */\n        var resize = this._viewportRuler.change(150);\n        /** @type {?} */\n        var realign = function () {\n            _this._updatePagination();\n            _this._alignInkBarToSelectedTab();\n        };\n        this._keyManager = new FocusKeyManager(this._labelWrappers)\n            .withHorizontalOrientation(this._getLayoutDirection())\n            .withWrap();\n        this._keyManager.updateActiveItem(0);\n        // Defer the first call in order to allow for slower browsers to lay out the elements.\n        // This helps in cases where the user lands directly on a page with paginated tabs.\n        typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame(realign) : realign();\n        // On dir change or window resize, realign the ink bar and update the orientation of\n        // the key manager if the direction has changed.\n        merge(dirChange, resize).pipe(takeUntil(this._destroyed)).subscribe(function () {\n            realign();\n            _this._keyManager.withHorizontalOrientation(_this._getLayoutDirection());\n        });\n        // If there is a change in the focus key manager we need to emit the `indexFocused`\n        // event in order to provide a public event that notifies about focus changes. Also we realign\n        // the tabs container by scrolling the new focused tab into the visible section.\n        this._keyManager.change.pipe(takeUntil(this._destroyed)).subscribe(function (newFocusIndex) {\n            _this.indexFocused.emit(newFocusIndex);\n            _this._setTabFocus(newFocusIndex);\n        });\n    };\n    /**\n     * @return {?}\n     */\n    MatTabHeader.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._destroyed.next();\n        this._destroyed.complete();\n    };\n    /**\n     * Callback for when the MutationObserver detects that the content has changed.\n     */\n    /**\n     * Callback for when the MutationObserver detects that the content has changed.\n     * @return {?}\n     */\n    MatTabHeader.prototype._onContentChanges = /**\n     * Callback for when the MutationObserver detects that the content has changed.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        /** @type {?} */\n        var zoneCallback = function () {\n            _this._updatePagination();\n            _this._alignInkBarToSelectedTab();\n            _this._changeDetectorRef.markForCheck();\n        };\n        // The content observer runs outside the `NgZone` by default, which\n        // means that we need to bring the callback back in ourselves.\n        // @breaking-change 8.0.0 Remove null check for `_ngZone` once it's a required parameter.\n        this._ngZone ? this._ngZone.run(zoneCallback) : zoneCallback();\n    };\n    /**\n     * Updating the view whether pagination should be enabled or not\n     */\n    /**\n     * Updating the view whether pagination should be enabled or not\n     * @return {?}\n     */\n    MatTabHeader.prototype._updatePagination = /**\n     * Updating the view whether pagination should be enabled or not\n     * @return {?}\n     */\n    function () {\n        this._checkPaginationEnabled();\n        this._checkScrollingControls();\n        this._updateTabScrollPosition();\n    };\n    Object.defineProperty(MatTabHeader.prototype, \"focusIndex\", {\n        /** Tracks which element has focus; used for keyboard navigation */\n        get: /**\n         * Tracks which element has focus; used for keyboard navigation\n         * @return {?}\n         */\n        function () {\n            return this._keyManager ? /** @type {?} */ ((this._keyManager.activeItemIndex)) : 0;\n        },\n        /** When the focus index is set, we must manually send focus to the correct label */\n        set: /**\n         * When the focus index is set, we must manually send focus to the correct label\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {\n                return;\n            }\n            this._keyManager.setActiveItem(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n     * providing a valid index and return true.\n     */\n    /**\n     * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n     * providing a valid index and return true.\n     * @param {?} index\n     * @return {?}\n     */\n    MatTabHeader.prototype._isValidIndex = /**\n     * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n     * providing a valid index and return true.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        if (!this._labelWrappers) {\n            return true;\n        }\n        /** @type {?} */\n        var tab = this._labelWrappers ? this._labelWrappers.toArray()[index] : null;\n        return !!tab && !tab.disabled;\n    };\n    /**\n     * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n     * scrolling is enabled.\n     */\n    /**\n     * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n     * scrolling is enabled.\n     * @param {?} tabIndex\n     * @return {?}\n     */\n    MatTabHeader.prototype._setTabFocus = /**\n     * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n     * scrolling is enabled.\n     * @param {?} tabIndex\n     * @return {?}\n     */\n    function (tabIndex) {\n        if (this._showPaginationControls) {\n            this._scrollToLabel(tabIndex);\n        }\n        if (this._labelWrappers && this._labelWrappers.length) {\n            this._labelWrappers.toArray()[tabIndex].focus();\n            /** @type {?} */\n            var containerEl = this._tabListContainer.nativeElement;\n            /** @type {?} */\n            var dir = this._getLayoutDirection();\n            if (dir == 'ltr') {\n                containerEl.scrollLeft = 0;\n            }\n            else {\n                containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;\n            }\n        }\n    };\n    /** The layout direction of the containing app. */\n    /**\n     * The layout direction of the containing app.\n     * @return {?}\n     */\n    MatTabHeader.prototype._getLayoutDirection = /**\n     * The layout direction of the containing app.\n     * @return {?}\n     */\n    function () {\n        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    };\n    /** Performs the CSS transformation on the tab list that will cause the list to scroll. */\n    /**\n     * Performs the CSS transformation on the tab list that will cause the list to scroll.\n     * @return {?}\n     */\n    MatTabHeader.prototype._updateTabScrollPosition = /**\n     * Performs the CSS transformation on the tab list that will cause the list to scroll.\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var scrollDistance = this.scrollDistance;\n        /** @type {?} */\n        var translateX = this._getLayoutDirection() === 'ltr' ? -scrollDistance : scrollDistance;\n        // Don't use `translate3d` here because we don't want to create a new layer. A new layer\n        // seems to cause flickering and overflow in Internet Explorer. For example, the ink bar\n        // and ripples will exceed the boundaries of the visible tab bar.\n        // See: https://github.com/angular/material2/issues/10276\n        this._tabList.nativeElement.style.transform = \"translateX(\" + translateX + \"px)\";\n    };\n    Object.defineProperty(MatTabHeader.prototype, \"scrollDistance\", {\n        /** Sets the distance in pixels that the tab header should be transformed in the X-axis. */\n        get: /**\n         * Sets the distance in pixels that the tab header should be transformed in the X-axis.\n         * @return {?}\n         */\n        function () { return this._scrollDistance; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) {\n            this._scrollDistance = Math.max(0, Math.min(this._getMaxScrollDistance(), v));\n            // Mark that the scroll distance has changed so that after the view is checked, the CSS\n            // transformation can move the header.\n            this._scrollDistanceChanged = true;\n            this._checkScrollingControls();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n     * the end of the list, respectively). The distance to scroll is computed to be a third of the\n     * length of the tab list view window.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    /**\n     * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n     * the end of the list, respectively). The distance to scroll is computed to be a third of the\n     * length of the tab list view window.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @param {?} scrollDir\n     * @return {?}\n     */\n    MatTabHeader.prototype._scrollHeader = /**\n     * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n     * the end of the list, respectively). The distance to scroll is computed to be a third of the\n     * length of the tab list view window.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @param {?} scrollDir\n     * @return {?}\n     */\n    function (scrollDir) {\n        /** @type {?} */\n        var viewLength = this._tabListContainer.nativeElement.offsetWidth;\n        // Move the scroll distance one-third the length of the tab list's viewport.\n        this.scrollDistance += (scrollDir == 'before' ? -1 : 1) * viewLength / 3;\n    };\n    /**\n     * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    /**\n     * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @param {?} labelIndex\n     * @return {?}\n     */\n    MatTabHeader.prototype._scrollToLabel = /**\n     * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @param {?} labelIndex\n     * @return {?}\n     */\n    function (labelIndex) {\n        /** @type {?} */\n        var selectedLabel = this._labelWrappers ? this._labelWrappers.toArray()[labelIndex] : null;\n        if (!selectedLabel) {\n            return;\n        }\n        /** @type {?} */\n        var viewLength = this._tabListContainer.nativeElement.offsetWidth;\n        /** @type {?} */\n        var labelBeforePos;\n        /** @type {?} */\n        var labelAfterPos;\n        if (this._getLayoutDirection() == 'ltr') {\n            labelBeforePos = selectedLabel.getOffsetLeft();\n            labelAfterPos = labelBeforePos + selectedLabel.getOffsetWidth();\n        }\n        else {\n            labelAfterPos = this._tabList.nativeElement.offsetWidth - selectedLabel.getOffsetLeft();\n            labelBeforePos = labelAfterPos - selectedLabel.getOffsetWidth();\n        }\n        /** @type {?} */\n        var beforeVisiblePos = this.scrollDistance;\n        /** @type {?} */\n        var afterVisiblePos = this.scrollDistance + viewLength;\n        if (labelBeforePos < beforeVisiblePos) {\n            // Scroll header to move label to the before direction\n            this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;\n        }\n        else if (labelAfterPos > afterVisiblePos) {\n            // Scroll header to move label to the after direction\n            this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;\n        }\n    };\n    /**\n     * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n     * tab list is wider than the size of the header container, then the pagination controls should\n     * be shown.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    /**\n     * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n     * tab list is wider than the size of the header container, then the pagination controls should\n     * be shown.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n    MatTabHeader.prototype._checkPaginationEnabled = /**\n     * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n     * tab list is wider than the size of the header container, then the pagination controls should\n     * be shown.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var isEnabled = this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;\n        if (!isEnabled) {\n            this.scrollDistance = 0;\n        }\n        if (isEnabled !== this._showPaginationControls) {\n            this._changeDetectorRef.markForCheck();\n        }\n        this._showPaginationControls = isEnabled;\n    };\n    /**\n     * Evaluate whether the before and after controls should be enabled or disabled.\n     * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n     * before button. If the header is at the end of the list (scroll distance is equal to the\n     * maximum distance we can scroll), then disable the after button.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    /**\n     * Evaluate whether the before and after controls should be enabled or disabled.\n     * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n     * before button. If the header is at the end of the list (scroll distance is equal to the\n     * maximum distance we can scroll), then disable the after button.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n    MatTabHeader.prototype._checkScrollingControls = /**\n     * Evaluate whether the before and after controls should be enabled or disabled.\n     * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n     * before button. If the header is at the end of the list (scroll distance is equal to the\n     * maximum distance we can scroll), then disable the after button.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n    function () {\n        // Check if the pagination arrows should be activated.\n        this._disableScrollBefore = this.scrollDistance == 0;\n        this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();\n        this._changeDetectorRef.markForCheck();\n    };\n    /**\n     * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n     * is equal to the difference in width between the tab list container and tab header container.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    /**\n     * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n     * is equal to the difference in width between the tab list container and tab header container.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n    MatTabHeader.prototype._getMaxScrollDistance = /**\n     * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n     * is equal to the difference in width between the tab list container and tab header container.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var lengthOfTabList = this._tabList.nativeElement.scrollWidth;\n        /** @type {?} */\n        var viewLength = this._tabListContainer.nativeElement.offsetWidth;\n        return (lengthOfTabList - viewLength) || 0;\n    };\n    /** Tells the ink-bar to align itself to the current label wrapper */\n    /**\n     * Tells the ink-bar to align itself to the current label wrapper\n     * @return {?}\n     */\n    MatTabHeader.prototype._alignInkBarToSelectedTab = /**\n     * Tells the ink-bar to align itself to the current label wrapper\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var selectedLabelWrapper = this._labelWrappers && this._labelWrappers.length ?\n            this._labelWrappers.toArray()[this.selectedIndex].elementRef.nativeElement :\n            null;\n        this._inkBar.alignToElement(/** @type {?} */ ((selectedLabelWrapper)));\n    };\n    /** @nocollapse */\n    MatTabHeader.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: ChangeDetectorRef },\n        { type: ViewportRuler },\n        { type: Directionality, decorators: [{ type: Optional }] },\n        { type: NgZone }\n    ]; };\n    MatTabHeader.propDecorators = {\n        _labelWrappers: [{ type: ContentChildren, args: [MatTabLabelWrapper,] }],\n        _inkBar: [{ type: ViewChild, args: [MatInkBar,] }],\n        _tabListContainer: [{ type: ViewChild, args: ['tabListContainer',] }],\n        _tabList: [{ type: ViewChild, args: ['tabList',] }],\n        selectedIndex: [{ type: Input }],\n        selectFocusedIndex: [{ type: Output }],\n        indexFocused: [{ type: Output }]\n    };\nMatTabHeader.ngComponentDef = Éµngcc0.ÉµdefineComponent({ type: MatTabHeader, selectors: [[\"mat-tab-header\"]], factory: function MatTabHeader_Factory(t) { return new (t || MatTabHeader)(Éµngcc0.ÉµdirectiveInject(ElementRef), Éµngcc0.ÉµdirectiveInject(ChangeDetectorRef), Éµngcc0.ÉµdirectiveInject(ViewportRuler), Éµngcc0.ÉµdirectiveInject(Directionality, 8), Éµngcc0.ÉµdirectiveInject(NgZone)); }, contentQueries: function MatTabHeader_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµcontentQuery(dirIndex, MatTabLabelWrapper, false, null);\r\n    } if (rf & 2) {\r\n        var _t;\r\n        (Éµngcc0.ÉµqueryRefresh(_t = Éµngcc0.ÉµloadContentQuery()) && (ctx._labelWrappers = _t));\r\n    } }, viewQuery: function MatTabHeader_Query(rf, ctx) { if (rf & 1) {\r\n        Éµngcc0.ÉµviewQuery(MatInkBar, true, null);\r\n        Éµngcc0.ÉµviewQuery(_c7, true, null);\r\n        Éµngcc0.ÉµviewQuery(_c8, true, null);\r\n    } if (rf & 2) {\r\n        var _t;\r\n        (Éµngcc0.ÉµqueryRefresh(_t = Éµngcc0.ÉµloadViewQuery()) && (ctx._inkBar = _t.first));\r\n        (Éµngcc0.ÉµqueryRefresh(_t = Éµngcc0.ÉµloadViewQuery()) && (ctx._tabListContainer = _t.first));\r\n        (Éµngcc0.ÉµqueryRefresh(_t = Éµngcc0.ÉµloadViewQuery()) && (ctx._tabList = _t.first));\r\n    } }, hostBindings: function MatTabHeader_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµelementHostAttrs(_c9);\r\n        Éµngcc0.ÉµelementHostStyling(_c10);\r\n    } if (rf & 2) {\r\n        Éµngcc0.ÉµelementHostClassProp(0, ctx._showPaginationControls);\r\n        Éµngcc0.ÉµelementHostClassProp(1, (ctx._getLayoutDirection() == \"rtl\"));\r\n        Éµngcc0.ÉµelementHostStylingApply();\r\n    } }, inputs: { disableRipple: \"disableRipple\", selectedIndex: \"selectedIndex\" }, outputs: { selectFocusedIndex: \"selectFocusedIndex\", indexFocused: \"indexFocused\" }, features: [Éµngcc0.ÉµInheritDefinitionFeature], ngContentSelectors: _c1, consts: 11, vars: 2, template: function MatTabHeader_Template(rf, ctx) { if (rf & 1) {\r\n        Éµngcc0.ÉµprojectionDef();\r\n        Éµngcc0.ÉµelementStart(0, \"div\", _c11);\r\n        Éµngcc0.ÉµelementStyling(_c19);\r\n        Éµngcc0.Éµlistener(\"click\", function MatTabHeader_Template_div_click_0_listener($event) { return ctx._scrollHeader(\"before\"); });\r\n        Éµngcc0.Éµelement(1, \"div\", _c12);\r\n        Éµngcc0.ÉµelementEnd();\r\n        Éµngcc0.ÉµelementStart(2, \"div\", _c13, _c14);\r\n        Éµngcc0.Éµlistener(\"keydown\", function MatTabHeader_Template_div_keydown_2_listener($event) { return ctx._handleKeydown($event); });\r\n        Éµngcc0.ÉµelementStart(4, \"div\", _c15, _c16);\r\n        Éµngcc0.Éµlistener(\"cdkObserveContent\", function MatTabHeader_Template_div_cdkObserveContent_4_listener($event) { return ctx._onContentChanges(); });\r\n        Éµngcc0.ÉµelementStart(6, \"div\", _c17);\r\n        Éµngcc0.Éµprojection(7);\r\n        Éµngcc0.ÉµelementEnd();\r\n        Éµngcc0.Éµelement(8, \"mat-ink-bar\");\r\n        Éµngcc0.ÉµelementEnd();\r\n        Éµngcc0.ÉµelementEnd();\r\n        Éµngcc0.ÉµelementStart(9, \"div\", _c18);\r\n        Éµngcc0.ÉµelementStyling(_c19);\r\n        Éµngcc0.Éµlistener(\"click\", function MatTabHeader_Template_div_click_9_listener($event) { return ctx._scrollHeader(\"after\"); });\r\n        Éµngcc0.Éµelement(10, \"div\", _c12);\r\n        Éµngcc0.ÉµelementEnd();\r\n    } if (rf & 2) {\r\n        Éµngcc0.ÉµelementClassProp(0, 0, ctx._disableScrollBefore);\r\n        Éµngcc0.ÉµelementStylingApply(0);\r\n        Éµngcc0.Éµselect(0);\r\n        Éµngcc0.ÉµelementProperty(0, \"matRippleDisabled\", Éµngcc0.Éµbind((ctx._disableScrollBefore || ctx.disableRipple)));\r\n        Éµngcc0.ÉµelementClassProp(9, 0, ctx._disableScrollAfter);\r\n        Éµngcc0.ÉµelementStylingApply(9);\r\n        Éµngcc0.Éµselect(9);\r\n        Éµngcc0.ÉµelementProperty(9, \"matRippleDisabled\", Éµngcc0.Éµbind((ctx._disableScrollAfter || ctx.disableRipple)));\r\n    } }, directives: [Éµngcc1.MatRipple, Éµngcc2.CdkObserveContent, MatInkBar], styles: [\".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:0}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media screen and (-ms-high-contrast:active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media screen and (-ms-high-contrast:active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media screen and (-ms-high-contrast:active){.mat-tab-label{opacity:1}}@media (max-width:599px){.mat-tab-label{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media screen and (-ms-high-contrast:active){.mat-ink-bar{outline:solid 2px;height:0}}.mat-tab-header-pagination{position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-pagination-after,.mat-tab-header-rtl .mat-tab-header-pagination-before{padding-right:4px}.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:'';height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-list{flex-grow:1;position:relative;transition:transform .5s cubic-bezier(.35,0,.25,1)}.mat-tab-labels{display:flex}[mat-align-tabs=center] .mat-tab-labels{justify-content:center}[mat-align-tabs=end] .mat-tab-labels{justify-content:flex-end}\"], encapsulation: 2, changeDetection: 0 });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatTabHeader, [{\r\n        type: Component,\r\n        args: [{ selector: 'mat-tab-header',\r\n                template: \"<div class=\\\"mat-tab-header-pagination mat-tab-header-pagination-before mat-elevation-z4\\\" aria-hidden=\\\"true\\\" mat-ripple [matRippleDisabled]=\\\"_disableScrollBefore || disableRipple\\\" [class.mat-tab-header-pagination-disabled]=\\\"_disableScrollBefore\\\" (click)=\\\"_scrollHeader('before')\\\"><div class=\\\"mat-tab-header-pagination-chevron\\\"></div></div><div class=\\\"mat-tab-label-container\\\" #tabListContainer (keydown)=\\\"_handleKeydown($event)\\\"><div class=\\\"mat-tab-list\\\" #tabList role=\\\"tablist\\\" (cdkObserveContent)=\\\"_onContentChanges()\\\"><div class=\\\"mat-tab-labels\\\"><ng-content></ng-content></div><mat-ink-bar></mat-ink-bar></div></div><div class=\\\"mat-tab-header-pagination mat-tab-header-pagination-after mat-elevation-z4\\\" aria-hidden=\\\"true\\\" mat-ripple [matRippleDisabled]=\\\"_disableScrollAfter || disableRipple\\\" [class.mat-tab-header-pagination-disabled]=\\\"_disableScrollAfter\\\" (click)=\\\"_scrollHeader('after')\\\"><div class=\\\"mat-tab-header-pagination-chevron\\\"></div></div>\",\r\n                styles: [\".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:0}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media screen and (-ms-high-contrast:active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media screen and (-ms-high-contrast:active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media screen and (-ms-high-contrast:active){.mat-tab-label{opacity:1}}@media (max-width:599px){.mat-tab-label{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media screen and (-ms-high-contrast:active){.mat-ink-bar{outline:solid 2px;height:0}}.mat-tab-header-pagination{position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-pagination-after,.mat-tab-header-rtl .mat-tab-header-pagination-before{padding-right:4px}.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:'';height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-list{flex-grow:1;position:relative;transition:transform .5s cubic-bezier(.35,0,.25,1)}.mat-tab-labels{display:flex}[mat-align-tabs=center] .mat-tab-labels{justify-content:center}[mat-align-tabs=end] .mat-tab-labels{justify-content:flex-end}\"],\r\n                inputs: ['disableRipple'],\r\n                encapsulation: ViewEncapsulation.None,\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                host: {\r\n                    'class': 'mat-tab-header',\r\n                    '[class.mat-tab-header-pagination-controls-enabled]': '_showPaginationControls',\r\n                    '[class.mat-tab-header-rtl]': \"_getLayoutDirection() == 'rtl'\"\r\n                }\r\n            }]\r\n    }], function () { return [{ type: ElementRef }, { type: ChangeDetectorRef }, { type: ViewportRuler }, { type: Directionality, decorators: [{\r\n                type: Optional\r\n            }] }, { type: NgZone }]; }, { selectedIndex: [{\r\n            type: Input\r\n        }], selectedIndex: [], ngAfterContentChecked: [], _tabLabelCount: [], _selectedIndexChanged: [], _scrollDistanceChanged: [], _handleKeydown: [], ngAfterContentInit: [], _keyManager: [], ngOnDestroy: [], _onContentChanges: [], _updatePagination: [], focusIndex: [], focusIndex: [], _isValidIndex: [], _setTabFocus: [], _getLayoutDirection: [], _updateTabScrollPosition: [], scrollDistance: [], scrollDistance: [], _scrollHeader: [], _scrollToLabel: [], _checkPaginationEnabled: [], _showPaginationControls: [], _checkScrollingControls: [], _disableScrollBefore: [], _disableScrollAfter: [], _getMaxScrollDistance: [], _alignInkBarToSelectedTab: [], _labelWrappers: [{\r\n            type: ContentChildren,\r\n            args: [MatTabLabelWrapper]\r\n        }], _inkBar: [{\r\n            type: ViewChild,\r\n            args: [MatInkBar]\r\n        }], _tabListContainer: [{\r\n            type: ViewChild,\r\n            args: ['tabListContainer']\r\n        }], _tabList: [{\r\n            type: ViewChild,\r\n            args: ['tabList']\r\n        }], selectFocusedIndex: [{\r\n            type: Output\r\n        }], indexFocused: [{\r\n            type: Output\r\n        }] });\n    return MatTabHeader;\n}(_MatTabHeaderMixinBase));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * Used to generate unique ID's for each tab component\n  @type {?} */\nvar nextId = 0;\n/**\n * A simple change event emitted on focus or selection changes.\n */\nvar  /**\n * A simple change event emitted on focus or selection changes.\n */\nMatTabChangeEvent = /** @class */ (function () {\n    function MatTabChangeEvent() {\n    }\n    return MatTabChangeEvent;\n}());\n/**\n * \\@docs-private\n */\nvar  /**\n * \\@docs-private\n */\nMatTabGroupBase = /** @class */ (function () {\n    function MatTabGroupBase(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n    return MatTabGroupBase;\n}());\n/** @type {?} */\nvar _MatTabGroupMixinBase = mixinColor(mixinDisableRipple(MatTabGroupBase), 'primary');\n/**\n * Material design tab-group component.  Supports basic tab pairs (label + content) and includes\n * animated ink-bar, keyboard navigation, and screen reader.\n * See: https://material.io/design/components/tabs.html\n */\nvar MatTabGroup = /** @class */ (function (_super) {\n    __extends(MatTabGroup, _super);\n    function MatTabGroup(elementRef, _changeDetectorRef) {\n        var _this = _super.call(this, elementRef) || this;\n        _this._changeDetectorRef = _changeDetectorRef;\n        /**\n         * The tab index that should be selected after the content has been checked.\n         */\n        _this._indexToSelect = 0;\n        /**\n         * Snapshot of the height of the tab body wrapper before another tab is activated.\n         */\n        _this._tabBodyWrapperHeight = 0;\n        /**\n         * Subscription to tabs being added/removed.\n         */\n        _this._tabsSubscription = Subscription.EMPTY;\n        /**\n         * Subscription to changes in the tab labels.\n         */\n        _this._tabLabelSubscription = Subscription.EMPTY;\n        _this._dynamicHeight = false;\n        _this._selectedIndex = null;\n        /**\n         * Position of the tab header.\n         */\n        _this.headerPosition = 'above';\n        /**\n         * Output to enable support for two-way binding on `[(selectedIndex)]`\n         */\n        _this.selectedIndexChange = new EventEmitter();\n        /**\n         * Event emitted when focus has changed within a tab group.\n         */\n        _this.focusChange = new EventEmitter();\n        /**\n         * Event emitted when the body animation has completed\n         */\n        _this.animationDone = new EventEmitter();\n        /**\n         * Event emitted when the tab selection has changed.\n         */\n        _this.selectedTabChange = new EventEmitter(true);\n        _this._groupId = nextId++;\n        return _this;\n    }\n    Object.defineProperty(MatTabGroup.prototype, \"dynamicHeight\", {\n        /** Whether the tab group should grow to the size of the active tab. */\n        get: /**\n         * Whether the tab group should grow to the size of the active tab.\n         * @return {?}\n         */\n        function () { return this._dynamicHeight; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._dynamicHeight = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTabGroup.prototype, \"selectedIndex\", {\n        /** The index of the active tab. */\n        get: /**\n         * The index of the active tab.\n         * @return {?}\n         */\n        function () { return this._selectedIndex; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._indexToSelect = coerceNumberProperty(value, null);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTabGroup.prototype, \"backgroundColor\", {\n        /** Background color of the tab group. */\n        get: /**\n         * Background color of the tab group.\n         * @return {?}\n         */\n        function () { return this._backgroundColor; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            /** @type {?} */\n            var nativeElement = this._elementRef.nativeElement;\n            nativeElement.classList.remove(\"mat-background-\" + this.backgroundColor);\n            if (value) {\n                nativeElement.classList.add(\"mat-background-\" + value);\n            }\n            this._backgroundColor = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * After the content is checked, this component knows what tabs have been defined\n     * and what the selected index should be. This is where we can know exactly what position\n     * each tab should be in according to the new selected index, and additionally we know how\n     * a new selected tab should transition in (from the left or right).\n     */\n    /**\n     * After the content is checked, this component knows what tabs have been defined\n     * and what the selected index should be. This is where we can know exactly what position\n     * each tab should be in according to the new selected index, and additionally we know how\n     * a new selected tab should transition in (from the left or right).\n     * @return {?}\n     */\n    MatTabGroup.prototype.ngAfterContentChecked = /**\n     * After the content is checked, this component knows what tabs have been defined\n     * and what the selected index should be. This is where we can know exactly what position\n     * each tab should be in according to the new selected index, and additionally we know how\n     * a new selected tab should transition in (from the left or right).\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        /** @type {?} */\n        var indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);\n        // If there is a change in selected index, emit a change event. Should not trigger if\n        // the selected index has not yet been initialized.\n        if (this._selectedIndex != indexToSelect) {\n            /** @type {?} */\n            var isFirstRun_1 = this._selectedIndex == null;\n            if (!isFirstRun_1) {\n                this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));\n            }\n            // Changing these values after change detection has run\n            // since the checked content may contain references to them.\n            Promise.resolve().then(function () {\n                _this._tabs.forEach(function (tab, index) { return tab.isActive = index === indexToSelect; });\n                if (!isFirstRun_1) {\n                    _this.selectedIndexChange.emit(indexToSelect);\n                }\n            });\n        }\n        // Setup the position for each tab and optionally setup an origin on the next selected tab.\n        this._tabs.forEach(function (tab, index) {\n            tab.position = index - indexToSelect;\n            // If there is already a selected tab, then set up an origin for the next selected tab\n            // if it doesn't have one already.\n            if (_this._selectedIndex != null && tab.position == 0 && !tab.origin) {\n                tab.origin = indexToSelect - _this._selectedIndex;\n            }\n        });\n        if (this._selectedIndex !== indexToSelect) {\n            this._selectedIndex = indexToSelect;\n            this._changeDetectorRef.markForCheck();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatTabGroup.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._subscribeToTabLabels();\n        // Subscribe to changes in the amount of tabs, in order to be\n        // able to re-render the content as new tabs are added or removed.\n        this._tabsSubscription = this._tabs.changes.subscribe(function () {\n            /** @type {?} */\n            var indexToSelect = _this._clampTabIndex(_this._indexToSelect);\n            // Maintain the previously-selected tab if a new tab is added or removed and there is no\n            // explicit change that selects a different tab.\n            if (indexToSelect === _this._selectedIndex) {\n                /** @type {?} */\n                var tabs = _this._tabs.toArray();\n                for (var i = 0; i < tabs.length; i++) {\n                    if (tabs[i].isActive) {\n                        // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed\n                        // event, otherwise the consumer may end up in an infinite loop in some edge cases like\n                        // adding a tab within the `selectedIndexChange` event.\n                        _this._indexToSelect = _this._selectedIndex = i;\n                        break;\n                    }\n                }\n            }\n            _this._subscribeToTabLabels();\n            _this._changeDetectorRef.markForCheck();\n        });\n    };\n    /**\n     * @return {?}\n     */\n    MatTabGroup.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._tabsSubscription.unsubscribe();\n        this._tabLabelSubscription.unsubscribe();\n    };\n    /** Re-aligns the ink bar to the selected tab element. */\n    /**\n     * Re-aligns the ink bar to the selected tab element.\n     * @return {?}\n     */\n    MatTabGroup.prototype.realignInkBar = /**\n     * Re-aligns the ink bar to the selected tab element.\n     * @return {?}\n     */\n    function () {\n        if (this._tabHeader) {\n            this._tabHeader._alignInkBarToSelectedTab();\n        }\n    };\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    MatTabGroup.prototype._focusChanged = /**\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        this.focusChange.emit(this._createChangeEvent(index));\n    };\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    MatTabGroup.prototype._createChangeEvent = /**\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        /** @type {?} */\n        var event = new MatTabChangeEvent;\n        event.index = index;\n        if (this._tabs && this._tabs.length) {\n            event.tab = this._tabs.toArray()[index];\n        }\n        return event;\n    };\n    /**\n     * Subscribes to changes in the tab labels. This is needed, because the \\@Input for the label is\n     * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the\n     * binding to be updated, we need to subscribe to changes in it and trigger change detection\n     * manually.\n     * @return {?}\n     */\n    MatTabGroup.prototype._subscribeToTabLabels = /**\n     * Subscribes to changes in the tab labels. This is needed, because the \\@Input for the label is\n     * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the\n     * binding to be updated, we need to subscribe to changes in it and trigger change detection\n     * manually.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (this._tabLabelSubscription) {\n            this._tabLabelSubscription.unsubscribe();\n        }\n        this._tabLabelSubscription = merge.apply(void 0, this._tabs.map(function (tab) { return tab._stateChanges; })).subscribe(function () { return _this._changeDetectorRef.markForCheck(); });\n    };\n    /**\n     * Clamps the given index to the bounds of 0 and the tabs length.\n     * @param {?} index\n     * @return {?}\n     */\n    MatTabGroup.prototype._clampTabIndex = /**\n     * Clamps the given index to the bounds of 0 and the tabs length.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        // Note the `|| 0`, which ensures that values like NaN can't get through\n        // and which would otherwise throw the component into an infinite loop\n        // (since Math.max(NaN, 0) === NaN).\n        return Math.min(this._tabs.length - 1, Math.max(index || 0, 0));\n    };\n    /** Returns a unique id for each tab label element */\n    /**\n     * Returns a unique id for each tab label element\n     * @param {?} i\n     * @return {?}\n     */\n    MatTabGroup.prototype._getTabLabelId = /**\n     * Returns a unique id for each tab label element\n     * @param {?} i\n     * @return {?}\n     */\n    function (i) {\n        return \"mat-tab-label-\" + this._groupId + \"-\" + i;\n    };\n    /** Returns a unique id for each tab content element */\n    /**\n     * Returns a unique id for each tab content element\n     * @param {?} i\n     * @return {?}\n     */\n    MatTabGroup.prototype._getTabContentId = /**\n     * Returns a unique id for each tab content element\n     * @param {?} i\n     * @return {?}\n     */\n    function (i) {\n        return \"mat-tab-content-\" + this._groupId + \"-\" + i;\n    };\n    /**\n     * Sets the height of the body wrapper to the height of the activating tab if dynamic\n     * height property is true.\n     */\n    /**\n     * Sets the height of the body wrapper to the height of the activating tab if dynamic\n     * height property is true.\n     * @param {?} tabHeight\n     * @return {?}\n     */\n    MatTabGroup.prototype._setTabBodyWrapperHeight = /**\n     * Sets the height of the body wrapper to the height of the activating tab if dynamic\n     * height property is true.\n     * @param {?} tabHeight\n     * @return {?}\n     */\n    function (tabHeight) {\n        if (!this._dynamicHeight || !this._tabBodyWrapperHeight) {\n            return;\n        }\n        /** @type {?} */\n        var wrapper = this._tabBodyWrapper.nativeElement;\n        wrapper.style.height = this._tabBodyWrapperHeight + 'px';\n        // This conditional forces the browser to paint the height so that\n        // the animation to the new height can have an origin.\n        if (this._tabBodyWrapper.nativeElement.offsetHeight) {\n            wrapper.style.height = tabHeight + 'px';\n        }\n    };\n    /** Removes the height of the tab body wrapper. */\n    /**\n     * Removes the height of the tab body wrapper.\n     * @return {?}\n     */\n    MatTabGroup.prototype._removeTabBodyWrapperHeight = /**\n     * Removes the height of the tab body wrapper.\n     * @return {?}\n     */\n    function () {\n        this._tabBodyWrapperHeight = this._tabBodyWrapper.nativeElement.clientHeight;\n        this._tabBodyWrapper.nativeElement.style.height = '';\n        this.animationDone.emit();\n    };\n    /** Handle click events, setting new selected index if appropriate. */\n    /**\n     * Handle click events, setting new selected index if appropriate.\n     * @param {?} tab\n     * @param {?} tabHeader\n     * @param {?} idx\n     * @return {?}\n     */\n    MatTabGroup.prototype._handleClick = /**\n     * Handle click events, setting new selected index if appropriate.\n     * @param {?} tab\n     * @param {?} tabHeader\n     * @param {?} idx\n     * @return {?}\n     */\n    function (tab, tabHeader, idx) {\n        if (!tab.disabled) {\n            this.selectedIndex = tabHeader.focusIndex = idx;\n        }\n    };\n    /** Retrieves the tabindex for the tab. */\n    /**\n     * Retrieves the tabindex for the tab.\n     * @param {?} tab\n     * @param {?} idx\n     * @return {?}\n     */\n    MatTabGroup.prototype._getTabIndex = /**\n     * Retrieves the tabindex for the tab.\n     * @param {?} tab\n     * @param {?} idx\n     * @return {?}\n     */\n    function (tab, idx) {\n        if (tab.disabled) {\n            return null;\n        }\n        return this.selectedIndex === idx ? 0 : -1;\n    };\n    /** @nocollapse */\n    MatTabGroup.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: ChangeDetectorRef }\n    ]; };\n    MatTabGroup.propDecorators = {\n        _tabs: [{ type: ContentChildren, args: [MatTab,] }],\n        _tabBodyWrapper: [{ type: ViewChild, args: ['tabBodyWrapper',] }],\n        _tabHeader: [{ type: ViewChild, args: ['tabHeader',] }],\n        dynamicHeight: [{ type: Input }],\n        selectedIndex: [{ type: Input }],\n        headerPosition: [{ type: Input }],\n        backgroundColor: [{ type: Input }],\n        selectedIndexChange: [{ type: Output }],\n        focusChange: [{ type: Output }],\n        animationDone: [{ type: Output }],\n        selectedTabChange: [{ type: Output }]\n    };\nMatTabGroup.ngComponentDef = Éµngcc0.ÉµdefineComponent({ type: MatTabGroup, selectors: [[\"mat-tab-group\"]], factory: function MatTabGroup_Factory(t) { return new (t || MatTabGroup)(Éµngcc0.ÉµdirectiveInject(ElementRef), Éµngcc0.ÉµdirectiveInject(ChangeDetectorRef)); }, contentQueries: function MatTabGroup_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµcontentQuery(dirIndex, MatTab, false, null);\r\n    } if (rf & 2) {\r\n        var _t;\r\n        (Éµngcc0.ÉµqueryRefresh(_t = Éµngcc0.ÉµloadContentQuery()) && (ctx._tabs = _t));\r\n    } }, viewQuery: function MatTabGroup_Query(rf, ctx) { if (rf & 1) {\r\n        Éµngcc0.ÉµviewQuery(_c20, true, null);\r\n        Éµngcc0.ÉµviewQuery(_c21, true, null);\r\n    } if (rf & 2) {\r\n        var _t;\r\n        (Éµngcc0.ÉµqueryRefresh(_t = Éµngcc0.ÉµloadViewQuery()) && (ctx._tabBodyWrapper = _t.first));\r\n        (Éµngcc0.ÉµqueryRefresh(_t = Éµngcc0.ÉµloadViewQuery()) && (ctx._tabHeader = _t.first));\r\n    } }, hostBindings: function MatTabGroup_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµelementHostAttrs(_c22);\r\n        Éµngcc0.ÉµelementHostStyling(_c23);\r\n    } if (rf & 2) {\r\n        Éµngcc0.ÉµelementHostClassProp(0, ctx.dynamicHeight);\r\n        Éµngcc0.ÉµelementHostClassProp(1, (ctx.headerPosition === \"below\"));\r\n        Éµngcc0.ÉµelementHostStylingApply();\r\n    } }, inputs: { color: \"color\", disableRipple: \"disableRipple\", dynamicHeight: \"dynamicHeight\", selectedIndex: \"selectedIndex\", backgroundColor: \"backgroundColor\", headerPosition: \"headerPosition\" }, outputs: { selectedIndexChange: \"selectedIndexChange\", focusChange: \"focusChange\", animationDone: \"animationDone\", selectedTabChange: \"selectedTabChange\" }, exportAs: [\"matTabGroup\"], features: [Éµngcc0.ÉµInheritDefinitionFeature], consts: 6, vars: 4, template: function MatTabGroup_Template(rf, ctx) { if (rf & 1) {\r\n        Éµngcc0.ÉµelementStart(0, \"mat-tab-header\", _c24, _c25);\r\n        Éµngcc0.Éµlistener(\"indexFocused\", function MatTabGroup_Template_mat_tab_header_indexFocused_0_listener($event) { return ctx._focusChanged($event); });\r\n        Éµngcc0.Éµlistener(\"selectFocusedIndex\", function MatTabGroup_Template_mat_tab_header_selectFocusedIndex_0_listener($event) { return ctx.selectedIndex = $event; });\r\n        Éµngcc0.Éµtemplate(2, MatTabGroup_div_2_Template, 4, 12, \"div\", _c26);\r\n        Éµngcc0.ÉµelementEnd();\r\n        Éµngcc0.ÉµelementStart(3, \"div\", _c27, _c28);\r\n        Éµngcc0.Éµtemplate(5, MatTabGroup_mat_tab_body_5_Template, 1, 5, \"mat-tab-body\", _c29);\r\n        Éµngcc0.ÉµelementEnd();\r\n    } if (rf & 2) {\r\n        Éµngcc0.Éµselect(0);\r\n        Éµngcc0.ÉµelementProperty(0, \"selectedIndex\", Éµngcc0.Éµbind(ctx.selectedIndex));\r\n        Éµngcc0.ÉµelementProperty(0, \"disableRipple\", Éµngcc0.Éµbind(ctx.disableRipple));\r\n        Éµngcc0.Éµselect(2);\r\n        Éµngcc0.ÉµelementProperty(2, \"ngForOf\", Éµngcc0.Éµbind(ctx._tabs));\r\n        Éµngcc0.Éµselect(5);\r\n        Éµngcc0.ÉµelementProperty(5, \"ngForOf\", Éµngcc0.Éµbind(ctx._tabs));\r\n    } }, directives: [MatTabHeader,\r\n        MatTabLabelWrapper, Éµngcc1.MatRipple, Éµngcc3.CdkMonitorFocus, Éµngcc4.NgForOf, Éµngcc4.NgIf, Éµngcc5.CdkPortalOutlet, MatTabBody], styles: [\".mat-tab-group{display:flex;flex-direction:column}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:0}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media screen and (-ms-high-contrast:active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media screen and (-ms-high-contrast:active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media screen and (-ms-high-contrast:active){.mat-tab-label{opacity:1}}@media (max-width:599px){.mat-tab-label{padding:0 12px}}@media (max-width:959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height .5s cubic-bezier(.35,0,.25,1)}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}\"], encapsulation: 2, changeDetection: 0 });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatTabGroup, [{\r\n        type: Component,\r\n        args: [{ selector: 'mat-tab-group',\r\n                exportAs: 'matTabGroup',\r\n                template: \"<mat-tab-header #tabHeader [selectedIndex]=\\\"selectedIndex\\\" [disableRipple]=\\\"disableRipple\\\" (indexFocused)=\\\"_focusChanged($event)\\\" (selectFocusedIndex)=\\\"selectedIndex = $event\\\"><div class=\\\"mat-tab-label\\\" role=\\\"tab\\\" matTabLabelWrapper mat-ripple cdkMonitorElementFocus *ngFor=\\\"let tab of _tabs; let i = index\\\" [id]=\\\"_getTabLabelId(i)\\\" [attr.tabIndex]=\\\"_getTabIndex(tab, i)\\\" [attr.aria-posinset]=\\\"i + 1\\\" [attr.aria-setsize]=\\\"_tabs.length\\\" [attr.aria-controls]=\\\"_getTabContentId(i)\\\" [attr.aria-selected]=\\\"selectedIndex == i\\\" [attr.aria-label]=\\\"tab.ariaLabel || null\\\" [attr.aria-labelledby]=\\\"(!tab.ariaLabel && tab.ariaLabelledby) ? tab.ariaLabelledby : null\\\" [class.mat-tab-label-active]=\\\"selectedIndex == i\\\" [disabled]=\\\"tab.disabled\\\" [matRippleDisabled]=\\\"tab.disabled || disableRipple\\\" (click)=\\\"_handleClick(tab, tabHeader, i)\\\"><div class=\\\"mat-tab-label-content\\\"><ng-template [ngIf]=\\\"tab.templateLabel\\\"><ng-template [cdkPortalOutlet]=\\\"tab.templateLabel\\\"></ng-template></ng-template><ng-template [ngIf]=\\\"!tab.templateLabel\\\">{{tab.textLabel}}</ng-template></div></div></mat-tab-header><div class=\\\"mat-tab-body-wrapper\\\" #tabBodyWrapper><mat-tab-body role=\\\"tabpanel\\\" *ngFor=\\\"let tab of _tabs; let i = index\\\" [id]=\\\"_getTabContentId(i)\\\" [attr.aria-labelledby]=\\\"_getTabLabelId(i)\\\" [class.mat-tab-body-active]=\\\"selectedIndex == i\\\" [content]=\\\"tab.content\\\" [position]=\\\"tab.position\\\" [origin]=\\\"tab.origin\\\" (_onCentered)=\\\"_removeTabBodyWrapperHeight()\\\" (_onCentering)=\\\"_setTabBodyWrapperHeight($event)\\\"></mat-tab-body></div>\",\r\n                styles: [\".mat-tab-group{display:flex;flex-direction:column}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:0}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media screen and (-ms-high-contrast:active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media screen and (-ms-high-contrast:active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media screen and (-ms-high-contrast:active){.mat-tab-label{opacity:1}}@media (max-width:599px){.mat-tab-label{padding:0 12px}}@media (max-width:959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height .5s cubic-bezier(.35,0,.25,1)}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}\"],\r\n                encapsulation: ViewEncapsulation.None,\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                inputs: ['color', 'disableRipple'],\r\n                host: {\r\n                    'class': 'mat-tab-group',\r\n                    '[class.mat-tab-group-dynamic-height]': 'dynamicHeight',\r\n                    '[class.mat-tab-group-inverted-header]': 'headerPosition === \"below\"'\r\n                }\r\n            }]\r\n    }], function () { return [{ type: ElementRef }, { type: ChangeDetectorRef }]; }, { dynamicHeight: [{\r\n            type: Input\r\n        }], dynamicHeight: [], selectedIndex: [{\r\n            type: Input\r\n        }], selectedIndex: [], backgroundColor: [{\r\n            type: Input\r\n        }], backgroundColor: [], ngAfterContentChecked: [], _indexToSelect: [], _selectedIndex: [], ngAfterContentInit: [], _tabsSubscription: [], ngOnDestroy: [], realignInkBar: [], _focusChanged: [], _createChangeEvent: [], _subscribeToTabLabels: [], _tabLabelSubscription: [], _clampTabIndex: [], _getTabLabelId: [], _getTabContentId: [], _setTabBodyWrapperHeight: [], _removeTabBodyWrapperHeight: [], _tabBodyWrapperHeight: [], _handleClick: [], _getTabIndex: [], _tabs: [{\r\n            type: ContentChildren,\r\n            args: [MatTab]\r\n        }], _tabBodyWrapper: [{\r\n            type: ViewChild,\r\n            args: ['tabBodyWrapper']\r\n        }], _tabHeader: [{\r\n            type: ViewChild,\r\n            args: ['tabHeader']\r\n        }], headerPosition: [{\r\n            type: Input\r\n        }], selectedIndexChange: [{\r\n            type: Output\r\n        }], focusChange: [{\r\n            type: Output\r\n        }], animationDone: [{\r\n            type: Output\r\n        }], selectedTabChange: [{\r\n            type: Output\r\n        }] });\n    return MatTabGroup;\n}(_MatTabGroupMixinBase));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * \\@docs-private\n */\nvar  /**\n * \\@docs-private\n */\nMatTabNavBase = /** @class */ (function () {\n    function MatTabNavBase(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n    return MatTabNavBase;\n}());\n/** @type {?} */\nvar _MatTabNavMixinBase = mixinDisableRipple(mixinColor(MatTabNavBase, 'primary'));\n/**\n * Navigation component matching the styles of the tab group header.\n * Provides anchored navigation with animated ink bar.\n */\nvar MatTabNav = /** @class */ (function (_super) {\n    __extends(MatTabNav, _super);\n    function MatTabNav(elementRef, _dir, _ngZone, _changeDetectorRef, _viewportRuler) {\n        var _this = _super.call(this, elementRef) || this;\n        _this._dir = _dir;\n        _this._ngZone = _ngZone;\n        _this._changeDetectorRef = _changeDetectorRef;\n        _this._viewportRuler = _viewportRuler;\n        /**\n         * Subject that emits when the component has been destroyed.\n         */\n        _this._onDestroy = new Subject();\n        return _this;\n    }\n    Object.defineProperty(MatTabNav.prototype, \"backgroundColor\", {\n        /** Background color of the tab nav. */\n        get: /**\n         * Background color of the tab nav.\n         * @return {?}\n         */\n        function () { return this._backgroundColor; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            /** @type {?} */\n            var nativeElement = this._elementRef.nativeElement;\n            nativeElement.classList.remove(\"mat-background-\" + this.backgroundColor);\n            if (value) {\n                nativeElement.classList.add(\"mat-background-\" + value);\n            }\n            this._backgroundColor = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Notifies the component that the active link has been changed.\n     * @breaking-change 8.0.0 `element` parameter to be removed.\n     */\n    /**\n     * Notifies the component that the active link has been changed.\n     * \\@breaking-change 8.0.0 `element` parameter to be removed.\n     * @param {?} element\n     * @return {?}\n     */\n    MatTabNav.prototype.updateActiveLink = /**\n     * Notifies the component that the active link has been changed.\n     * \\@breaking-change 8.0.0 `element` parameter to be removed.\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        // Note: keeping the `element` for backwards-compat, but isn't being used for anything.\n        // @breaking-change 8.0.0\n        this._activeLinkChanged = !!element;\n        this._changeDetectorRef.markForCheck();\n    };\n    /**\n     * @return {?}\n     */\n    MatTabNav.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._ngZone.runOutsideAngular(function () {\n            /** @type {?} */\n            var dirChange = _this._dir ? _this._dir.change : of(null);\n            return merge(dirChange, _this._viewportRuler.change(10))\n                .pipe(takeUntil(_this._onDestroy))\n                .subscribe(function () { return _this._alignInkBar(); });\n        });\n    };\n    /** Checks if the active link has been changed and, if so, will update the ink bar. */\n    /**\n     * Checks if the active link has been changed and, if so, will update the ink bar.\n     * @return {?}\n     */\n    MatTabNav.prototype.ngAfterContentChecked = /**\n     * Checks if the active link has been changed and, if so, will update the ink bar.\n     * @return {?}\n     */\n    function () {\n        if (this._activeLinkChanged) {\n            /** @type {?} */\n            var activeTab = this._tabLinks.find(function (tab) { return tab.active; });\n            this._activeLinkElement = activeTab ? activeTab._elementRef : null;\n            this._alignInkBar();\n            this._activeLinkChanged = false;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatTabNav.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._onDestroy.next();\n        this._onDestroy.complete();\n    };\n    /** Aligns the ink bar to the active link. */\n    /**\n     * Aligns the ink bar to the active link.\n     * @return {?}\n     */\n    MatTabNav.prototype._alignInkBar = /**\n     * Aligns the ink bar to the active link.\n     * @return {?}\n     */\n    function () {\n        if (this._activeLinkElement) {\n            this._inkBar.show();\n            this._inkBar.alignToElement(this._activeLinkElement.nativeElement);\n        }\n        else {\n            this._inkBar.hide();\n        }\n    };\n    /** @nocollapse */\n    MatTabNav.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: Directionality, decorators: [{ type: Optional }] },\n        { type: NgZone },\n        { type: ChangeDetectorRef },\n        { type: ViewportRuler }\n    ]; };\n    MatTabNav.propDecorators = {\n        _inkBar: [{ type: ViewChild, args: [MatInkBar,] }],\n        _tabLinks: [{ type: ContentChildren, args: [forwardRef(function () { return MatTabLink; }), { descendants: true },] }],\n        backgroundColor: [{ type: Input }]\n    };\nMatTabNav.ngComponentDef = Éµngcc0.ÉµdefineComponent({ type: MatTabNav, selectors: [[\"\", \"mat-tab-nav-bar\", \"\"]], factory: function MatTabNav_Factory(t) { return new (t || MatTabNav)(Éµngcc0.ÉµdirectiveInject(ElementRef), Éµngcc0.ÉµdirectiveInject(Directionality, 8), Éµngcc0.ÉµdirectiveInject(NgZone), Éµngcc0.ÉµdirectiveInject(ChangeDetectorRef), Éµngcc0.ÉµdirectiveInject(ViewportRuler)); }, contentQueries: function MatTabNav_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµcontentQuery(dirIndex, MatTabLink, true, null);\r\n    } if (rf & 2) {\r\n        var _t;\r\n        (Éµngcc0.ÉµqueryRefresh(_t = Éµngcc0.ÉµloadContentQuery()) && (ctx._tabLinks = _t));\r\n    } }, viewQuery: function MatTabNav_Query(rf, ctx) { if (rf & 1) {\r\n        Éµngcc0.ÉµviewQuery(MatInkBar, true, null);\r\n    } if (rf & 2) {\r\n        var _t;\r\n        (Éµngcc0.ÉµqueryRefresh(_t = Éµngcc0.ÉµloadViewQuery()) && (ctx._inkBar = _t.first));\r\n    } }, hostBindings: function MatTabNav_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµelementHostAttrs(_c37);\r\n    } }, inputs: { color: \"color\", disableRipple: \"disableRipple\", backgroundColor: \"backgroundColor\" }, exportAs: [\"matTabNavBar\", \"matTabNav\"], features: [Éµngcc0.ÉµInheritDefinitionFeature], attrs: _c38, ngContentSelectors: _c1, consts: 3, vars: 0, template: function MatTabNav_Template(rf, ctx) { if (rf & 1) {\r\n        Éµngcc0.ÉµprojectionDef();\r\n        Éµngcc0.ÉµelementStart(0, \"div\", _c39);\r\n        Éµngcc0.Éµlistener(\"cdkObserveContent\", function MatTabNav_Template_div_cdkObserveContent_0_listener($event) { return ctx._alignInkBar(); });\r\n        Éµngcc0.Éµprojection(1);\r\n        Éµngcc0.Éµelement(2, \"mat-ink-bar\");\r\n        Éµngcc0.ÉµelementEnd();\r\n    } }, directives: [Éµngcc2.CdkObserveContent, MatInkBar], styles: [\".mat-tab-nav-bar{overflow:hidden;position:relative;flex-shrink:0}.mat-tab-links{position:relative;display:flex}.mat-tab-link{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;vertical-align:top;text-decoration:none;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.mat-tab-link:focus{outline:0}.mat-tab-link:focus:not(.mat-tab-disabled){opacity:1}@media screen and (-ms-high-contrast:active){.mat-tab-link:focus{outline:dotted 2px}}.mat-tab-link.mat-tab-disabled{cursor:default}@media screen and (-ms-high-contrast:active){.mat-tab-link.mat-tab-disabled{opacity:.5}}.mat-tab-link .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media screen and (-ms-high-contrast:active){.mat-tab-link{opacity:1}}[mat-stretch-tabs] .mat-tab-link{flex-basis:0;flex-grow:1}.mat-tab-link.mat-tab-disabled{pointer-events:none}@media (max-width:599px){.mat-tab-link{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media screen and (-ms-high-contrast:active){.mat-ink-bar{outline:solid 2px;height:0}}\"], encapsulation: 2, changeDetection: 0 });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatTabNav, [{\r\n        type: Component,\r\n        args: [{ selector: '[mat-tab-nav-bar]',\r\n                exportAs: 'matTabNavBar, matTabNav',\r\n                inputs: ['color', 'disableRipple'],\r\n                template: \"<div class=\\\"mat-tab-links\\\" (cdkObserveContent)=\\\"_alignInkBar()\\\"><ng-content></ng-content><mat-ink-bar></mat-ink-bar></div>\",\r\n                styles: [\".mat-tab-nav-bar{overflow:hidden;position:relative;flex-shrink:0}.mat-tab-links{position:relative;display:flex}.mat-tab-link{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;vertical-align:top;text-decoration:none;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.mat-tab-link:focus{outline:0}.mat-tab-link:focus:not(.mat-tab-disabled){opacity:1}@media screen and (-ms-high-contrast:active){.mat-tab-link:focus{outline:dotted 2px}}.mat-tab-link.mat-tab-disabled{cursor:default}@media screen and (-ms-high-contrast:active){.mat-tab-link.mat-tab-disabled{opacity:.5}}.mat-tab-link .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media screen and (-ms-high-contrast:active){.mat-tab-link{opacity:1}}[mat-stretch-tabs] .mat-tab-link{flex-basis:0;flex-grow:1}.mat-tab-link.mat-tab-disabled{pointer-events:none}@media (max-width:599px){.mat-tab-link{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media screen and (-ms-high-contrast:active){.mat-ink-bar{outline:solid 2px;height:0}}\"],\r\n                host: { 'class': 'mat-tab-nav-bar' },\r\n                encapsulation: ViewEncapsulation.None,\r\n                changeDetection: ChangeDetectionStrategy.OnPush\r\n            }]\r\n    }], function () { return [{ type: ElementRef }, { type: Directionality, decorators: [{\r\n                type: Optional\r\n            }] }, { type: NgZone }, { type: ChangeDetectorRef }, { type: ViewportRuler }]; }, { backgroundColor: [{\r\n            type: Input\r\n        }], backgroundColor: [], updateActiveLink: [], _activeLinkChanged: [], ngAfterContentInit: [], ngAfterContentChecked: [], _activeLinkElement: [], ngOnDestroy: [], _alignInkBar: [], _inkBar: [{\r\n            type: ViewChild,\r\n            args: [MatInkBar]\r\n        }], _tabLinks: [{\r\n            type: ContentChildren,\r\n            args: [forwardRef(function () { return MatTabLink; }), { descendants: true }]\r\n        }] });\n    return MatTabNav;\n}(_MatTabNavMixinBase));\nvar MatTabLinkBase = /** @class */ (function () {\n    function MatTabLinkBase() {\n    }\n    return MatTabLinkBase;\n}());\n/** @type {?} */\nvar _MatTabLinkMixinBase = mixinTabIndex(mixinDisableRipple(mixinDisabled(MatTabLinkBase)));\n/**\n * Link inside of a `mat-tab-nav-bar`.\n */\nvar MatTabLink = /** @class */ (function (_super) {\n    __extends(MatTabLink, _super);\n    function MatTabLink(_tabNavBar, _elementRef, ngZone, platform, globalOptions, tabIndex, _focusMonitor) {\n        var _this = _super.call(this) || this;\n        _this._tabNavBar = _tabNavBar;\n        _this._elementRef = _elementRef;\n        _this._focusMonitor = _focusMonitor;\n        /**\n         * Whether the tab link is active or not.\n         */\n        _this._isActive = false;\n        /**\n         * Whether the ripples are globally disabled through the RippleGlobalOptions\n         */\n        _this._ripplesGloballyDisabled = false;\n        /**\n         * Ripple configuration for ripples that are launched on pointer down.\n         * \\@docs-private\n         */\n        _this.rippleConfig = {};\n        _this._tabLinkRipple = new RippleRenderer(_this, ngZone, _elementRef, platform);\n        _this._tabLinkRipple.setupTriggerEvents(_elementRef.nativeElement);\n        _this.tabIndex = parseInt(tabIndex) || 0;\n        if (globalOptions) {\n            // TODO(paul): Do not copy each option manually. Allow dynamic global option changes: #9729\n            _this._ripplesGloballyDisabled = !!globalOptions.disabled;\n            _this.rippleConfig = {\n                terminateOnPointerUp: globalOptions.terminateOnPointerUp,\n                animation: globalOptions.animation,\n            };\n        }\n        if (_focusMonitor) {\n            _focusMonitor.monitor(_elementRef);\n        }\n        return _this;\n    }\n    Object.defineProperty(MatTabLink.prototype, \"active\", {\n        /** Whether the link is active. */\n        get: /**\n         * Whether the link is active.\n         * @return {?}\n         */\n        function () { return this._isActive; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (value !== this._isActive) {\n                this._isActive = value;\n                this._tabNavBar.updateActiveLink(this._elementRef);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTabLink.prototype, \"rippleDisabled\", {\n        /**\n         * Whether ripples are disabled on interaction\n         * @docs-private\n         */\n        get: /**\n         * Whether ripples are disabled on interaction\n         * \\@docs-private\n         * @return {?}\n         */\n        function () {\n            return this.disabled || this.disableRipple || this._tabNavBar.disableRipple ||\n                this._ripplesGloballyDisabled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatTabLink.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._tabLinkRipple._removeTriggerEvents();\n        if (this._focusMonitor) {\n            this._focusMonitor.stopMonitoring(this._elementRef);\n        }\n    };\n    /** @nocollapse */\n    MatTabLink.ctorParameters = function () { return [\n        { type: MatTabNav },\n        { type: ElementRef },\n        { type: NgZone },\n        { type: Platform },\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_RIPPLE_GLOBAL_OPTIONS,] }] },\n        { type: String, decorators: [{ type: Attribute, args: ['tabindex',] }] },\n        { type: FocusMonitor }\n    ]; };\n    MatTabLink.propDecorators = {\n        active: [{ type: Input }]\n    };\nMatTabLink.ngDirectiveDef = Éµngcc0.ÉµdefineDirective({ type: MatTabLink, selectors: [[\"\", \"mat-tab-link\", \"\"], [\"\", \"matTabLink\", \"\"]], factory: function MatTabLink_Factory(t) { return new (t || MatTabLink)(Éµngcc0.ÉµdirectiveInject(MatTabNav), Éµngcc0.ÉµdirectiveInject(ElementRef), Éµngcc0.ÉµdirectiveInject(NgZone), Éµngcc0.ÉµdirectiveInject(Platform), Éµngcc0.ÉµdirectiveInject(MAT_RIPPLE_GLOBAL_OPTIONS, 8), Éµngcc0.ÉµinjectAttribute('tabindex'), Éµngcc0.ÉµdirectiveInject(FocusMonitor)); }, hostBindings: function MatTabLink_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        Éµngcc0.ÉµallocHostVars(3);\r\n        Éµngcc0.ÉµelementHostAttrs(_c40);\r\n        Éµngcc0.ÉµelementHostStyling(_c41);\r\n    } if (rf & 2) {\r\n        Éµngcc0.ÉµelementAttribute(elIndex, \"aria-current\", Éµngcc0.Éµbind(ctx.active));\r\n        Éµngcc0.ÉµelementAttribute(elIndex, \"aria-disabled\", Éµngcc0.Éµbind(ctx.disabled.toString()));\r\n        Éµngcc0.ÉµelementAttribute(elIndex, \"tabIndex\", Éµngcc0.Éµbind(ctx.tabIndex));\r\n        Éµngcc0.ÉµelementHostClassProp(0, ctx.disabled);\r\n        Éµngcc0.ÉµelementHostClassProp(1, ctx.active);\r\n        Éµngcc0.ÉµelementHostStylingApply();\r\n    } }, inputs: { disabled: \"disabled\", disableRipple: \"disableRipple\", tabIndex: \"tabIndex\", active: \"active\" }, exportAs: [\"matTabLink\"], features: [Éµngcc0.ÉµInheritDefinitionFeature] });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatTabLink, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[mat-tab-link], [matTabLink]',\r\n                exportAs: 'matTabLink',\r\n                inputs: ['disabled', 'disableRipple', 'tabIndex'],\r\n                host: {\r\n                    'class': 'mat-tab-link',\r\n                    '[attr.aria-current]': 'active',\r\n                    '[attr.aria-disabled]': 'disabled.toString()',\r\n                    '[attr.tabIndex]': 'tabIndex',\r\n                    '[class.mat-tab-disabled]': 'disabled',\r\n                    '[class.mat-tab-label-active]': 'active'\r\n                }\r\n            }]\r\n    }], function () { return [{ type: MatTabNav }, { type: ElementRef }, { type: NgZone }, { type: Platform }, { type: undefined, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [MAT_RIPPLE_GLOBAL_OPTIONS]\r\n            }] }, { type: String, decorators: [{\r\n                type: Attribute,\r\n                args: ['tabindex']\r\n            }] }, { type: FocusMonitor }]; }, { active: [{\r\n            type: Input\r\n        }], active: [], rippleDisabled: [], ngOnDestroy: [] });\n    return MatTabLink;\n}(_MatTabLinkMixinBase));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MatTabsModule = /** @class */ (function () {\n    function MatTabsModule() {\n    }\nMatTabsModule.ngModuleDef = Éµngcc0.ÉµdefineNgModule({ type: MatTabsModule });\n/*@__PURE__*/ Éµngcc0.ÉµsetNgModuleScope(MatTabsModule, { declarations: function () { return [MatTabGroup,\r\n        MatTabLabel,\r\n        MatTab,\r\n        MatInkBar,\r\n        MatTabLabelWrapper,\r\n        MatTabNav,\r\n        MatTabLink,\r\n        MatTabBody,\r\n        MatTabBodyPortal,\r\n        MatTabHeader,\r\n        MatTabContent]; }, imports: function () { return [CommonModule,\r\n        MatCommonModule,\r\n        PortalModule,\r\n        MatRippleModule,\r\n        ObserversModule,\r\n        A11yModule]; }, exports: function () { return [MatCommonModule,\r\n        MatTabGroup,\r\n        MatTabLabel,\r\n        MatTab,\r\n        MatTabNav,\r\n        MatTabLink,\r\n        MatTabContent]; } });\n/*@__PURE__*/ Éµngcc0.ÉµsetClassMetadata(MatTabsModule, [{\r\n        type: NgModule,\r\n        args: [{\r\n                imports: [\r\n                    CommonModule,\r\n                    MatCommonModule,\r\n                    PortalModule,\r\n                    MatRippleModule,\r\n                    ObserversModule,\r\n                    A11yModule,\r\n                ],\r\n                // Don't export all components because some are only to be used internally.\r\n                exports: [\r\n                    MatCommonModule,\r\n                    MatTabGroup,\r\n                    MatTabLabel,\r\n                    MatTab,\r\n                    MatTabNav,\r\n                    MatTabLink,\r\n                    MatTabContent,\r\n                ],\r\n                declarations: [\r\n                    MatTabGroup,\r\n                    MatTabLabel,\r\n                    MatTab,\r\n                    MatInkBar,\r\n                    MatTabLabelWrapper,\r\n                    MatTabNav,\r\n                    MatTabLink,\r\n                    MatTabBody,\r\n                    MatTabBodyPortal,\r\n                    MatTabHeader,\r\n                    MatTabContent,\r\n                ]\r\n            }]\r\n    }], function () { return []; }, null);\nMatTabsModule.ngInjectorDef = Éµngcc0.defineInjector({ factory: function MatTabsModule_Factory(t) { return new (t || MatTabsModule)(); }, imports: [[\r\n            CommonModule,\r\n            MatCommonModule,\r\n            PortalModule,\r\n            MatRippleModule,\r\n            ObserversModule,\r\n            A11yModule,\r\n        ],\r\n        MatCommonModule] });\n    return MatTabsModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\nexport { MatInkBar, _MAT_INK_BAR_POSITIONER, MatTabBody, MatTabBodyPortal, MatTabHeader, MatTabLabelWrapper, MatTab, MatTabLabel, MatTabNav, MatTabLink, MatTabContent, MatTabsModule, MatTabChangeEvent, MatTabGroupBase, _MatTabGroupMixinBase, MatTabGroup, matTabsAnimations, _MAT_INK_BAR_POSITIONER_FACTORY as Éµa23, MatTabBase as Éµf23, _MatTabMixinBase as Éµg23, MatTabHeaderBase as Éµb23, _MatTabHeaderMixinBase as Éµc23, MatTabLabelWrapperBase as Éµd23, _MatTabLabelWrapperMixinBase as Éµe23, MatTabLinkBase as Éµj23, MatTabNavBase as Éµh23, _MatTabLinkMixinBase as Éµk23, _MatTabNavMixinBase as Éµi23 };\n\n//# sourceMappingURL=tabs.es5.js.map","/* tslint:disable component-selector */\nimport { Component, ViewChild, Input, ViewChildren, QueryList } from '@angular/core';\nimport { CodeComponent } from './code.component';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/material\";\nimport * as i2 from \"@angular/common\";\nimport * as i3 from \"./code.component\";\nvar _c0 = [\"content\"];\nvar _c1 = [2, \"display\", \"none\"];\nvar _c2 = [\"content\", \"\"];\nvar _c3 = [\"disableRipple\", \"\", 1, \"code-tab-group\"];\nvar _c4 = [\"style\", \"overflow-y: hidden;\", 4, \"ngFor\", \"ngForOf\"];\nvar _c5 = [2, \"overflow-y\", \"hidden\"];\nvar _c6 = [\"mat-tab-label\", \"\"];\nvar _c7 = [3, \"language\", \"linenums\", \"path\", \"region\", \"header\"];\nfunction CodeTabsComponent_mat_tab_5_ng_template_1_Template(rf, ctx) { if (rf & 1) {\n    i0.ÉµelementStart(0, \"span\");\n    i0.ÉµelementStyling();\n    i0.Éµtext(1);\n    i0.ÉµelementEnd();\n} if (rf & 2) {\n    var tab_r90 = i0.ÉµnextContext().$implicit;\n    i0.ÉµelementStylingMap(0, i0.Éµinterpolation1(\"\", tab_r90.class, \"\"));\n    i0.ÉµelementStylingApply(0);\n    i0.Éµselect(1);\n    i0.ÉµtextBinding(1, i0.Éµinterpolation1(\"\", tab_r90.header, \"\"));\n} }\nfunction CodeTabsComponent_mat_tab_5_Template(rf, ctx) { if (rf & 1) {\n    i0.ÉµelementStart(0, \"mat-tab\", _c5);\n    i0.Éµtemplate(1, CodeTabsComponent_mat_tab_5_ng_template_1_Template, 2, 2, \"ng-template\", _c6);\n    i0.ÉµelementStart(2, \"aio-code\", _c7);\n    i0.ÉµelementStyling();\n    i0.ÉµelementEnd();\n    i0.ÉµelementEnd();\n} if (rf & 2) {\n    var tab_r90 = ctx.$implicit;\n    i0.ÉµelementStylingMap(2, i0.Éµinterpolation1(\"\", tab_r90.class, \"\"));\n    i0.ÉµelementStylingApply(2);\n    i0.Éµselect(2);\n    i0.ÉµelementProperty(2, \"language\", i0.Éµbind(tab_r90.language));\n    i0.ÉµelementProperty(2, \"linenums\", i0.Éµbind(tab_r90.linenums));\n    i0.ÉµelementProperty(2, \"path\", i0.Éµbind(tab_r90.path));\n    i0.ÉµelementProperty(2, \"region\", i0.Éµbind(tab_r90.region));\n    i0.ÉµelementProperty(2, \"header\", i0.Éµbind(tab_r90.header));\n} }\nvar _c8 = [];\n/**\n * Renders a set of tab group of code snippets.\n *\n * The innerHTML of the `<code-tabs>` component should contain `<code-pane>` elements.\n * Each `<code-pane>` has the same interface as the embedded `<code-example>` component.\n * The optional `linenums` attribute is the default `linenums` for each code pane.\n */\nvar CodeTabsComponent = /** @class */ (function () {\n    function CodeTabsComponent() {\n    }\n    CodeTabsComponent.prototype.ngOnInit = function () {\n        this.tabs = [];\n        var codeExamples = this.content.nativeElement.querySelectorAll('code-pane');\n        for (var i = 0; i < codeExamples.length; i++) {\n            var tabContent = codeExamples[i];\n            this.tabs.push(this.getTabInfo(tabContent));\n        }\n    };\n    CodeTabsComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        this.codeComponents.toArray().forEach(function (codeComponent, i) {\n            codeComponent.code = _this.tabs[i].code;\n        });\n    };\n    /** Gets the extracted TabInfo data from the provided code-pane element. */\n    CodeTabsComponent.prototype.getTabInfo = function (tabContent) {\n        return {\n            class: tabContent.getAttribute('class'),\n            code: tabContent.innerHTML,\n            language: tabContent.getAttribute('language'),\n            linenums: tabContent.getAttribute('linenums') || this.linenums,\n            path: tabContent.getAttribute('path') || '',\n            region: tabContent.getAttribute('region') || '',\n            header: tabContent.getAttribute('header')\n        };\n    };\n    CodeTabsComponent.ngComponentDef = i0.ÉµdefineComponent({ type: CodeTabsComponent, selectors: [[\"code-tabs\"]], factory: function CodeTabsComponent_Factory(t) { return new (t || CodeTabsComponent)(); }, viewQuery: function CodeTabsComponent_Query(rf, ctx) { if (rf & 1) {\n            i0.ÉµviewQuery(_c0, true, null);\n            i0.ÉµviewQuery(CodeComponent, true, null);\n        } if (rf & 2) {\n            var _t;\n            (i0.ÉµqueryRefresh((_t = i0.ÉµloadViewQuery())) && (ctx.content = _t.first));\n            (i0.ÉµqueryRefresh((_t = i0.ÉµloadViewQuery())) && (ctx.codeComponents = _t));\n        } }, inputs: { linenums: \"linenums\" }, ngContentSelectors: _c8, consts: 6, vars: 1, template: function CodeTabsComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ÉµprojectionDef();\n            i0.ÉµelementStart(0, \"div\", _c1, _c2);\n            i0.Éµprojection(2);\n            i0.ÉµelementEnd();\n            i0.ÉµelementStart(3, \"mat-card\");\n            i0.ÉµelementStart(4, \"mat-tab-group\", _c3);\n            i0.Éµtemplate(5, CodeTabsComponent_mat_tab_5_Template, 3, 6, \"mat-tab\", _c4);\n            i0.ÉµelementEnd();\n            i0.ÉµelementEnd();\n        } if (rf & 2) {\n            i0.Éµselect(5);\n            i0.ÉµelementProperty(5, \"ngForOf\", i0.Éµbind(ctx.tabs));\n        } }, directives: [i1.MatCard, i1.MatTabGroup, i2.NgForOf, i1.MatTab, i1.MatTabLabel, i3.CodeComponent], encapsulation: 2 });\n    return CodeTabsComponent;\n}());\nexport { CodeTabsComponent };\n/*@__PURE__*/ i0.ÉµsetClassMetadata(CodeTabsComponent, [{\n        type: Component,\n        args: [{\n                selector: 'code-tabs',\n                template: \"\\n    <!-- Use content projection so that the provided HTML's code-panes can be split into tabs -->\\n    <div #content style=\\\"display: none\\\"><ng-content></ng-content></div>\\n\\n    <mat-card>\\n      <mat-tab-group class=\\\"code-tab-group\\\" disableRipple>\\n        <mat-tab style=\\\"overflow-y: hidden;\\\" *ngFor=\\\"let tab of tabs\\\">\\n          <ng-template mat-tab-label>\\n            <span class=\\\"{{ tab.class }}\\\">{{ tab.header }}</span>\\n          </ng-template>\\n          <aio-code class=\\\"{{ tab.class }}\\\"\\n                    [language]=\\\"tab.language\\\"\\n                    [linenums]=\\\"tab.linenums\\\"\\n                    [path]=\\\"tab.path\\\"\\n                    [region]=\\\"tab.region\\\"\\n                    [header]=\\\"tab.header\\\">\\n          </aio-code>\\n        </mat-tab>\\n      </mat-tab-group>\\n    </mat-card>\\n  \",\n            }]\n    }], null, { linenums: [{\n            type: Input\n        }], content: [{\n            type: ViewChild,\n            args: ['content']\n        }], codeComponents: [{\n            type: ViewChildren,\n            args: [CodeComponent]\n        }] });\n","/* tslint:disable component-selector */\nimport { Component, AfterViewInit, ViewChild, Input, ViewChildren, QueryList, OnInit } from '@angular/core';\nimport { CodeComponent } from './code.component';\n\nexport interface TabInfo {\n  class: string|null;\n  code: string;\n  language: string|null;\n  linenums: any;\n  path: string;\n  region: string;\n  header: string|null;\n}\n\n/**\n * Renders a set of tab group of code snippets.\n *\n * The innerHTML of the `<code-tabs>` component should contain `<code-pane>` elements.\n * Each `<code-pane>` has the same interface as the embedded `<code-example>` component.\n * The optional `linenums` attribute is the default `linenums` for each code pane.\n */\n@Component({\n  selector: 'code-tabs',\n  template: `\n    <!-- Use content projection so that the provided HTML's code-panes can be split into tabs -->\n    <div #content style=\"display: none\"><ng-content></ng-content></div>\n\n    <mat-card>\n      <mat-tab-group class=\"code-tab-group\" disableRipple>\n        <mat-tab style=\"overflow-y: hidden;\" *ngFor=\"let tab of tabs\">\n          <ng-template mat-tab-label>\n            <span class=\"{{ tab.class }}\">{{ tab.header }}</span>\n          </ng-template>\n          <aio-code class=\"{{ tab.class }}\"\n                    [language]=\"tab.language\"\n                    [linenums]=\"tab.linenums\"\n                    [path]=\"tab.path\"\n                    [region]=\"tab.region\"\n                    [header]=\"tab.header\">\n          </aio-code>\n        </mat-tab>\n      </mat-tab-group>\n    </mat-card>\n  `,\n})\nexport class CodeTabsComponent implements OnInit, AfterViewInit {\n  tabs: TabInfo[];\n\n  @Input() linenums: string;\n\n  @ViewChild('content') content;\n\n  @ViewChildren(CodeComponent) codeComponents: QueryList<CodeComponent>;\n\n  ngOnInit() {\n    this.tabs = [];\n    const codeExamples = this.content.nativeElement.querySelectorAll('code-pane');\n\n    for (let i = 0; i < codeExamples.length; i++) {\n      const tabContent = codeExamples[i];\n      this.tabs.push(this.getTabInfo(tabContent));\n    }\n  }\n\n  ngAfterViewInit() {\n    this.codeComponents.toArray().forEach((codeComponent, i) => {\n      codeComponent.code = this.tabs[i].code;\n    });\n  }\n\n  /** Gets the extracted TabInfo data from the provided code-pane element. */\n  private getTabInfo(tabContent: HTMLElement): TabInfo {\n    return {\n      class: tabContent.getAttribute('class'),\n      code: tabContent.innerHTML,\n      language: tabContent.getAttribute('language'),\n      linenums: tabContent.getAttribute('linenums') || this.linenums,\n      path: tabContent.getAttribute('path') || '',\n      region: tabContent.getAttribute('region') || '',\n      header: tabContent.getAttribute('header')\n    };\n  }\n}\n","import { NgModule, Type } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { CodeTabsComponent } from './code-tabs.component';\nimport { MatCardModule, MatTabsModule } from '@angular/material';\nimport { CodeModule } from './code.module';\nimport { WithCustomElementComponent } from '../element-registry';\n\n@NgModule({\n  imports: [ CommonModule, MatCardModule, MatTabsModule, CodeModule ],\n  declarations: [ CodeTabsComponent ],\n  exports: [ CodeTabsComponent ],\n  entryComponents: [ CodeTabsComponent ]\n})\nexport class CodeTabsModule implements WithCustomElementComponent {\n  customElementComponent: Type<any> = CodeTabsComponent;\n}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { CodeTabsComponent } from './code-tabs.component';\nimport { MatCardModule, MatTabsModule } from '@angular/material';\nimport { CodeModule } from './code.module';\nimport * as i0 from \"@angular/core\";\nvar CodeTabsModule = /** @class */ (function () {\n    function CodeTabsModule() {\n        this.customElementComponent = CodeTabsComponent;\n    }\n    CodeTabsModule.ngModuleDef = i0.ÉµdefineNgModule({ type: CodeTabsModule });\n    CodeTabsModule.ngInjectorDef = i0.defineInjector({ factory: function CodeTabsModule_Factory(t) { return new (t || CodeTabsModule)(); }, imports: [[CommonModule, MatCardModule, MatTabsModule, CodeModule]] });\n    return CodeTabsModule;\n}());\nexport { CodeTabsModule };\n/*@__PURE__*/ i0.ÉµsetNgModuleScope(CodeTabsModule, { declarations: [CodeTabsComponent], imports: [CommonModule, MatCardModule, MatTabsModule, CodeModule], exports: [CodeTabsComponent] });\n/*@__PURE__*/ i0.ÉµsetClassMetadata(CodeTabsModule, [{\n        type: NgModule,\n        args: [{\n                imports: [CommonModule, MatCardModule, MatTabsModule, CodeModule],\n                declarations: [CodeTabsComponent],\n                exports: [CodeTabsComponent],\n                entryComponents: [CodeTabsComponent]\n            }]\n    }], null, null);\n","import * as i0 from '@angular/core';\nimport {CodeTabsModule} from './code-tabs.module';\nexport const CodeTabsModuleNgFactory = new i0.ÉµNgModuleFactory(CodeTabsModule);\nexport const ÉµNonEmptyModule = true;"],"sourceRoot":""}